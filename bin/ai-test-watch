#!/bin/bash
#
# AI Company Test Watch Command
# ファイル変更を監視して自動的にテストを実行
#

# プロジェクトディレクトリ
PROJECT_DIR="/home/aicompany/ai_co"
VENV_PATH="$PROJECT_DIR/venv"
AUTO_TEST_SCRIPT="$PROJECT_DIR/scripts/auto_test_on_change.py"

# 色定義
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# 監視対象ディレクトリ
WATCH_DIRS=(
    "$PROJECT_DIR/core"
    "$PROJECT_DIR/workers"
    "$PROJECT_DIR/libs"
    "$PROJECT_DIR/tests"
)

# ヘルプ表示
show_help() {
    echo "AI Company Test Watch Command"
    echo ""
    echo "使用方法: ai-test-watch [オプション]"
    echo ""
    echo "オプション:"
    echo "  -i, --interval SECONDS  チェック間隔（デフォルト: 2秒）"
    echo "  -a, --auto-fix         テスト失敗時に自動修正を試みる"
    echo "  -n, --notify           テスト結果をSlack通知"
    echo "  -h, --help             このヘルプを表示"
    echo ""
    echo "終了: Ctrl+C"
}

# ファイル変更の検知
detect_changes() {
    local checksum_file="/tmp/ai_company_watch_checksum"
    local new_checksum_file="/tmp/ai_company_watch_checksum_new"
    
    # チェックサムを計算
    find "${WATCH_DIRS[@]}" -name "*.py" -type f -exec md5sum {} \; 2>/dev/null | sort > "$new_checksum_file"
    
    # 初回実行時
    if [ ! -f "$checksum_file" ]; then
        mv "$new_checksum_file" "$checksum_file"
        return 1  # 変更なし
    fi
    
    # 差分チェック
    if ! diff -q "$checksum_file" "$new_checksum_file" > /dev/null 2>&1; then
        # 変更されたファイルを表示
        echo -e "${YELLOW}📝 変更を検出:${NC}"
        diff "$checksum_file" "$new_checksum_file" | grep "^[<>]" | cut -d' ' -f3 | sort | uniq | while read file; do
            if [ -f "$file" ]; then
                echo -e "  ${BLUE}↻${NC} $(basename "$file")"
            fi
        done
        
        mv "$new_checksum_file" "$checksum_file"
        return 0  # 変更あり
    else
        rm "$new_checksum_file"
        return 1  # 変更なし
    fi
}

# テスト実行
run_tests() {
    local start_time=$(date +%s)
    
    echo -e "\n${GREEN}🧪 テスト実行中...${NC}"
    
    # 仮想環境をアクティベート
    source "$VENV_PATH/bin/activate"
    
    # 自動テストスクリプトを実行
    python3 "$AUTO_TEST_SCRIPT"
    local result=$?
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    if [ $result -eq 0 ]; then
        echo -e "${GREEN}✅ テスト成功 (${duration}秒)${NC}"
        
        # 成功時の通知
        if [ "$NOTIFY_SLACK" = true ]; then
            notify_slack "✅ テスト成功 - 変更は安全です (${duration}秒)"
        fi
    else
        echo -e "${RED}❌ テスト失敗 (${duration}秒)${NC}"
        
        # 失敗時の通知
        if [ "$NOTIFY_SLACK" = true ]; then
            notify_slack "❌ テスト失敗 - 修正が必要です"
        fi
        
        # 自動修正を試みる
        if [ "$AUTO_FIX" = true ]; then
            echo -e "${YELLOW}🔧 自動修正を試みています...${NC}"
            # TODO: 自動修正ロジックの実装
        fi
    fi
    
    return $result
}

# Slack通知
notify_slack() {
    local message="$1"
    
    if [ -f "$PROJECT_DIR/libs/slack_notifier.py" ]; then
        python3 -c "
from libs.slack_notifier import SlackNotifier
notifier = SlackNotifier()
notifier.send_message('🔍 Test Watch: $message')
" 2>/dev/null
    fi
}

# 統計情報表示
show_stats() {
    echo -e "\n${PURPLE}📊 監視統計:${NC}"
    echo -e "  チェック回数: $CHECK_COUNT"
    echo -e "  変更検出回数: $CHANGE_COUNT"
    echo -e "  テスト実行回数: $TEST_COUNT"
    echo -e "  成功回数: $SUCCESS_COUNT"
    echo -e "  失敗回数: $FAIL_COUNT"
}

# シグナルハンドラ
cleanup() {
    echo -e "\n\n${BLUE}👋 監視を終了します${NC}"
    show_stats
    rm -f /tmp/ai_company_watch_checksum*
    exit 0
}

# メイン処理
main() {
    # デフォルト値
    INTERVAL=2
    AUTO_FIX=false
    NOTIFY_SLACK=false
    
    # 引数解析
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -i|--interval)
                INTERVAL="$2"
                shift 2
                ;;
            -a|--auto-fix)
                AUTO_FIX=true
                shift
                ;;
            -n|--notify)
                NOTIFY_SLACK=true
                shift
                ;;
            *)
                echo -e "${RED}❌ 不明なオプション: $1${NC}"
                show_help
                exit 1
                ;;
        esac
    done
    
    # シグナルハンドラ設定
    trap cleanup SIGINT SIGTERM
    
    # カウンター初期化
    CHECK_COUNT=0
    CHANGE_COUNT=0
    TEST_COUNT=0
    SUCCESS_COUNT=0
    FAIL_COUNT=0
    
    # 初期メッセージ
    echo -e "${GREEN}🔍 AI Company Test Watch${NC}"
    echo -e "${BLUE}監視中のディレクトリ:${NC}"
    for dir in "${WATCH_DIRS[@]}"; do
        echo -e "  📁 $dir"
    done
    echo -e "${BLUE}チェック間隔: ${INTERVAL}秒${NC}"
    echo -e "${YELLOW}終了するには Ctrl+C を押してください${NC}\n"
    
    # 初回のチェックサム作成
    detect_changes > /dev/null 2>&1
    
    # 監視ループ
    while true; do
        CHECK_COUNT=$((CHECK_COUNT + 1))
        
        # プログレス表示
        echo -ne "\r${BLUE}⏳ チェック中... (#$CHECK_COUNT)${NC}"
        
        # 変更検知
        if detect_changes; then
            CHANGE_COUNT=$((CHANGE_COUNT + 1))
            
            # 少し待機（連続した変更をまとめるため）
            sleep 0.5
            
            # テスト実行
            TEST_COUNT=$((TEST_COUNT + 1))
            if run_tests; then
                SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            else
                FAIL_COUNT=$((FAIL_COUNT + 1))
            fi
            
            echo -e "\n${BLUE}監視を継続します...${NC}"
        else
            # 変更なしの場合は改行をクリア
            echo -ne "\r                                        \r"
        fi
        
        # 指定された間隔で待機
        sleep "$INTERVAL"
    done
}

# 実行前チェック
if [ ! -d "$PROJECT_DIR" ]; then
    echo -e "${RED}❌ プロジェクトディレクトリが見つかりません: $PROJECT_DIR${NC}"
    exit 1
fi

if [ ! -f "$AUTO_TEST_SCRIPT" ]; then
    echo -e "${RED}❌ 自動テストスクリプトが見つかりません: $AUTO_TEST_SCRIPT${NC}"
    exit 1
fi

# 実行
main "$@"
