#!/usr/bin/env python3
"""
AI Company Project Manager
ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆã€ç®¡ç†ã€çµ„ç¹”åŒ–ã‚’è‡ªå‹•åŒ–
"""

import argparse
import json
import os
import shutil
import sys
from datetime import datetime
from pathlib import Path


class ProjectManager:
    """AI Companyãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†"""

    def __init__(self):
        self.ai_company_root = Path("/home/aicompany/ai_co")
        self.projects_root = Path("/home/aicompany/projects")
        self.projects_root.mkdir(exist_ok=True)

    def create_project(
        self, project_name: str, project_type: str = "general", template: str = None
    ) -> Path:
        """æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ"""

        # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåã®æ­£è¦åŒ–
        safe_name = self._sanitize_project_name(project_name)
        project_path = self.projects_root / safe_name

        # æ—¢å­˜ãƒã‚§ãƒƒã‚¯
        if project_path.exists():
            counter = 1
            while (self.projects_root / f"{safe_name}_{counter}").exists():
                counter += 1
            project_path = self.projects_root / f"{safe_name}_{counter}"

        # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
        project_path.mkdir(parents=True, exist_ok=True)

        # åŸºæœ¬æ§‹é€ ä½œæˆ
        self._create_project_structure(project_path, project_type)

        # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
        self._create_project_config(project_path, project_name, project_type)

        # ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆé©ç”¨
        if template:
            self._apply_template(project_path, template)

        print(f"âœ… ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆå®Œäº†: {project_path}")
        return project_path

    def _sanitize_project_name(self, name: str) -> str:
        """ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåã‚’å®‰å…¨ãªå½¢å¼ã«å¤‰æ›"""
        import re

        # è‹±æ•°å­—ã€ãƒã‚¤ãƒ•ãƒ³ã€ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã®ã¿è¨±å¯
        safe_name = re.sub(r"[^a-zA-Z0-9_-]", "_", name.lower())
        safe_name = re.sub(r"_+", "_", safe_name)  # é€£ç¶šã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢é™¤å»
        safe_name = safe_name.strip("_")  # å‰å¾Œã®ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢é™¤å»
        return safe_name or "unnamed_project"

    def _create_project_structure(self, project_path: Path, project_type: str):
        """ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåŸºæœ¬æ§‹é€ ã‚’ä½œæˆ"""

        # å…±é€šãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        common_dirs = [
            "src",  # ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰
            "tests",  # ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰
            "docs",  # ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
            "config",  # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
            "scripts",  # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
            "data",  # ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«
            "logs",  # ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«
            ".ai_company",  # AI Companyç®¡ç†ç”¨
        ]

        # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—åˆ¥ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        type_specific_dirs = {
            "web": ["frontend", "backend", "api", "static", "templates"],
            "api": ["api", "models", "services", "middleware"],
            "cli": ["cli", "commands", "utils"],
            "ml": ["models", "data", "notebooks", "experiments"],
            "general": ["lib", "bin", "examples"],
        }

        # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
        all_dirs = common_dirs + type_specific_dirs.get(project_type, [])
        for dir_name in all_dirs:
            (project_path / dir_name).mkdir(exist_ok=True)

            # .gitkeep ä½œæˆï¼ˆç©ºãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’Gitã§è¿½è·¡ï¼‰
            gitkeep = project_path / dir_name / ".gitkeep"
            if not any((project_path / dir_name).iterdir()):
                gitkeep.touch()

    def _create_project_config(
        self, project_path: Path, project_name: str, project_type: str
    ):
        """ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ"""

        config = {
            "project": {
                "name": project_name,
                "type": project_type,
                "created_at": datetime.now().isoformat(),
                "ai_company_version": "1.0.0",
            },
            "development": {
                "framework": self._suggest_framework(project_type),
                "language": self._suggest_language(project_type),
                "testing_framework": "pytest",
                "development_approach": "TDD",
            },
            "ai_company": {
                "auto_git": True,
                "auto_tests": True,
                "code_review": True,
                "documentation": True,
            },
            "structure": {
                "src_dir": "src",
                "test_dir": "tests",
                "docs_dir": "docs",
                "config_dir": "config",
            },
        }

        # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
        config_file = project_path / ".ai_company" / "project.json"
        config_file.parent.mkdir(exist_ok=True)
        with open(config_file, "w", encoding="utf-8") as f:
            json.dump(config, f, indent=2, ensure_ascii=False)

        # README.md ä½œæˆ
        self._create_readme(project_path, project_name, project_type, config)

        # .gitignore ä½œæˆ
        self._create_gitignore(project_path, project_type)

    def _suggest_framework(self, project_type: str) -> str:
        """ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã«åŸºã¥ããƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ææ¡ˆ"""
        suggestions = {
            "web": "fastapi",
            "api": "fastapi",
            "cli": "click",
            "ml": "pytorch",
            "general": "python",
        }
        return suggestions.get(project_type, "python")

    def _suggest_language(self, project_type: str) -> str:
        """ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã«åŸºã¥ãè¨€èªææ¡ˆ"""
        return "python"  # AI Companyã¯ä¸»ã«Python

    def _create_readme(
        self, project_path: Path, project_name: str, project_type: str, config: dict
    ):
        """README.md ã‚’ä½œæˆ"""

        readme_content = f"""# {project_name}

{project_name} - AI Company generated project

## ğŸ“‹ Project Overview

**Type**: {project_type.title()}
**Framework**: {config['development']['framework']}
**Language**: {config['development']['language']}
**Created**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## ğŸš€ Quick Start

```bash
# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ç§»å‹•
cd {project_path.name}

# ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ« (ä¾‹)
pip install -r requirements.txt

# ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
pytest tests/

# å®Ÿè¡Œ (ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦)
python src/main.py
```

## ğŸ“ Project Structure

```
{project_path.name}/
â”œâ”€â”€ src/                    # ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰
â”œâ”€â”€ tests/                  # ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ (TDD)
â”œâ”€â”€ docs/                   # ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
â”œâ”€â”€ config/                 # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
â”œâ”€â”€ scripts/                # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
â”œâ”€â”€ data/                   # ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«
â””â”€â”€ .ai_company/           # AI Companyç®¡ç†ç”¨
```

## ğŸ› ï¸ Development

This project follows **Test-Driven Development (TDD)**:

1. ğŸ”´ **Red**: Write failing tests first
2. ğŸŸ¢ **Green**: Implement minimal code to pass
3. ğŸ”µ **Refactor**: Improve code quality

## ğŸ“Š AI Company Integration

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯AI Companyã§ç®¡ç†ã•ã‚Œã¦ã„ã¾ã™:

```bash
# AI Companyã§ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ
ai-test "æ–°æ©Ÿèƒ½ã‚’è¿½åŠ ã—ã¦ãã ã•ã„"

# ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
ai-codegen generate rest_api --params '{{"resource_name": "item"}}'

# è¦ä»¶ã‹ã‚‰é–‹ç™º
ai-requirements-to-code requirements.json --output .
```

## ğŸ¤ Contributing

1. Fork the repository
2. Create your feature branch
3. Write tests first (TDD)
4. Implement the feature
5. Ensure all tests pass
6. Submit a pull request

---
Generated by AI Company - Autonomous Development System
"""

        readme_file = project_path / "README.md"
        with open(readme_file, "w", encoding="utf-8") as f:
            f.write(readme_content)

    def _create_gitignore(self, project_path: Path, project_type: str):
        """ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸ.gitignoreä½œæˆ"""

        common_ignores = [
            "# Python",
            "__pycache__/",
            "*.py[cod]",
            "*$py.class",
            "*.so",
            ".Python",
            "build/",
            "develop-eggs/",
            "dist/",
            "downloads/",
            "eggs/",
            ".eggs/",
            "lib/",
            "lib64/",
            "parts/",
            "sdist/",
            "var/",
            "wheels/",
            "*.egg-info/",
            ".installed.cfg",
            "*.egg",
            "",
            "# Virtual environments",
            "venv/",
            "env/",
            "ENV/",
            "",
            "# IDE",
            ".vscode/",
            ".idea/",
            "*.swp",
            "*.swo",
            "",
            "# Logs",
            "logs/",
            "*.log",
            "",
            "# Data",
            "data/*.csv",
            "data/*.json",
            "!data/.gitkeep",
            "",
            "# AI Company",
            ".ai_company/cache/",
            ".ai_company/temp/",
        ]

        type_specific_ignores = {
            "web": ["# Web specific", "node_modules/", "static/build/", "media/"],
            "ml": [
                "# ML specific",
                "models/*.pkl",
                "models/*.h5",
                "experiments/",
                "*.ipynb_checkpoints",
            ],
        }

        all_ignores = common_ignores + type_specific_ignores.get(project_type, [])

        gitignore_file = project_path / ".gitignore"
        with open(gitignore_file, "w", encoding="utf-8") as f:
            f.write("\\n".join(all_ignores))

    def _apply_template(self, project_path: Path, template: str):
        """ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆé©ç”¨"""
        template_path = self.ai_company_root / "templates" / "projects" / template
        if template_path.exists():
            # ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚³ãƒ”ãƒ¼
            for item in template_path.rglob("*"):
                if item.is_file():
                    relative_path = item.relative_to(template_path)
                    target_path = project_path / relative_path
                    target_path.parent.mkdir(parents=True, exist_ok=True)
                    shutil.copy2(item, target_path)

    def list_projects(self) -> list:
        """ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§ã‚’å–å¾—"""
        projects = []
        for project_dir in self.projects_root.iterdir():
            if project_dir.is_dir():
                config_file = project_dir / ".ai_company" / "project.json"
                if config_file.exists():
                    with open(config_file, "r", encoding="utf-8") as f:
                        config = json.load(f)
                    projects.append(
                        {
                            "name": config["project"]["name"],
                            "path": str(project_dir),
                            "type": config["project"]["type"],
                            "created": config["project"]["created_at"],
                        }
                    )
        return projects

    def get_project_path(self, project_name: str) -> Path:
        """ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåã‹ã‚‰ãƒ‘ã‚¹ã‚’å–å¾—"""
        safe_name = self._sanitize_project_name(project_name)

        # å®Œå…¨ä¸€è‡´
        exact_path = self.projects_root / safe_name
        if exact_path.exists():
            return exact_path

        # éƒ¨åˆ†ä¸€è‡´æ¤œç´¢
        for project_dir in self.projects_root.iterdir():
            if project_dir.is_dir() and safe_name in project_dir.name:
                return project_dir

        raise FileNotFoundError(f"Project not found: {project_name}")

    def create_from_requirements(
        self, requirements_file: str, project_name: str = None
    ) -> Path:
        """è¦ä»¶ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ"""

        with open(requirements_file, "r", encoding="utf-8") as f:
            requirements = json.load(f)

        # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåæ±ºå®š
        if not project_name:
            project_name = requirements.get("project_overview", "AI Generated Project")

        # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—æ¨å®š
        framework = requirements.get("technical_specs", {}).get("framework", "general")
        project_type = self._infer_project_type(framework)

        # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
        project_path = self.create_project(project_name, project_type)

        # è¦ä»¶ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã‚³ãƒ”ãƒ¼
        shutil.copy2(
            requirements_file, project_path / ".ai_company" / "requirements.json"
        )

        return project_path

    def _infer_project_type(self, framework: str) -> str:
        """ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‹ã‚‰ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã‚’æ¨å®š"""
        type_mapping = {
            "fastapi": "api",
            "flask": "web",
            "django": "web",
            "click": "cli",
            "pytorch": "ml",
            "tensorflow": "ml",
        }
        return type_mapping.get(framework, "general")


def main():
    parser = argparse.ArgumentParser(
        description="AI Company Project Manager",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ä½¿ç”¨ä¾‹:
  # æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
  ai-project-manager create "My Ecommerce Site" --type web --output-dir custom_path

  # è¦ä»¶ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
  ai-project-manager from-requirements requirements.json --name "Generated Project"

  # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§è¡¨ç¤º
  ai-project-manager list

  # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ã‚¹å–å¾—
  ai-project-manager path "My Project"

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—:
  - web: Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³
  - api: REST API / GraphQL API
  - cli: ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ãƒ„ãƒ¼ãƒ«
  - ml: æ©Ÿæ¢°å­¦ç¿’ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ
  - general: æ±ç”¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ
        """,
    )

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # create ã‚³ãƒãƒ³ãƒ‰
    create_parser = subparsers.add_parser("create", help="æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ")
    create_parser.add_argument("name", help="ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå")
    create_parser.add_argument(
        "--type",
        default="general",
        choices=["web", "api", "cli", "ml", "general"],
        help="ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—",
    )
    create_parser.add_argument("--template", help="ä½¿ç”¨ã™ã‚‹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ")

    # from-requirements ã‚³ãƒãƒ³ãƒ‰
    req_parser = subparsers.add_parser("from-requirements", help="è¦ä»¶ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ")
    req_parser.add_argument("requirements_file", help="è¦ä»¶JSONãƒ•ã‚¡ã‚¤ãƒ«")
    req_parser.add_argument("--name", help="ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåï¼ˆæŒ‡å®šã—ãªã„å ´åˆã¯è¦ä»¶ã‹ã‚‰æ¨å®šï¼‰")

    # list ã‚³ãƒãƒ³ãƒ‰
    list_parser = subparsers.add_parser("list", help="ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§è¡¨ç¤º")

    # path ã‚³ãƒãƒ³ãƒ‰
    path_parser = subparsers.add_parser("path", help="ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ã‚¹å–å¾—")
    path_parser.add_argument("name", help="ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå")

    args = parser.parse_args()

    manager = ProjectManager()

    if args.command == "create":
        project_path = manager.create_project(args.name, args.type, args.template)
        print(f"ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ã‚¹: {project_path}")

    elif args.command == "from-requirements":
        project_path = manager.create_from_requirements(
            args.requirements_file, args.name
        )
        print(f"ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ã‚¹: {project_path}")

    elif args.command == "list":
        projects = manager.list_projects()
        if projects:
            print("ğŸ“‹ AI Company Projects:")
            print("=" * 60)
            for project in projects:
                print(f"ğŸ“ {project['name']}")
                print(f"   Type: {project['type']}")
                print(f"   Path: {project['path']}")
                print(f"   Created: {project['created'][:10]}")
                print()
        else:
            print("ğŸ“­ No projects found")

    elif args.command == "path":
        try:
            project_path = manager.get_project_path(args.name)
            print(str(project_path))
        except FileNotFoundError as e:
            print(f"âŒ {e}")
            sys.exit(1)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
