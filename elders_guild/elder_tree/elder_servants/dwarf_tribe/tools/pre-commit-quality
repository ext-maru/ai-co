#!/usr/bin/env python3
"""
üèõÔ∏è Elder Guild Git Pre-commit Quality Hook
„Ç®„É´„ÉÄ„Éº„Ç∫„ÇÆ„É´„ÉâÂìÅË≥™‰øùË®º Git „Éï„ÉÉ„ÇØ

Features:
- „Ç≥„Éü„ÉÉ„ÉàÂâç„ÅÆËá™ÂãïÂìÅË≥™„ÉÅ„Çß„ÉÉ„ÇØ
- Iron WillÈÅµÂÆàÂº∑Âà∂
- ÂìÅË≥™„Çπ„Ç≥„Ç¢Âü∫Ê∫ñÊú™Ê∫Ä„Åß„Ç≥„Éü„ÉÉ„ÉàÈòªÊ≠¢
- ÊîπÂñÑÊèêÊ°à„Å®„Ç¨„Ç§„ÉÄ„É≥„Çπ
"""

import sys
import os
import subprocess
import json
import asyncio
from pathlib import Path
from typing import List, Dict, Any

# Add project root to path
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from libs.elders_code_quality_engine import quick_analyze

class Colors:
    """ANSI color codes"""
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    END = '\033[0m'

class ElderGuildPreCommitHook:
    """„Ç®„É´„ÉÄ„Éº„Ç∫„ÇÆ„É´„ÉâÂìÅË≥™‰øùË®º Pre-commit „Éï„ÉÉ„ÇØ"""
    
    def __init__(self):
        self.db_params = {
            'host': 'localhost',
            'database': 'elders_guild_pgvector',
            'user': 'postgres',
            'password': ''
        }
        self.minimum_quality_score = 70.0
        self.iron_will_required = True
        self.max_files_to_check = 50
        
    def get_staged_python_files(self) -> List[str]:
        """„Çπ„ÉÜ„Éº„Ç∏„Åï„Çå„ÅüPython„Éï„Ç°„Ç§„É´ÂèñÂæó"""
        try:
            # Get staged files
            result = subprocess.run(
                ['git', 'diff', '--cached', '--name-only', '--diff-filter=ACM'],
                capture_output=True,
                text=True,
                check=True
            )
            
            files = result.stdout.strip().split('\n') if result.stdout.strip() else []
            
            # Filter Python files and check if they exist
            python_files = []
            for file in files:
                if file.endswith('.py') and os.path.exists(file):
                    python_files.append(file)
                    
            return python_files[:self.max_files_to_check]
            
        except subprocess.CalledProcessError as e:
            print(f"{Colors.RED}‚ùå Failed to get staged files: {e}{Colors.END}")
            return []
            
    def print_header(self):
        """„Éò„ÉÉ„ÉÄ„ÉºË°®Á§∫"""
        print(f"{Colors.PURPLE}{Colors.BOLD}")
        print("üèõÔ∏è  ELDERS GUILD QUALITY ASSURANCE")
        print("    „Ç®„É´„ÉÄ„Éº„Ç∫„ÇÆ„É´„ÉâÂìÅË≥™‰øùË®º„Ç∑„Çπ„ÉÜ„É†")
        print("    Pre-commit Quality Check")
        print(f"{Colors.END}")
        
    async def analyze_file_quality(self, file_path: str) -> Dict[str, Any]:
        """„Éï„Ç°„Ç§„É´ÂìÅË≥™ÂàÜÊûê"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                code = f.read()
                
            result = await quick_analyze(code, self.db_params)
            
            analysis = result.get('analysis', {})
            return {
                'file': file_path,
                'quality_score': analysis.get('quality_score', 0),
                'iron_will_compliance': analysis.get('iron_will_compliance', False),
                'tdd_compatibility': analysis.get('tdd_compatibility', False),
                'issues': analysis.get('issues', []),
                'suggestions': analysis.get('suggestions', []),
                'bug_risks': analysis.get('bug_risks', []),
                'complexity_score': analysis.get('complexity_score', 0)
            }
            
        except Exception as e:
            return {
                'file': file_path,
                'error': str(e),
                'quality_score': 0,
                'iron_will_compliance': False
            }
            
    async def check_quality_gate(self, files: List[str]) -> Dict[str, Any]:
        """ÂìÅË≥™„Ç≤„Éº„Éà„ÉÅ„Çß„ÉÉ„ÇØ"""
        if not files:
            return {
                'status': 'skipped',
                'reason': 'No Python files to check',
                'gate_decision': 'approved'
            }
            
        print(f"{Colors.CYAN}üîç Analyzing {len(files)} Python file(s)...{Colors.END}")
        
        results = []
        quality_violations = []
        iron_will_violations = []
        high_risk_bugs = []
        
        for file_path in files:
            print(f"  üìÑ {file_path}", end=" ... ")
            
            analysis = await self.analyze_file_quality(file_path)
            results.append(analysis)
            
            if 'error' in analysis:
                print(f"{Colors.RED}‚ùå Error{Colors.END}")
                continue
                
            quality_score = analysis['quality_score']
            iron_will = analysis['iron_will_compliance']
            
            # ÂìÅË≥™„Çπ„Ç≥„Ç¢Ë°®Á§∫
            if quality_score >= 85:
                color = Colors.GREEN
                status = "‚úÖ"
            elif quality_score >= self.minimum_quality_score:
                color = Colors.YELLOW
                status = "‚ö†Ô∏è"
            else:
                color = Colors.RED
                status = "‚ùå"
                
            print(f"{color}{status} {quality_score:.1f}/100{Colors.END}")
            
            # ÈÅïÂèç„ÉÅ„Çß„ÉÉ„ÇØ
            if quality_score < self.minimum_quality_score:
                quality_violations.append(analysis)
                
            if self.iron_will_required and not iron_will:
                iron_will_violations.append(analysis)
                
            high_risk = [risk for risk in analysis.get('bug_risks', []) if risk.get('risk_level', 0) > 7]
            if high_risk:
                high_risk_bugs.append(analysis)
                
        # ÁµêÊûúÂà§ÂÆö
        has_violations = bool(quality_violations or iron_will_violations or high_risk_bugs)
        
        # Áµ±Ë®àË®àÁÆó
        valid_results = [r for r in results if 'error' not in r]
        avg_quality = sum(r['quality_score'] for r in valid_results) / len(valid_results) if valid_results else 0
        
        return {
            'status': 'completed',
            'gate_decision': 'blocked' if has_violations else 'approved',
            'total_files': len(files),
            'analyzed_files': len(valid_results),
            'average_quality_score': avg_quality,
            'quality_violations': quality_violations,
            'iron_will_violations': iron_will_violations,
            'high_risk_bugs': high_risk_bugs,
            'all_results': results
        }
        
    def print_quality_summary(self, gate_result: Dict[str, Any]):
        """ÂìÅË≥™„Çµ„Éû„É™„ÉºË°®Á§∫"""
        print(f"\n{Colors.BOLD}üìä QUALITY GATE SUMMARY{Colors.END}")
        print("=" * 40)
        
        files = gate_result['analyzed_files']
        avg_score = gate_result['average_quality_score']
        
        print(f"üìÅ Files analyzed: {files}")
        
        # Âπ≥ÂùáÂìÅË≥™„Çπ„Ç≥„Ç¢
        if avg_score >= 85:
            score_color = Colors.GREEN
            score_icon = "üèÜ"
        elif avg_score >= self.minimum_quality_score:
            score_color = Colors.YELLOW
            score_icon = "‚ö†Ô∏è"
        else:
            score_color = Colors.RED
            score_icon = "üö®"
            
        print(f"üéØ Average quality: {score_color}{score_icon} {avg_score:.1f}/100{Colors.END}")
        
        # „Ç≤„Éº„ÉàÁµêÊûú
        if gate_result['gate_decision'] == 'approved':
            print(f"{Colors.GREEN}{Colors.BOLD}‚úÖ QUALITY GATE: APPROVED{Colors.END}")
            print(f"{Colors.GREEN}üéâ All files meet Elder Guild quality standards!{Colors.END}")
        else:
            print(f"{Colors.RED}{Colors.BOLD}üö® QUALITY GATE: BLOCKED{Colors.END}")
            print(f"{Colors.RED}‚õî Commit blocked due to quality violations{Colors.END}")
            
    def print_violations(self, gate_result: Dict[str, Any]):
        """ÈÅïÂèçË©≥Á¥∞Ë°®Á§∫"""
        # Iron WillÈÅïÂèç
        iron_will_violations = gate_result.get('iron_will_violations', [])
        if iron_will_violations:
            print(f"\n{Colors.RED}{Colors.BOLD}‚öîÔ∏è  IRON WILL VIOLATIONS (Critical):{Colors.END}")
            for violation in iron_will_violations:
                print(f"  üìÑ {violation['file']}")
                print(f"     üö® Workaround/TODO comments detected")
                print(f"     üí° Remove all temporary fixes and complete implementation")
                
        # ÂìÅË≥™ÈÅïÂèç
        quality_violations = gate_result.get('quality_violations', [])
        if quality_violations:
            print(f"\n{Colors.YELLOW}{Colors.BOLD}üìä QUALITY VIOLATIONS:{Colors.END}")
            for violation in quality_violations:
                score = violation['quality_score']
                print(f"  üìÑ {violation['file']} (Score: {score:.1f}/100)")
                
                # ‰∏ªË¶ÅÂïèÈ°åË°®Á§∫
                issues = violation.get('issues', [])
                high_severity_issues = [i for i in issues if i.get('severity', 0) > 6]
                for issue in high_severity_issues[:3]:
                    print(f"     üî• {issue.get('name', 'Issue')}: {issue.get('description', 'No description')}")
                    
                # ÊîπÂñÑÊèêÊ°à
                suggestions = violation.get('suggestions', [])
                high_priority_suggestions = [s for s in suggestions if s.get('priority') == 'high']
                for suggestion in high_priority_suggestions[:2]:
                    print(f"     üí° {suggestion.get('title', 'Suggestion')}")
                    
        # È´ò„É™„Çπ„ÇØ„Éê„Ç∞
        high_risk_bugs = gate_result.get('high_risk_bugs', [])
        if high_risk_bugs:
            print(f"\n{Colors.RED}{Colors.BOLD}üêõ HIGH-RISK BUGS:{Colors.END}")
            for bug_file in high_risk_bugs:
                print(f"  üìÑ {bug_file['file']}")
                for risk in bug_file.get('bug_risks', []):
                    if risk.get('risk_level', 0) > 7:
                        print(f"     ‚ö†Ô∏è  {risk.get('name', 'Bug Risk')}: {risk.get('description', 'No description')}")
                        
    def print_improvement_guide(self):
        """ÊîπÂñÑ„Ç¨„Ç§„ÉâË°®Á§∫"""
        print(f"\n{Colors.BLUE}{Colors.BOLD}üõ†Ô∏è  IMPROVEMENT GUIDE:{Colors.END}")
        print(f"{Colors.CYAN}üìö Quick fixes:{Colors.END}")
        print("  1. Remove all TODO/FIXME comments (Iron Will)")
        print("  2. Add type hints: def func(x: int) -> str:")
        print("  3. Add docstrings: \"\"\"Function description\"\"\"")
        print("  4. Add error handling: try/except blocks")
        print("  5. Reduce complexity: break large functions")
        print()
        print(f"{Colors.CYAN}üîß Quality tools:{Colors.END}")
        print("  elders-code-quality analyze <file>    # Detailed analysis")
        print("  elders-code-quality report .          # Project overview")
        print()
        print(f"{Colors.CYAN}üìñ Resources:{Colors.END}")
        print("  CLAUDE.md - Elder Guild development standards")
        print("  knowledge_base/ - Best practices and guides")
        
    async def run_quality_check(self) -> int:
        """ÂìÅË≥™„ÉÅ„Çß„ÉÉ„ÇØÂÆüË°å"""
        self.print_header()
        
        # „Çπ„ÉÜ„Éº„Ç∏„Åï„Çå„Åü„Éï„Ç°„Ç§„É´ÂèñÂæó
        staged_files = self.get_staged_python_files()
        
        if not staged_files:
            print(f"{Colors.GREEN}‚úÖ No Python files to check{Colors.END}")
            return 0
            
        print(f"üìã Found {len(staged_files)} staged Python file(s)")
        
        # ÂìÅË≥™„Ç≤„Éº„Éà„ÉÅ„Çß„ÉÉ„ÇØÂÆüË°å
        gate_result = await self.check_quality_gate(staged_files)
        
        # ÁµêÊûúË°®Á§∫
        self.print_quality_summary(gate_result)
        
        if gate_result['gate_decision'] == 'blocked':
            self.print_violations(gate_result)
            self.print_improvement_guide()
            
            print(f"\n{Colors.RED}{Colors.BOLD}üõë COMMIT BLOCKED{Colors.END}")
            print(f"{Colors.RED}Fix the above issues and try again{Colors.END}")
            print(f"{Colors.YELLOW}üí° Use: git commit --no-verify to bypass (not recommended){Colors.END}")
            return 1
        else:
            print(f"\n{Colors.GREEN}{Colors.BOLD}üöÄ COMMIT APPROVED{Colors.END}")
            print(f"{Colors.GREEN}Code quality meets Elder Guild standards{Colors.END}")
            return 0

async def main():
    """„É°„Ç§„É≥ÂÆüË°å"""
    hook = ElderGuildPreCommitHook()
    return await hook.run_quality_check()

if __name__ == "__main__":
    try:
        exit_code = asyncio.run(main())
        sys.exit(exit_code)
    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}üõë Quality check cancelled{Colors.END}")
        sys.exit(1)
    except Exception as e:
        print(f"\n{Colors.RED}‚ùå Quality check failed: {e}{Colors.END}")
        sys.exit(1)