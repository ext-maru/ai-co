"""
Slack PM Manager - Slack対話型プロジェクトマネージャー
指示者との会話, 作業進行、報告を管理
"""

import json
import time
import logging
import threading
import re
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, asdict
from enum import Enum
import uuid

from slack_sdk import WebClient
from slack_sdk.rtm_v2 import RTMClient

class ConversationState(Enum):
    IDLE = "idle"
    LISTENING = "listening"
    CLARIFYING = "clarifying"
    PLANNING = "planning"
    CONFIRMING = "confirming"
    EXECUTING = "executing"
    REPORTING = "reporting"
    AWAITING_APPROVAL = "awaiting_approval"

class MessageType(Enum):
    TASK_REQUEST = "task_request"
    CLARIFICATION = "clarification"
    APPROVAL = "approval"
    STATUS_CHECK = "status_check"
    MODIFICATION = "modification"
    CANCEL = "cancel"
    HELP = "help"
    CHAT = "chat"

@dataclass
class PMSession:
    session_id: str
    user_id: str
    channel_id: str
    state: ConversationState
    created_at: datetime
    last_activity: datetime
    current_task_id: Optional[str] = None
    context: Dict[str, Any] = None
    conversation_history: List[Dict] = None
    pending_approval: Optional[str] = None

    def __post_init__(self):
        if self.context is None:
            self.context = {}
        if self.conversation_history is None:
            self.conversation_history = []

class SlackPMManager:
    """
    Slack統合プロジェクトマネージャー
    """

    def __init__(self, config_path: str = None):
        self.logger = logging.getLogger(__name__)
        self.config = self._load_config(config_path)

        # Slack クライアント
        self.web_client = WebClient(token=self.config['slack']['bot_token'])
        self.rtm_client = None

        # セッション管理
        self.active_sessions: Dict[str, PMSession] = {}  # user_id -> session
        self.session_timeout = timedelta(hours=2)

        # PM機能
        self.pm_capabilities = {
            'task_breakdown': True,
            'progress_tracking': True,
            'automatic_reporting': True,
            'approval_workflow': True,
            'context_awareness': True
        }

        # メッセージ解析パターン
        self._setup_message_patterns()

        # コールバック
        self.on_task_created: Optional[Callable] = None
        self.on_approval_needed: Optional[Callable] = None
        self.on_task_completed: Optional[Callable] = None

        # バックグラウンドタスク
        self.running = False
        self.cleanup_thread = None

    def _load_config(self, config_path: str) -> Dict:
        """設定読み込み"""
        default_config = {
            'slack': {
                'bot_token': '',
                'app_token': '',
                'pm_channels': [],  # PMが動作するチャンネル
                'admin_users': [],  # 管理者ユーザー
                'response_delay': 1,  # 応答遅延（秒）
            },
            'pm_settings': {
                'auto_start_tasks': False,  # タスクの自動開始
                'require_approval': True,   # 承認が必要
                'max_concurrent_tasks': 3,  # 同時実行タスク数
                'session_timeout_hours': 2,
                'progress_report_interval': 1800,  # 30分
            }
        }\n        \n        if config_path:\n            try:\n                with open(config_path, 'r') as f:\n                    file_config = json.load(f)\n                    return {**default_config, **file_config.get('slack_pm', {})}\n            except Exception as e:\n                self.logger.warning(f\"設定ファイル読み込み失敗: {e}\")\n        \n        return default_config\n    \n    def _setup_message_patterns(self):\n        \"\"\"メッセージ解析パターンの設定\"\"\"\n        self.patterns = {\n            MessageType.TASK_REQUEST: [\n                r'(.+)を(作って|作成して|実装して|開発して)',\n                r'(.+)の(機能|システム|プログラム)を(.+)',\n                r'(タスク|作業|仕事)[:：](.+)',\n                r'お疲れ様.*(.+)をお願い',\n                r'(.+)について(対応|処理|実行)して',\n            ],\n            MessageType.STATUS_CHECK: [\n                r'(進捗|状況|状態)(は|を)(どう|確認|教えて)',\n                r'(タスク|作業)の(進み具合|状況)',\n                r'今(何|どこまで|どの辺)',\n                r'ステータス.*確認',\n            ],\n            MessageType.APPROVAL: [\n                r'(OK|了解|承認|良い|はい|yes)',\n                r'(進めて|実行して|開始して)',\n                r'(それで|その通り|その方向で)',\n            ],\n            MessageType.MODIFICATION: [\n                r'(変更|修正|調整)(.+)',\n                r'(.+)を(.+)に(変えて|修正して)',\n                r'(やり直し|再検討)',\n            ],\n            MessageType.CANCEL: [\n                r'(キャンセル|中止|停止|やめ)',\n                r'(不要|いらない)',\n            ],\n            MessageType.HELP: [\n                r'(ヘルプ|使い方|機能|できること)',\n                r'(help|what can you do)',\n            ]\n        }\n    \n    def start_rtm(self):\n        \"\"\"リアルタイムメッセージング開始\"\"\"\n        try:\n            self.rtm_client = RTMClient(\n                token=self.config['slack']['app_token']\n            )\n            \n            @self.rtm_client.on(\"message\")\n            def handle_message(client: RTMClient, event: dict):\n                self._handle_slack_message(event)\n            \n            self.running = True\n            \n            # バックグラウンドタスク開始\n            self.cleanup_thread = threading.Thread(target=self._cleanup_worker, daemon=True)\n            self.cleanup_thread.start()\n            \n            # RTM開始\n            self.rtm_client.start()\n            \n            self.logger.info(\"🚀 Slack PM Manager RTM開始\")\n            \n        except Exception as e:\n            self.logger.error(f\"RTM開始失敗: {e}\")\n    \n    def stop_rtm(self):\n        \"\"\"リアルタイムメッセージング停止\"\"\"\n        self.running = False\n        \n        if self.rtm_client:\n            self.rtm_client.close()\n        \n        if self.cleanup_thread:\n            self.cleanup_thread.join(timeout=5)\n        \n        self.logger.info(\"🛑 Slack PM Manager 停止\")\n    \n    def _handle_slack_message(self, event: dict):\n        \"\"\"Slackメッセージの処理\"\"\"\n        try:\n            # ボット自身のメッセージは無視\n            if event.get('bot_id'):\n                return\n            \n            user_id = event.get('user')\n            channel_id = event.get('channel')\n            text = event.get('text', '')\n            ts = event.get('ts')\n            \n            if not all([user_id, channel_id, text]):\n                return\n            \n            # PMチャンネルでない場合は無視\n            if self.config['slack']['pm_channels'] and channel_id not in self.config['slack']['pm_channels']:\n                return\n            \n            # メンション確認\n            if not self._is_mentioned(text):\n                return\n            \n            # テキストからメンション部分を除去\n            clean_text = self._clean_mention(text)\n            \n            self.logger.info(f\"📨 Slack PM メッセージ受信: {user_id} -> {clean_text[:50]}...\")\n            \n            # セッション取得または作成\n            session = self._get_or_create_session(user_id, channel_id)\n            \n            # メッセージタイプ判定\n            message_type = self._classify_message(clean_text, session)\n            \n            # セッション更新\n            session.last_activity = datetime.now()\n            session.conversation_history.append({\n                'timestamp': ts,\n                'user_message': clean_text,\n                'message_type': message_type.value\n            })\n            \n            # メッセージタイプに応じた処理\n            self._process_message_by_type(session, clean_text, message_type)\n            \n        except Exception as e:\n            self.logger.error(f\"Slackメッセージ処理エラー: {e}\")\n            self._send_error_message(event.get('channel'), \"申し訳ございません。エラーが発生しました。\")\n    \n    def _is_mentioned(self, text: str) -> bool:\n        \"\"\"メンション確認\"\"\"\n        # @bot_userやDMの場合はTrue\n        return '<@' in text or True  # 簡易実装\n    \n    def _clean_mention(self, text: str) -> str:\n        \"\"\"メンション部分を除去\"\"\"\n        return re.sub(r'<@[^>]+>', '', text).strip()\n    \n    def _get_or_create_session(self, user_id: str, channel_id: str) -> PMSession:\n        \"\"\"セッション取得または作成\"\"\"\n        if user_id in self.active_sessions:\n            session = self.active_sessions[user_id]\n            # タイムアウトチェック\n            if datetime.now() - session.last_activity > self.session_timeout:\n                self.logger.info(f\"セッションタイムアウト: {user_id}\")\n                del self.active_sessions[user_id]\n            else:\n                return session\n        \n        # 新しいセッション作成\n        session = PMSession(\n            session_id=str(uuid.uuid4()),\n            user_id=user_id,\n            channel_id=channel_id,\n            state=ConversationState.IDLE,\n            created_at=datetime.now(),\n            last_activity=datetime.now()\n        )\n        \n        self.active_sessions[user_id] = session\n        self.logger.info(f\"新しいPMセッション作成: {user_id}\")\n        \n        return session\n    \n    def _classify_message(self, text: str, session: PMSession) -> MessageType:\n        \"\"\"メッセージタイプの分類\"\"\"\n        text_lower = text.lower()\n        \n        # セッション状態に応じた判定\n        if session.state == ConversationState.AWAITING_APPROVAL:\n            for pattern in self.patterns[MessageType.APPROVAL]:\n                if re.search(pattern, text_lower, re.IGNORECASE):\n                    return MessageType.APPROVAL\n            return MessageType.MODIFICATION  # 承認待ち中の非承認メッセージは修正要求\n        \n        # パターンマッチング\n        for msg_type, patterns in self.patterns.items():\n            for pattern in patterns:\n                if re.search(pattern, text_lower, re.IGNORECASE):\n                    return msg_type\n        \n        # デフォルトはタスク要求\n        if session.state == ConversationState.IDLE:\n            return MessageType.TASK_REQUEST\n        else:\n            return MessageType.CHAT\n    \n    def _process_message_by_type(self, session: PMSession, text: str, message_type: MessageType):\n        \"\"\"メッセージタイプ別処理\"\"\"\n        \n        if message_type == MessageType.TASK_REQUEST:\n            self._handle_task_request(session, text)\n        elif message_type == MessageType.STATUS_CHECK:\n            self._handle_status_check(session)\n        elif message_type == MessageType.APPROVAL:\n            self._handle_approval(session, text)\n        elif message_type == MessageType.MODIFICATION:\n            self._handle_modification(session, text)\n        elif message_type == MessageType.CANCEL:\n            self._handle_cancel(session)\n        elif message_type == MessageType.HELP:\n            self._handle_help(session)\n        else:\n            self._handle_chat(session, text)\n    \n    def _handle_task_request(self, session: PMSession, text: str):\n        \"\"\"タスク要求の処理\"\"\"\n        session.state = ConversationState.PLANNING\n        \n        # タスク分析\n        task_analysis = self._analyze_task(text)\n        \n        # プランニング応答\n        planning_response = self._generate_planning_response(task_analysis)\n        \n        # Slack応答\n        self._send_slack_message(\n            session.channel_id,\n            f\"📋 **タスク要求を受信しました**\\n\\n\"\n            f\"**分析結果:**\\n{task_analysis['summary']}\\n\\n\"\n            f\"**実行プラン:**\\n{planning_response}\\n\\n\"\n            f\"この内容で進めてよろしいですか？ (はい/修正要求)\"\n        )\n        \n        session.state = ConversationState.AWAITING_APPROVAL\n        session.context['pending_task'] = task_analysis\n        session.context['planning_response'] = planning_response\n    \n    def _analyze_task(self, text: str) -> Dict[str, Any]:\n        \"\"\"タスク分析\"\"\"\n        # 簡易実装 - 実際はClaude APIで分析\n        return {\n            'original_request': text,\n            'summary': f\"要求: {text[:100]}...\",\n            'estimated_complexity': 'medium',\n            'estimated_time': '30-60分',\n            'required_skills': ['Python', 'システム設計'],\n            'deliverables': ['実装ファイル', 'テストコード', 'ドキュメント']\n        }\n    \n    def _generate_planning_response(self, task_analysis: Dict) -> str:\n        \"\"\"プランニング応答生成\"\"\"\n        return f\"\"\"1. **要件整理**: {task_analysis['summary']}\n2. **技術検討**: {', '.join(task_analysis['required_skills'])}\n3. **実装**: コード作成とテスト\n4. **検証**: 動作確認\n5. **納品**: {', '.join(task_analysis['deliverables'])}\n\n**見積時間**: {task_analysis['estimated_time']}\n**複雑度**: {task_analysis['estimated_complexity']}\"\"\"\n    \n    def _handle_status_check(self, session: PMSession):\n        \"\"\"ステータス確認処理\"\"\"\n        if session.current_task_id:\n            # タスクの進捗を確認\n            progress = self._get_task_progress(session.current_task_id)\n            \n            self._send_slack_message(\n                session.channel_id,\n                f\"📊 **現在のタスク進捗**\\n\\n\"\n                f\"**タスクID**: {session.current_task_id}\\n\"\n                f\"**ステータス**: {progress['status']}\\n\"\n                f\"**進捗率**: {progress['progress']}%\\n\"\n                f\"**経過時間**: {progress['elapsed_time']}\\n\"\n                f\"**予想残り時間**: {progress['estimated_remaining']}\\n\\n\"\n                f\"**詳細**: {progress['details']}\"\n            )\n        else:\n            self._send_slack_message(\n                session.channel_id,\n                \"現在実行中のタスクはありません。\\n新しいタスクをお申し付けください！\"\n            )\n    \n    def _handle_approval(self, session: PMSession, text: str):\n        \"\"\"承認処理\"\"\"\n        if session.state != ConversationState.AWAITING_APPROVAL:\n            return\n        \n        pending_task = session.context.get('pending_task')\n        if not pending_task:\n            return\n        \n        # タスク実行開始\n        task_id = self._create_and_execute_task(pending_task, session)\n        \n        session.current_task_id = task_id\n        session.state = ConversationState.EXECUTING\n        \n        self._send_slack_message(\n            session.channel_id,\n            f\"✅ **承認いただきました！**\\n\\n\"\n            f\"**タスクID**: {task_id}\\n\"\n            f\"タスクを開始します。進捗は定期的にお知らせします。\\n\\n\"\n            f\"進捗確認は「進捗は？」とお声がけください。\"\n        )\n        \n        # コールバック実行\n        if self.on_task_created:\n            try:\n                self.on_task_created(task_id, pending_task, session)\n            except Exception as e:\n                self.logger.error(f\"Task creation callback error: {e}\")\n    \n    def _handle_modification(self, session: PMSession, text: str):\n        \"\"\"修正要求処理\"\"\"\n        self._send_slack_message(\n            session.channel_id,\n            f\"📝 **修正要求を承りました**\\n\\n\"\n            f\"修正内容: {text}\\n\\n\"\n            f\"プランを調整いたします。少々お待ちください...\"\n        )\n        \n        # 状態をプランニングに戻す\n        session.state = ConversationState.PLANNING\n        \n        # 修正されたプランを生成（簡易実装）\n        time.sleep(2)  # 実際は Claude API で再プランニング\n        \n        self._send_slack_message(\n            session.channel_id,\n            f\"📋 **修正プラン**\\n\\n\"\n            f\"ご指摘を反映したプランを作成しました。\\n\"\n            f\"修正内容: {text}を考慮して調整\\n\\n\"\n            f\"この内容で進めてよろしいですか？\"\n        )\n        \n        session.state = ConversationState.AWAITING_APPROVAL\n    \n    def _handle_cancel(self, session: PMSession):\n        \"\"\"キャンセル処理\"\"\"\n        if session.current_task_id:\n            # 実行中タスクをキャンセル\n            self._cancel_task(session.current_task_id)\n            \n            self._send_slack_message(\n                session.channel_id,\n                f\"⚠️ **タスクをキャンセルしました**\\n\\n\"\n                f\"タスクID: {session.current_task_id}\\n\"\n                f\"実行を停止いたします。\"\n            )\n        else:\n            self._send_slack_message(\n                session.channel_id,\n                \"現在実行中のタスクはありません。\\n\"\n                \"何か他にお手伝いできることはありますか？\"\n            )\n        \n        # セッションリセット\n        session.state = ConversationState.IDLE\n        session.current_task_id = None\n        session.context.clear()\n    \n    def _handle_help(self, session: PMSession):\n        \"\"\"ヘルプ処理\"\"\"\n        help_message = \"\"\"🤖 **AI Company PM の使い方**\n\n**基本機能:**\n• タスク要求: \"○○を作って\" \"○○を実装して\"\n• 進捗確認: \"進捗は？\" \"状況を教えて\"\n• 修正要求: \"○○を変更して\" \"やり直し\"\n• キャンセル: \"キャンセル\" \"中止\"\n\n**ワークフロー:**\n1. タスク要求 → 分析・プランニング\n2. 承認確認 → 実行開始\n3. 定期進捗報告\n4. 完了報告\n\n**コマンド例:**\n• \"ユーザー管理システムを作って\"\n• \"進捗はどう？\"\n• \"データベース部分を変更して\"\n• \"作業を中止して\"\n\n何かご質問はありますか？\"\"\"\n        \n        self._send_slack_message(session.channel_id, help_message)\n    \n    def _handle_chat(self, session: PMSession, text: str):\n        \"\"\"一般的な会話処理\"\"\"\n        # 簡易応答\n        responses = [\n            \"承知いたしました。他にご要望はありますか？\",\n            \"なるほど、理解いたします。\",\n            \"ありがとうございます。他にお手伝いできることはありますか？\"\n        ]\n        \n        import random\n        response = random.choice(responses)\n        \n        self._send_slack_message(session.channel_id, response)\n    \n    def _send_slack_message(self, channel_id: str, text: str):\n        \"\"\"Slackメッセージ送信\"\"\"\n        try:\n            # 応答遅延\n            time.sleep(self.config['slack']['response_delay'])\n            \n            response = self.web_client.chat_postMessage(\n                channel=channel_id,\n                text=text,\n                mrkdwn=True\n            )\n            \n            self.logger.debug(f\"Slack送信成功: {channel_id}\")\n            \n        except Exception as e:\n            self.logger.error(f\"Slack送信失敗: {e}\")\n    \n    def _send_error_message(self, channel_id: str, error_msg: str):\n        \"\"\"エラーメッセージ送信\"\"\"\n        try:\n            self.web_client.chat_postMessage(\n                channel=channel_id,\n                text=f\"❌ {error_msg}\",\n                mrkdwn=True\n            )\n        except Exception as e:\n            self.logger.error(f\"エラーメッセージ送信失敗: {e}\")\n    \n    def _create_and_execute_task(self, task_analysis: Dict, session: PMSession) -> str:\n        \"\"\"タスク作成・実行\"\"\"\n        task_id = f\"pm_{int(time.time())}\"\n        \n        # 実際のタスク実行ロジック（簡易実装）\n        # 実際は既存のタスクシステムと連携\n        \n        return task_id\n    \n    def _get_task_progress(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"タスク進捗取得\"\"\"\n        # 簡易実装\n        return {\n            'status': '実行中',\n            'progress': 65,\n            'elapsed_time': '25分',\n            'estimated_remaining': '15分',\n            'details': 'コア機能の実装完了、テスト作成中'\n        }\n    \n    def _cancel_task(self, task_id: str):\n        \"\"\"タスクキャンセル\"\"\"\n        # 実際のキャンセル処理\n        pass\n    \n    def _cleanup_worker(self):\n        \"\"\"セッションクリーンアップワーカー\"\"\"\n        while self.running:\n            try:\n                current_time = datetime.now()\n                expired_sessions = []\n                \n                for user_id, session in self.active_sessions.items():\n                    if current_time - session.last_activity > self.session_timeout:\n                        expired_sessions.append(user_id)\n                \n                for user_id in expired_sessions:\n                    self.logger.info(f\"セッション期限切れでクリーンアップ: {user_id}\")\n                    del self.active_sessions[user_id]\n                \n                time.sleep(300)  # 5分間隔でチェック\n                \n            except Exception as e:\n                self.logger.error(f\"セッションクリーンアップエラー: {e}\")\n                time.sleep(60)\n    \n    def send_progress_report(self, task_id: str, progress_data: Dict[str, Any]):\n        \"\"\"進捗報告送信\"\"\"\n        # タスクIDから対応するセッションを検索\n        target_session = None\n        for session in self.active_sessions.values():\n            if session.current_task_id == task_id:\n                target_session = session\n                break\n        \n        if not target_session:\n            return\n        \n        progress_message = f\"\"\"📊 **進捗報告**\n\n**タスクID**: {task_id}\n**進捗率**: {progress_data.get('progress', 0)}%\n**ステータス**: {progress_data.get('status', '実行中')}\n**完了項目**: {', '.join(progress_data.get('completed_items', []))}\n**次のステップ**: {progress_data.get('next_step', '継続中')}\n\n引き続き作業を進めます。\"\"\"\n        \n        self._send_slack_message(target_session.channel_id, progress_message)\n    \n    def send_completion_report(self, task_id: str, completion_data: Dict[str, Any]):\n        \"\"\"完了報告送信\"\"\"\n        target_session = None\n        for session in self.active_sessions.values():\n            if session.current_task_id == task_id:\n                target_session = session\n                break\n        \n        if not target_session:\n            return\n        \n        completion_message = f\"\"\"✅ **タスク完了報告**\n\n**タスクID**: {task_id}\n**実行時間**: {completion_data.get('execution_time', '不明')}\n**成果物**: {', '.join(completion_data.get('deliverables', []))}\n**実行結果**: {completion_data.get('result_summary', '正常完了')}\n\n**ファイル一覧**:\n{chr(10).join(f'• {file}' for file in completion_data.get('created_files', []))}\n\nタスクが完了いたしました！\n他にご要望はありますか？\"\"\"\n        \n        self._send_slack_message(target_session.channel_id, completion_message)\n        \n        # セッション状態リセット\n        target_session.state = ConversationState.IDLE\n        target_session.current_task_id = None\n    \n    def get_active_sessions(self) -> Dict[str, Dict]:\n        \"\"\"アクティブセッション一覧取得\"\"\"\n        return {\n            user_id: {\n                'session_id': session.session_id,\n                'state': session.state.value,\n                'current_task': session.current_task_id,\n                'last_activity': session.last_activity.isoformat(),\n                'messages_count': len(session.conversation_history)\n            }\n            for user_id, session in self.active_sessions.items()\n        }
