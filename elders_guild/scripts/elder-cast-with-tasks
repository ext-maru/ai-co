#!/usr/bin/env python3
"""
AI Elder Cast with Task Integration
ã‚¿ã‚¹ã‚¯ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã¨çµ±åˆã•ã‚ŒãŸã‚¯ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ«ãƒ€ãƒ¼èµ·å‹•ã‚·ã‚¹ãƒ†ãƒ 
"""

import argparse
import asyncio
import json
import os
import subprocess
import sys
import tempfile
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã‚’ãƒ‘ã‚¹ã«è¿½åŠ 
# ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã‚’è§£æ±ºã—ã¦ã‹ã‚‰å®Ÿéš›ã®ãƒ‘ã‚¹ã‚’å–å¾—
script_path = Path(__file__).resolve()
project_root = script_path.parent.parent.parent  # ai_coãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
sys.path.insert(0, str(project_root))

from libs.todo_tracker_integration import TodoTrackerIntegration
from libs.postgres_claude_task_tracker import TaskStatus, TaskPriority

# çŸ¥è­˜ã‚»ã‚¯ã‚·ãƒ§ãƒ³å®šç¾©ï¼ˆai-elder-cast-modularã‹ã‚‰ç¶™æ‰¿ï¼‰
KNOWLEDGE_SECTIONS = {
    "core": {
        "name": "ã‚³ã‚¢ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£",
        "files": ["ELDER_KNOWLEDGE_CONTEXT_OPTIMIZED.md"],
        "description": "æœ€å°é™ã®å¿…é ˆçŸ¥è­˜ï¼ˆ4KBï¼‰",
    },
    "medium": {
        "name": "ä¸­é–“ç‰ˆ",
        "files": ["ELDER_KNOWLEDGE_CONTEXT_MEDIUM.md"],
        "description": "ãƒãƒ©ãƒ³ã‚¹ç‰ˆï¼ˆ8KBï¼‰",
    },
    "identity": {
        "name": "ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£è©³ç´°",
        "files": [
            "knowledge_base/elder_knowledge_sections/02_claude_elder_identity.md",
            "knowledge_base/elder_knowledge_sections/03_grand_elder_hierarchy.md",
        ],
        "description": "ã‚¯ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ«ãƒ€ãƒ¼ã®è©³ç´°å®šç¾©",
    },
    "flow": {
        "name": "Elder Flow",
        "files": ["knowledge_base/elder_knowledge_sections/05_elder_flow_design.md"],
        "description": "Elder Flowè¨­è¨ˆä»•æ§˜",
    },
    "sages": {
        "name": "4è³¢è€…ã‚·ã‚¹ãƒ†ãƒ ",
        "files": ["knowledge_base/elder_knowledge_sections/09_four_sages_wisdom.md"],
        "description": "4è³¢è€…çµ±åˆçŸ¥æµã‚·ã‚¹ãƒ†ãƒ ",
    },
    "tdd": {
        "name": "TDDã‚¬ã‚¤ãƒ‰",
        "files": ["knowledge_base/elder_knowledge_sections/11_claude_tdd_guide.md"],
        "description": "ãƒ†ã‚¹ãƒˆé§†å‹•é–‹ç™ºã‚¬ã‚¤ãƒ‰",
    },
}


def print_colored(text, color="cyan"):
    """ã‚«ãƒ©ãƒ¼å‡ºåŠ›"""
    colors = {
        "cyan": "\033[0;36m",
        "green": "\033[0;32m",
        "yellow": "\033[1;33m",
        "purple": "\033[0;35m",
        "red": "\033[0;31m",
        "blue": "\033[0;34m",
        "bold": "\033[1m",
    }
    reset = "\033[0m"
    print(f"{colors.get(color, '')}{text}{reset}")


def format_task_priority(priority: TaskPriority) -> str:
    """ã‚¿ã‚¹ã‚¯å„ªå…ˆåº¦ã‚’çµµæ–‡å­—ã§è¡¨ç¾"""
    priority_map = {
        TaskPriority.CRITICAL: "ğŸ”´",
        TaskPriority.HIGH: "ğŸŸ ",
        TaskPriority.MEDIUM: "ğŸŸ¡",
        TaskPriority.LOW: "ğŸŸ¢",
    }
    return priority_map.get(priority, "âšª")


def format_task_status(status: TaskStatus) -> str:
    """ã‚¿ã‚¹ã‚¯ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’çµµæ–‡å­—ã§è¡¨ç¾"""
    status_map = {
        TaskStatus.PENDING: "ğŸ“‹",
        TaskStatus.IN_PROGRESS: "ğŸ”„",
        TaskStatus.COMPLETED: "âœ…",
        TaskStatus.CANCELLED: "âŒ",
        TaskStatus.BLOCKED: "ğŸš«",
    }
    return status_map.get(status, "â“")


async def get_task_summary(integration: TodoTrackerIntegration) -> Dict:
    """ã‚¿ã‚¹ã‚¯ã‚µãƒãƒªãƒ¼ã‚’å–å¾—"""
    try:
        # åŒæœŸã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
        sync_status = await integration.get_sync_status()
        my_stats = sync_status.get("my_tasks_stats", {})
        
        # æœ€è¿‘ã®ã‚¿ã‚¹ã‚¯ã‚’å–å¾—
        recent_tasks = await integration.tracker.list_tasks(
            assigned_to=integration.user_id,
            limit=10
        )
        
        # æœ¬æ—¥ã®ã‚¿ã‚¹ã‚¯ã‚’å–å¾—
        today = datetime.now().date()
        today_tasks = [
            task for task in recent_tasks
            if task.created_at.date() == today or
               (task.completed_at and task.completed_at.date() == today)
        ]
        
        # å„ªå…ˆåº¦åˆ¥ã«åˆ†é¡
        priority_tasks = {
            "critical": [],
            "high": [],
            "medium": [],
            "low": []
        }
        
        for task in recent_tasks:
            if task.status in [TaskStatus.PENDING, TaskStatus.IN_PROGRESS]:
                priority_key = task.priority.value.lower()
                if priority_key in priority_tasks:
                    priority_tasks[priority_key].append(task)
        
        return {
            "stats": my_stats,
            "recent_tasks": recent_tasks[:5],
            "today_tasks": today_tasks,
            "priority_tasks": priority_tasks,
            "total_active": my_stats.get("pending", 0) + my_stats.get("in_progress", 0)
        }
    except Exception as e:
        print_colored(f"âš ï¸ ã‚¿ã‚¹ã‚¯ã‚µãƒãƒªãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼: {e}", "yellow")
        return {
            "stats": {},
            "recent_tasks": [],
            "today_tasks": [],
            "priority_tasks": {"critical": [], "high": [], "medium": [], "low": []},
            "total_active": 0
        }


def format_task_knowledge(task_summary: Dict) -> str:
    """ã‚¿ã‚¹ã‚¯æƒ…å ±ã‚’çŸ¥è­˜å½¢å¼ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
    lines = [
        "\n# ğŸ“Š ç¾åœ¨ã®ã‚¿ã‚¹ã‚¯çŠ¶æ³\n",
        f"**ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹æ™‚åˆ»**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        f"**ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¿ã‚¹ã‚¯æ•°**: {task_summary['total_active']}ä»¶\n",
    ]
    
    # çµ±è¨ˆæƒ…å ±
    stats = task_summary.get("stats", {})
    if stats:
        lines.append("## ğŸ“ˆ ã‚¿ã‚¹ã‚¯çµ±è¨ˆ")
        lines.append(f"- **ç·ã‚¿ã‚¹ã‚¯æ•°**: {stats.get('total', 0)}ä»¶")
        lines.append(f"- **æœªç€æ‰‹**: {stats.get('pending', 0)}ä»¶")
        lines.append(f"- **é€²è¡Œä¸­**: {stats.get('in_progress', 0)}ä»¶")
        lines.append(f"- **å®Œäº†**: {stats.get('completed', 0)}ä»¶")
        lines.append(f"- **æœ¬æ—¥å®Œäº†**: {stats.get('completed_today', 0)}ä»¶\n")
    
    # å„ªå…ˆåº¦åˆ¥ã‚¿ã‚¹ã‚¯
    priority_tasks = task_summary.get("priority_tasks", {})
    has_priority_tasks = any(tasks for tasks in priority_tasks.values())
    
    if has_priority_tasks:
        lines.append("## ğŸ¯ å„ªå…ˆåº¦åˆ¥ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¿ã‚¹ã‚¯")
        
        for priority in ["critical", "high", "medium", "low"]:
            tasks = priority_tasks.get(priority, [])
            if tasks:
                priority_obj = TaskPriority[priority.upper()]
                emoji = format_task_priority(priority_obj)
                lines.append(f"\n### {emoji} {priority.upper()} ({len(tasks)}ä»¶)")
                
                for task in tasks[:3]:  # å„å„ªå…ˆåº¦ã§æœ€å¤§3ä»¶è¡¨ç¤º
                    status_emoji = format_task_status(task.status)
                    created = task.created_at.strftime('%m/%d')
                    lines.append(f"- {status_emoji} **{task.title}** (#{task.id[:8]}, {created})")
                    if task.description:
                        desc_preview = task.description[:50] + "..." if len(task.description) > 50 else task.description
                        lines.append(f"  - {desc_preview}")
    
    # æœ¬æ—¥ã®ã‚¿ã‚¹ã‚¯
    today_tasks = task_summary.get("today_tasks", [])
    if today_tasks:
        lines.append(f"\n## ğŸ“… æœ¬æ—¥ã®ã‚¿ã‚¹ã‚¯ ({len(today_tasks)}ä»¶)")
        for task in today_tasks[:5]:
            status_emoji = format_task_status(task.status)
            priority_emoji = format_task_priority(task.priority)
            lines.append(f"- {status_emoji} {priority_emoji} **{task.title}** (#{task.id[:8]})")
    
    # ç¶™æ‰¿ã™ã¹ãå‰å›ã®ã‚¿ã‚¹ã‚¯
    if task_summary.get("stats", {}).get("in_progress", 0) > 0:
        lines.append("\n## âš¡ ç¶™ç¶šä¸­ã®ã‚¿ã‚¹ã‚¯")
        in_progress = [t for t in task_summary.get("recent_tasks", []) if t.status == TaskStatus.IN_PROGRESS]
        for task in in_progress:
            lines.append(f"- ğŸ”„ **{task.title}** (#{task.id[:8]})")
            lines.append(f"  - é–‹å§‹: {task.created_at.strftime('%Y-%m-%d %H:%M')}")
    
    lines.append("\n---\n")
    
    return "\n".join(lines)


async def inherit_previous_session(integration: TodoTrackerIntegration) -> Optional[str]:
    """å‰å›ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®æœªå®Œäº†ã‚¿ã‚¹ã‚¯ã‚’ç¢ºèª"""
    try:
        # å‰å›ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‹ã‚‰æœªå®Œäº†ã‚¿ã‚¹ã‚¯ã‚’ç¢ºèª
        await integration.auto_inherit_if_pending()
        
        # ç¶™æ‰¿ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ãŒã‚ã‚‹ã‹ç¢ºèª
        active_tasks = await integration.tracker.list_tasks(
            assigned_to=integration.user_id,
            status_filter=[TaskStatus.IN_PROGRESS, TaskStatus.PENDING],
            limit=5
        )
        
        if active_tasks:
            message = f"\nğŸ”„ å‰å›ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‹ã‚‰{len(active_tasks)}ä»¶ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¿ã‚¹ã‚¯ã‚’ç¶™æ‰¿ã—ã¾ã—ãŸã€‚"
            return message
        
        return None
    except Exception as e:
        print_colored(f"âš ï¸ ã‚»ãƒƒã‚·ãƒ§ãƒ³ç¶™æ‰¿ã‚¨ãƒ©ãƒ¼: {e}", "yellow")
        return None


def load_sections(section_names: List[str]) -> str:
    """æŒ‡å®šã•ã‚ŒãŸã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’èª­ã¿è¾¼ã¿"""
    content = []
    total_size = 0
    
    for section_name in section_names:
        if section_name not in KNOWLEDGE_SECTIONS:
            continue
        
        section = KNOWLEDGE_SECTIONS[section_name]
        
        for file_path in section["files"]:
            full_path = project_root / file_path
            if full_path.exists():
                with open(full_path, "r", encoding="utf-8") as f:
                    file_content = f.read()
                    content.append(f"\n\n# === {section['name']} ===\n")
                    content.append(file_content)
                    total_size += len(file_content)
    
    return "\n".join(content)


async def sync_and_prepare_knowledge(sections: List[str], no_sync: bool = False) -> Tuple[str, Optional[TodoTrackerIntegration]]:
    """ã‚¿ã‚¹ã‚¯åŒæœŸã‚’å®Ÿè¡Œã—ã€çŸ¥è­˜ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æº–å‚™"""
    # åŸºæœ¬çŸ¥è­˜ã‚’èª­ã¿è¾¼ã¿
    knowledge_content = load_sections(sections)
    
    if no_sync:
        return knowledge_content, None
    
    # ã‚¿ã‚¹ã‚¯ãƒˆãƒ©ãƒƒã‚«ãƒ¼çµ±åˆã‚’åˆæœŸåŒ–
    print_colored("ğŸ“‹ ã‚¿ã‚¹ã‚¯ãƒˆãƒ©ãƒƒã‚«ãƒ¼æ¥ç¶šä¸­...", "cyan")
    
    try:
        # ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’ç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: claude_elderï¼‰
        user_id = os.environ.get("CLAUDE_ELDER_USER", "claude_elder")
        
        integration = TodoTrackerIntegration(
            auto_sync=False,  # èµ·å‹•æ™‚ã¯æ‰‹å‹•åŒæœŸã®ã¿
            user_id=user_id
        )
        await integration.initialize()
        
        # å‰å›ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ç¶™æ‰¿
        inherit_message = await inherit_previous_session(integration)
        if inherit_message:
            print_colored(inherit_message, "green")
        
        # åŒæ–¹å‘åŒæœŸã‚’å®Ÿè¡Œ
        print_colored("ğŸ”„ ã‚¿ã‚¹ã‚¯åŒæœŸå®Ÿè¡Œä¸­...", "cyan")
        await integration.sync_both_ways(personal_only=True)
        
        # ã‚¿ã‚¹ã‚¯ã‚µãƒãƒªãƒ¼ã‚’å–å¾—
        task_summary = await get_task_summary(integration)
        
        # ã‚¿ã‚¹ã‚¯æƒ…å ±ã‚’çŸ¥è­˜ã«è¿½åŠ 
        task_knowledge = format_task_knowledge(task_summary)
        knowledge_content = knowledge_content + "\n\n" + task_knowledge
        
        print_colored("âœ… ã‚¿ã‚¹ã‚¯åŒæœŸå®Œäº†", "green")
        print_colored(f"ğŸ“Š ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¿ã‚¹ã‚¯: {task_summary['total_active']}ä»¶", "blue")
        
        return knowledge_content, integration
        
    except Exception as e:
        print_colored(f"âš ï¸ ã‚¿ã‚¹ã‚¯åŒæœŸã‚¨ãƒ©ãƒ¼: {e}", "yellow")
        print_colored("âš ï¸ ã‚¿ã‚¹ã‚¯åŒæœŸã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ç¶šè¡Œã—ã¾ã™", "yellow")
        return knowledge_content, None


async def main():
    parser = argparse.ArgumentParser(
        description="AI Elder Cast with Task Integration - ã‚¿ã‚¹ã‚¯çµ±åˆç‰ˆã‚¯ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ«ãƒ€ãƒ¼",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ä½¿ç”¨ä¾‹:
  ai-elder-cast-with-tasks                    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆmedium + ã‚¿ã‚¹ã‚¯åŒæœŸï¼‰
  ai-elder-cast-with-tasks core              # ã‚³ã‚¢ç‰ˆ + ã‚¿ã‚¹ã‚¯åŒæœŸ
  ai-elder-cast-with-tasks --no-sync         # ã‚¿ã‚¹ã‚¯åŒæœŸãªã—
  ai-elder-cast-with-tasks --list            # ã‚»ã‚¯ã‚·ãƒ§ãƒ³ä¸€è¦§
        """,
    )
    
    parser.add_argument(
        "sections", nargs="*", default=["medium"], 
        help="èª­ã¿è¾¼ã‚€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: mediumï¼‰"
    )
    
    parser.add_argument(
        "--list", "-l", action="store_true", 
        help="åˆ©ç”¨å¯èƒ½ãªã‚»ã‚¯ã‚·ãƒ§ãƒ³ä¸€è¦§ã‚’è¡¨ç¤º"
    )
    
    parser.add_argument(
        "--no-sync", action="store_true",
        help="ã‚¿ã‚¹ã‚¯åŒæœŸã‚’ã‚¹ã‚­ãƒƒãƒ—"
    )
    
    parser.add_argument(
        "--daemon", action="store_true",
        help="ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ã‚¿ã‚¹ã‚¯åŒæœŸãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚’èµ·å‹•"
    )
    
    args = parser.parse_args()
    
    # ã‚»ã‚¯ã‚·ãƒ§ãƒ³ä¸€è¦§è¡¨ç¤º
    if args.list:
        print_colored("ğŸ“š åˆ©ç”¨å¯èƒ½ãªçŸ¥è­˜ã‚»ã‚¯ã‚·ãƒ§ãƒ³:", "purple")
        print()
        for key, section in KNOWLEDGE_SECTIONS.items():
            print(f"  {key:<10} - {section['name']:<20} {section['description']}")
        print()
        return
    
    print_colored("ğŸ”® AI Elder Cast with Task Integration èµ·å‹•", "purple")
    print_colored("ğŸ›ï¸ ã‚¨ãƒ«ãƒ€ãƒ¼ã‚ºã‚®ãƒ«ãƒ‰ ã‚¿ã‚¹ã‚¯çµ±åˆã‚·ã‚¹ãƒ†ãƒ ", "bold")
    print()
    
    # ã‚¿ã‚¹ã‚¯åŒæœŸã¨çŸ¥è­˜æº–å‚™
    knowledge_content, integration = await sync_and_prepare_knowledge(
        args.sections, 
        no_sync=args.no_sync
    )
    
    # ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ¢ãƒ¼ãƒ‰ã®å‡¦ç†
    if args.daemon and integration:
        print_colored("ğŸ”„ ã‚¿ã‚¹ã‚¯åŒæœŸãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚’èµ·å‹•ã—ã¾ã™...", "cyan")
        integration.auto_sync = True
        integration.sync_interval = 300  # 5åˆ†é–“éš”
        await integration.start_auto_sync()
        print_colored("âœ… ãƒ‡ãƒ¼ãƒ¢ãƒ³èµ·å‹•å®Œäº†ï¼ˆ5åˆ†é–“éš”ã§è‡ªå‹•åŒæœŸï¼‰", "green")
    
    # ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
    with tempfile.NamedTemporaryFile(
        mode="w", encoding="utf-8", suffix=".md", delete=False
    ) as tmp:
        tmp.write(knowledge_content)
        tmp_path = tmp.name
    
    # æ—¥æœ¬èªç’°å¢ƒè¨­å®š
    os.environ["LANG"] = "ja_JP.UTF-8"
    os.environ["LC_ALL"] = "ja_JP.UTF-8"
    
    # Claude Codeèµ·å‹•
    try:
        print_colored("ğŸ›ï¸ ã‚¯ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ«ãƒ€ãƒ¼å¬å–šä¸­...", "green")
        print()
        
        subprocess.run(["claude", "--dangerously-skip-permissions", tmp_path])
        
    finally:
        # ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤
        if os.path.exists(tmp_path):
            os.unlink(tmp_path)
        
        # çµ±åˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        if integration:
            await integration.stop_auto_sync()
            if integration.tracker:
                await integration.tracker.close()
    
    print()
    print_colored("ğŸ›ï¸ Elder Cast ã‚»ãƒƒã‚·ãƒ§ãƒ³å®Œäº†", "green")


if __name__ == "__main__":
    # éåŒæœŸãƒ¡ã‚¤ãƒ³é–¢æ•°ã‚’å®Ÿè¡Œ
    asyncio.run(main())