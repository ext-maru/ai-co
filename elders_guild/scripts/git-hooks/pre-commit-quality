#!/usr/bin/env python3
"""
ğŸ›ï¸ Elder Guild Git Pre-commit Quality Hook
ã‚¨ãƒ«ãƒ€ãƒ¼ã‚ºã‚®ãƒ«ãƒ‰å“è³ªä¿è¨¼ Git ãƒ•ãƒƒã‚¯

Features:
- ã‚³ãƒŸãƒƒãƒˆå‰ã®è‡ªå‹•å“è³ªãƒã‚§ãƒƒã‚¯
- Iron Willéµå®ˆå¼·åˆ¶
- å“è³ªã‚¹ã‚³ã‚¢åŸºæº–æœªæº€ã§ã‚³ãƒŸãƒƒãƒˆé˜»æ­¢
- æ”¹å–„ææ¡ˆã¨ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹
"""

import sys
import os
import subprocess
import json
import asyncio
from pathlib import Path
from typing import List, Dict, Any

# Add project root to path
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from libs.elders_code_quality_engine import quick_analyze

class Colors:
    """ANSI color codes"""
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    END = '\033[0m'

class ElderGuildPreCommitHook:
    """ã‚¨ãƒ«ãƒ€ãƒ¼ã‚ºã‚®ãƒ«ãƒ‰å“è³ªä¿è¨¼ Pre-commit ãƒ•ãƒƒã‚¯"""
    
    def __init__(self):
        self.db_params = {
            'host': 'localhost',
            'database': 'elders_guild_pgvector',
            'user': 'postgres',
            'password': ''
        }
        self.minimum_quality_score = 70.0
        self.iron_will_required = True
        self.max_files_to_check = 50
        
    def get_staged_python_files(self) -> List[str]:
        """ã‚¹ãƒ†ãƒ¼ã‚¸ã•ã‚ŒãŸPythonãƒ•ã‚¡ã‚¤ãƒ«å–å¾—"""
        try:
            # Get staged files
            result = subprocess.run(
                ['git', 'diff', '--cached', '--name-only', '--diff-filter=ACM'],
                capture_output=True,
                text=True,
                check=True
            )
            
            files = result.stdout.strip().split('\n') if result.stdout.strip() else []
            
            # Filter Python files and check if they exist
            python_files = []
            for file in files:
                if file.endswith('.py') and os.path.exists(file):
                    python_files.append(file)
                    
            return python_files[:self.max_files_to_check]
            
        except subprocess.CalledProcessError as e:
            print(f"{Colors.RED}âŒ Failed to get staged files: {e}{Colors.END}")
            return []
            
    def print_header(self):
        """ãƒ˜ãƒƒãƒ€ãƒ¼è¡¨ç¤º"""
        print(f"{Colors.PURPLE}{Colors.BOLD}")
        print("ğŸ›ï¸  ELDERS GUILD QUALITY ASSURANCE")
        print("    ã‚¨ãƒ«ãƒ€ãƒ¼ã‚ºã‚®ãƒ«ãƒ‰å“è³ªä¿è¨¼ã‚·ã‚¹ãƒ†ãƒ ")
        print("    Pre-commit Quality Check")
        print(f"{Colors.END}")
        
    async def analyze_file_quality(self, file_path: str) -> Dict[str, Any]:
        """ãƒ•ã‚¡ã‚¤ãƒ«å“è³ªåˆ†æ"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                code = f.read()
                
            result = await quick_analyze(code, self.db_params)
            
            analysis = result.get('analysis', {})
            return {
                'file': file_path,
                'quality_score': analysis.get('quality_score', 0),
                'iron_will_compliance': analysis.get('iron_will_compliance', False),
                'tdd_compatibility': analysis.get('tdd_compatibility', False),
                'issues': analysis.get('issues', []),
                'suggestions': analysis.get('suggestions', []),
                'bug_risks': analysis.get('bug_risks', []),
                'complexity_score': analysis.get('complexity_score', 0)
            }
            
        except Exception as e:
            return {
                'file': file_path,
                'error': str(e),
                'quality_score': 0,
                'iron_will_compliance': False
            }
            
    async def check_quality_gate(self, files: List[str]) -> Dict[str, Any]:
        """å“è³ªã‚²ãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯"""
        if not files:
            return {
                'status': 'skipped',
                'reason': 'No Python files to check',
                'gate_decision': 'approved'
            }
            
        print(f"{Colors.CYAN}ğŸ” Analyzing {len(files)} Python file(s)...{Colors.END}")
        
        results = []
        quality_violations = []
        iron_will_violations = []
        high_risk_bugs = []
        
        for file_path in files:
            print(f"  ğŸ“„ {file_path}", end=" ... ")
            
            analysis = await self.analyze_file_quality(file_path)
            results.append(analysis)
            
            if 'error' in analysis:
                print(f"{Colors.RED}âŒ Error{Colors.END}")
                continue
                
            quality_score = analysis['quality_score']
            iron_will = analysis['iron_will_compliance']
            
            # å“è³ªã‚¹ã‚³ã‚¢è¡¨ç¤º
            if quality_score >= 85:
                color = Colors.GREEN
                status = "âœ…"
            elif quality_score >= self.minimum_quality_score:
                color = Colors.YELLOW
                status = "âš ï¸"
            else:
                color = Colors.RED
                status = "âŒ"
                
            print(f"{color}{status} {quality_score:.1f}/100{Colors.END}")
            
            # é•åãƒã‚§ãƒƒã‚¯
            if quality_score < self.minimum_quality_score:
                quality_violations.append(analysis)
                
            if self.iron_will_required and not iron_will:
                iron_will_violations.append(analysis)
                
            high_risk = [risk for risk in analysis.get('bug_risks', []) if risk.get('risk_level', 0) > 7]
            if high_risk:
                high_risk_bugs.append(analysis)
                
        # çµæœåˆ¤å®š
        has_violations = bool(quality_violations or iron_will_violations or high_risk_bugs)
        
        # çµ±è¨ˆè¨ˆç®—
        valid_results = [r for r in results if 'error' not in r]
        avg_quality = sum(r['quality_score'] for r in valid_results) / len(valid_results) if valid_results else 0
        
        return {
            'status': 'completed',
            'gate_decision': 'blocked' if has_violations else 'approved',
            'total_files': len(files),
            'analyzed_files': len(valid_results),
            'average_quality_score': avg_quality,
            'quality_violations': quality_violations,
            'iron_will_violations': iron_will_violations,
            'high_risk_bugs': high_risk_bugs,
            'all_results': results
        }
        
    def print_quality_summary(self, gate_result: Dict[str, Any]):
        """å“è³ªã‚µãƒãƒªãƒ¼è¡¨ç¤º"""
        print(f"\n{Colors.BOLD}ğŸ“Š QUALITY GATE SUMMARY{Colors.END}")
        print("=" * 40)
        
        files = gate_result['analyzed_files']
        avg_score = gate_result['average_quality_score']
        
        print(f"ğŸ“ Files analyzed: {files}")
        
        # å¹³å‡å“è³ªã‚¹ã‚³ã‚¢
        if avg_score >= 85:
            score_color = Colors.GREEN
            score_icon = "ğŸ†"
        elif avg_score >= self.minimum_quality_score:
            score_color = Colors.YELLOW
            score_icon = "âš ï¸"
        else:
            score_color = Colors.RED
            score_icon = "ğŸš¨"
            
        print(f"ğŸ¯ Average quality: {score_color}{score_icon} {avg_score:.1f}/100{Colors.END}")
        
        # ã‚²ãƒ¼ãƒˆçµæœ
        if gate_result['gate_decision'] == 'approved':
            print(f"{Colors.GREEN}{Colors.BOLD}âœ… QUALITY GATE: APPROVED{Colors.END}")
            print(f"{Colors.GREEN}ğŸ‰ All files meet Elder Guild quality standards!{Colors.END}")
        else:
            print(f"{Colors.RED}{Colors.BOLD}ğŸš¨ QUALITY GATE: BLOCKED{Colors.END}")
            print(f"{Colors.RED}â›” Commit blocked due to quality violations{Colors.END}")
            
    def print_violations(self, gate_result: Dict[str, Any]):
        """é•åè©³ç´°è¡¨ç¤º"""
        # Iron Willé•å
        iron_will_violations = gate_result.get('iron_will_violations', [])
        if iron_will_violations:
            print(f"\n{Colors.RED}{Colors.BOLD}âš”ï¸  IRON WILL VIOLATIONS (Critical):{Colors.END}")
            for violation in iron_will_violations:
                print(f"  ğŸ“„ {violation['file']}")
                print(f"     ğŸš¨ Workaround/TODO comments detected")
                print(f"     ğŸ’¡ Remove all temporary fixes and complete implementation")
                
        # å“è³ªé•å
        quality_violations = gate_result.get('quality_violations', [])
        if quality_violations:
            print(f"\n{Colors.YELLOW}{Colors.BOLD}ğŸ“Š QUALITY VIOLATIONS:{Colors.END}")
            for violation in quality_violations:
                score = violation['quality_score']
                print(f"  ğŸ“„ {violation['file']} (Score: {score:.1f}/100)")
                
                # ä¸»è¦å•é¡Œè¡¨ç¤º
                issues = violation.get('issues', [])
                high_severity_issues = [i for i in issues if i.get('severity', 0) > 6]
                for issue in high_severity_issues[:3]:
                    print(f"     ğŸ”¥ {issue.get('name', 'Issue')}: {issue.get('description', 'No description')}")
                    
                # æ”¹å–„ææ¡ˆ
                suggestions = violation.get('suggestions', [])
                high_priority_suggestions = [s for s in suggestions if s.get('priority') == 'high']
                for suggestion in high_priority_suggestions[:2]:
                    print(f"     ğŸ’¡ {suggestion.get('title', 'Suggestion')}")
                    
        # é«˜ãƒªã‚¹ã‚¯ãƒã‚°
        high_risk_bugs = gate_result.get('high_risk_bugs', [])
        if high_risk_bugs:
            print(f"\n{Colors.RED}{Colors.BOLD}ğŸ› HIGH-RISK BUGS:{Colors.END}")
            for bug_file in high_risk_bugs:
                print(f"  ğŸ“„ {bug_file['file']}")
                for risk in bug_file.get('bug_risks', []):
                    if risk.get('risk_level', 0) > 7:
                        print(f"     âš ï¸  {risk.get('name', 'Bug Risk')}: {risk.get('description', 'No description')}")
                        
    def print_improvement_guide(self):
        """æ”¹å–„ã‚¬ã‚¤ãƒ‰è¡¨ç¤º"""
        print(f"\n{Colors.BLUE}{Colors.BOLD}ğŸ› ï¸  IMPROVEMENT GUIDE:{Colors.END}")
        print(f"{Colors.CYAN}ğŸ“š Quick fixes:{Colors.END}")
        print("  1. Remove all TODO/FIXME comments (Iron Will)")
        print("  2. Add type hints: def func(x: int) -> str:")
        print("  3. Add docstrings: \"\"\"Function description\"\"\"")
        print("  4. Add error handling: try/except blocks")
        print("  5. Reduce complexity: break large functions")
        print()
        print(f"{Colors.CYAN}ğŸ”§ Quality tools:{Colors.END}")
        print("  elders-code-quality analyze <file>    # Detailed analysis")
        print("  elders-code-quality report .          # Project overview")
        print()
        print(f"{Colors.CYAN}ğŸ“– Resources:{Colors.END}")
        print("  CLAUDE.md - Elder Guild development standards")
        print("  knowledge_base/ - Best practices and guides")
        
    async def run_quality_check(self) -> int:
        """å“è³ªãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ"""
        self.print_header()
        
        # ã‚¹ãƒ†ãƒ¼ã‚¸ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«å–å¾—
        staged_files = self.get_staged_python_files()
        
        if not staged_files:
            print(f"{Colors.GREEN}âœ… No Python files to check{Colors.END}")
            return 0
            
        print(f"ğŸ“‹ Found {len(staged_files)} staged Python file(s)")
        
        # å“è³ªã‚²ãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ
        gate_result = await self.check_quality_gate(staged_files)
        
        # çµæœè¡¨ç¤º
        self.print_quality_summary(gate_result)
        
        if gate_result['gate_decision'] == 'blocked':
            self.print_violations(gate_result)
            self.print_improvement_guide()
            
            print(f"\n{Colors.RED}{Colors.BOLD}ğŸ›‘ COMMIT BLOCKED{Colors.END}")
            print(f"{Colors.RED}Fix the above issues and try again{Colors.END}")
            print(f"{Colors.YELLOW}ğŸ’¡ Use: git commit --no-verify to bypass (not recommended){Colors.END}")
            return 1
        else:
            print(f"\n{Colors.GREEN}{Colors.BOLD}ğŸš€ COMMIT APPROVED{Colors.END}")
            print(f"{Colors.GREEN}Code quality meets Elder Guild standards{Colors.END}")
            return 0

async def main():
    """ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œ"""
    hook = ElderGuildPreCommitHook()
    return await hook.run_quality_check()

if __name__ == "__main__":
    try:
        exit_code = asyncio.run(main())
        sys.exit(exit_code)
    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}ğŸ›‘ Quality check cancelled{Colors.END}")
        sys.exit(1)
    except Exception as e:
        print(f"\n{Colors.RED}âŒ Quality check failed: {e}{Colors.END}")
        sys.exit(1)