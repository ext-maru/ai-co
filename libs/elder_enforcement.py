#!/usr/bin/env python3
"""
„Ç®„É´„ÉÄ„Éº„ÅÆÈ≠ÇÂº∑Âà∂ÂÆüË°å„Ç∑„Çπ„ÉÜ„É†
Elder Soul Enforcement System

„Åô„Åπ„Å¶„ÅÆÊñ∞ÂΩπÂâ≤„Å®„Éó„É≠„Çª„Çπ„ÅåÂøÖ„Åö„Ç®„É´„ÉÄ„Éº„ÅÆÈ≠Ç„Çí‰ΩøÁî®„Åô„Çã„Çà„ÅÜ„Å´„Åô„ÇãÂº∑Âà∂Ê©üÊßã
"""

import os
import sys
import json
import inspect
import logging
from pathlib import Path
from typing import Dict, Any, List, Optional, Callable
from functools import wraps
from datetime import datetime
import asyncio

# „Éó„É≠„Ç∏„Çß„ÇØ„Éà„É´„Éº„Éà„Çí„Éë„Çπ„Å´ËøΩÂä†
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

from libs.elder_registry import ElderRegistry, AgentType


class EnforcementError(Exception):
    """Âº∑Âà∂ÂÆüË°åÈÅïÂèç„Ç®„É©„Éº"""

    pass


class ElderTreeEnforcement:
    """
    „Ç®„É´„ÉÄ„Éº„ÅÆÈ≠Ç Âº∑Âà∂ÂÆüË°å„Ç∑„Çπ„ÉÜ„É†

    Ê©üËÉΩ:
    - Êñ∞„Åó„ÅÑ„Éó„É≠„Çª„Çπ/ÂΩπÂâ≤„ÅÆËá™ÂãïÊ§úÂá∫
    - „Ç®„É´„ÉÄ„Éº„ÅÆÈ≠Ç„Å∏„ÅÆÂº∑Âà∂ÁôªÈå≤
    - ÈùûÊ∫ñÊã†„Éó„É≠„Çª„Çπ„ÅÆË≠¶Âëä„ÉªÂÅúÊ≠¢
    - ÈñãÁô∫ËÄÖ„Å∏„ÅÆÊïôËÇ≤„É°„ÉÉ„Çª„Éº„Ç∏
    """

    def __init__(self):
        """ÂàùÊúüÂåñ„É°„ÇΩ„ÉÉ„Éâ"""
        self.registry = ElderRegistry()
        self.logger = self._setup_logger()

        # Âº∑Âà∂ÂÆüË°åË®≠ÂÆö
        self.enforcement_config = {
            "auto_register": True,  # Ëá™ÂãïÁôªÈå≤
            "strict_mode": True,  # Âé≥Ê†º„É¢„Éº„Éâ
            "education_mode": True,  # ÊïôËÇ≤„É¢„Éº„Éâ
            "grace_period": 300,  # Áå∂‰∫àÊúüÈñìÔºàÁßíÔºâ
            "violations_log": "data/violations.json",
        }

        # Èô§Â§ñ„Éë„Çø„Éº„É≥
        self.exclusions = {
            "system_processes": ["systemd", "init", "kernel"],
            "development_tools": ["python", "node", "npm", "git"],
            "existing_legacy": ["old_workers", "legacy_scripts"],
        }

        # ÈÅïÂèçË®òÈå≤
        self.violations: List[Dict[str, Any]] = []
        self.warned_processes: Dict[str, datetime] = {}

    def _setup_logger(self) -> logging.Logger:
        """„É≠„Ç¨„ÉºË®≠ÂÆö"""
        logger = logging.getLogger("elder_enforcement")
        logger.setLevel(logging.INFO)

        if not logger.handlers:
            # „Éï„Ç°„Ç§„É´„Éè„É≥„Éâ„É©„Éº
            log_dir = Path("logs")
            log_dir.mkdir(exist_ok=True)
            file_handler = logging.FileHandler(log_dir / "elder_enforcement.log")

            # „Ç≥„É≥„ÇΩ„Éº„É´„Éè„É≥„Éâ„É©„Éº
            console_handler = logging.StreamHandler()

            # „Éï„Ç©„Éº„Éû„ÉÉ„Çø„Éº
            formatter = logging.Formatter(
                "%(asctime)s - ElderEnforcement - %(levelname)s - %(message)s"
            )
            file_handler.setFormatter(formatter)
            console_handler.setFormatter(formatter)

            logger.addHandler(file_handler)
            logger.addHandler(console_handler)

        return logger

    async def initialize(self):
        """Âº∑Âà∂ÂÆüË°å„Ç∑„Çπ„ÉÜ„É†ÂàùÊúüÂåñ"""
        await self.registry.initialize()
        await self._load_violations()
        await self._setup_enforcement_rules()

        self.logger.info("üõ°Ô∏è Elder Tree Enforcement System initialized")

    async def enforce_elder_tree_usage(self):
        """„Ç®„É´„ÉÄ„Éº„ÅÆÈ≠Ç‰ΩøÁî®„ÇíÂº∑Âà∂"""
        self.logger.info("üîç Scanning for non-compliant processes...")

        # Êñ∞„Åó„ÅÑ„Éó„É≠„Çª„Çπ/ÂΩπÂâ≤„ÅÆÊ§úÂá∫
        violations = await self._detect_violations()

        if violations:
            self.logger.warning(f"‚ö†Ô∏è Found {len(violations)} violations")

            for violation in violations:
                await self._handle_violation(violation)
        else:
            self.logger.info("‚úÖ All processes are Elder Tree compliant")

    async def register_new_role(
        self, role_info: Dict[str, Any], auto_approve: bool = False
    ) -> bool:
        """
        Êñ∞ÂΩπÂâ≤„ÅÆÁôªÈå≤

        Args:
            role_info: ÂΩπÂâ≤ÊÉÖÂ†±
            auto_approve: Ëá™ÂãïÊâøË™ç„Éï„É©„Ç∞

        Returns:
            bool: ÁôªÈå≤ÊàêÂäü„Éï„É©„Ç∞
        """
        self.logger.info(f"üìã Registering new role: {role_info.get('name', 'Unknown')}")

        # ÂøÖÈ†à„Éï„Ç£„Éº„É´„Éâ„ÉÅ„Çß„ÉÉ„ÇØ
        required_fields = ["name", "description", "type", "capabilities"]
        missing_fields = [field for field in required_fields if field not in role_info]

        if missing_fields:
            raise EnforcementError(f"Missing required fields: {missing_fields}")

        # „Ç®„É´„ÉÄ„Éº„ÅÆÈ≠Ç„Å∏„ÅÆËá™ÂãïÁôªÈå≤
        try:
            agent = await self.registry.register_agent(
                agent_id=role_info.get(
                    "id", role_info["name"].lower().replace(" ", "_")
                ),
                name=role_info["name"],
                description=role_info["description"],
                agent_type=AgentType(role_info["type"]),
                capabilities=role_info["capabilities"],
                dependencies=role_info.get("dependencies", []),
                auto_start=role_info.get("auto_start", True),
            )

            self.logger.info(f"‚úÖ Successfully registered: {agent.name}")

            # ÈñãÁô∫ËÄÖ„Å∏„ÅÆÊïôËÇ≤„É°„ÉÉ„Çª„Éº„Ç∏
            if self.enforcement_config["education_mode"]:
                await self._send_education_message(role_info, agent)

            return True

        except Exception as e:
            self.logger.error(f"‚ùå Failed to register role: {e}")
            return False

    async def validate_process_compliance(self, process_info: Dict[str, Any]) -> bool:
        """„Éó„É≠„Çª„Çπ„ÅÆÊ∫ñÊã†ÊÄßÊ§úË®º"""
        process_name = process_info.get("name", "unknown")

        # Èô§Â§ñ„ÉÅ„Çß„ÉÉ„ÇØ
        if await self._is_excluded_process(process_info):
            return True

        # „Ç®„É´„ÉÄ„Éº„ÉÑ„É™„ÉºÁôªÈå≤„ÉÅ„Çß„ÉÉ„ÇØ
        agent_id = self._extract_agent_id(process_info)
        if agent_id and agent_id in self.registry.agents:
            return True

        # Ê∫ñÊã†„Éë„Çø„Éº„É≥„ÉÅ„Çß„ÉÉ„ÇØ
        if await self._matches_elder_pattern(process_info):
            return True

        # ÈÅïÂèç„Å®„Åó„Å¶Ë®òÈå≤
        await self._record_violation(process_info)
        return False

    # „Éá„Ç≥„É¨„Éº„Çø„Éº
    def require_elder_registration(self, agent_type: AgentType = AgentType.SERVANT):
        """
        „Ç®„É´„ÉÄ„ÉºÁôªÈå≤ÂøÖÈ†à„Éá„Ç≥„É¨„Éº„Çø„Éº

        ‰ΩøÁî®‰æã:
        @require_elder_registration(AgentType.SERVANT)
        def my_new_function():
            pass
        """

        def decorator(func:
            """decorator„É°„ÇΩ„ÉÉ„Éâ"""
        Callable) -> Callable:
            @wraps(func)
            async def wrapper(*args, **kwargs):
                """wrapper„É°„ÇΩ„ÉÉ„Éâ"""
                # Èñ¢Êï∞„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó
                func_info = {
                    "name": func.__name__,
                    "module": func.__module__,
                    "file": inspect.getfile(func),
                    "type": agent_type.value,
                }

                # Ëá™ÂãïÁôªÈå≤
                if self.enforcement_config["auto_register"]:
                    await self._auto_register_function(func_info, agent_type)

                # Âé≥Ê†º„É¢„Éº„Éâ„Åß„ÅÆÊ§úË®º
                if self.enforcement_config["strict_mode"]:
                    if not await self._verify_function_compliance(func_info):
                        raise EnforcementError(
                            f"Function {func.__name__} is not registered with Elder Soul. "
                            f"Please register using: elder-tree-soul register {func.__name__}"
                        )

                return (
                    await func(*args, **kwargs)
                    if asyncio.iscoroutinefunction(func)
                    else func(*args, **kwargs)
                )

            return wrapper

        return decorator

    # „Éó„É©„Ç§„Éô„Éº„Éà„É°„ÇΩ„ÉÉ„Éâ

    async def _detect_violations(self) -> List[Dict[str, Any]]:
        """ÈÅïÂèç„ÅÆÊ§úÂá∫"""
        violations = []

        # 1. „Éó„É≠„Çª„Çπ„Çπ„Ç≠„É£„É≥
        process_violations = await self._scan_processes()
        violations.extend(process_violations)

        # 2. „Éï„Ç°„Ç§„É´„Çπ„Ç≠„É£„É≥
        file_violations = await self._scan_files()
        violations.extend(file_violations)

        # 3. „Éù„Éº„Éà„Çπ„Ç≠„É£„É≥
        port_violations = await self._scan_ports()
        violations.extend(port_violations)

        return violations

    async def _scan_processes(self) -> List[Dict[str, Any]]:
        """„Éó„É≠„Çª„Çπ„Çπ„Ç≠„É£„É≥"""
        violations = []

        try:
            import psutil

            for proc in psutil.process_iter(["pid", "name", "cmdline"]):
                try:
                    process_info = proc.info

                    # „Ç®„É´„ÉÄ„ÉºÈñ¢ÈÄ£„Éó„É≠„Çª„Çπ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                    if await self._is_potential_elder_process(process_info):
                        if not await self.validate_process_compliance(process_info):
                            violations.append(
                                {
                                    "type": "process",
                                    "process": process_info,
                                    "reason": "Unregistered elder-like process",
                                }
                            )
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue

        except ImportError:
            self.logger.warning("psutil not available for process scanning")

        return violations

    async def _scan_files(self) -> List[Dict[str, Any]]:
        """„Éï„Ç°„Ç§„É´„Çπ„Ç≠„É£„É≥"""
        violations = []

        # „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÂÜÖ„ÅÆPython„Éï„Ç°„Ç§„É´„Çí„Çπ„Ç≠„É£„É≥
        for py_file in Path(PROJECT_ROOT).rglob("*.py"):
            if await self._is_potential_elder_file(py_file):
                file_info = await self._analyze_file(py_file)

                if not await self._is_file_compliant(file_info):
                    violations.append(
                        {
                            "type": "file",
                            "file": str(py_file),
                            "info": file_info,
                            "reason": "Non-compliant elder file",
                        }
                    )

        return violations

    async def _scan_ports(self) -> List[Dict[str, Any]]:
        """„Éù„Éº„Éà„Çπ„Ç≠„É£„É≥"""
        violations = []

        # „Ç®„É´„ÉÄ„Éº„Éù„Éº„ÉàÁØÑÂõ≤„ÅÆ„Çπ„Ç≠„É£„É≥
        elder_port_ranges = [
            (5000, 5999),  # „Ç®„É´„ÉÄ„Éº„ÉªË≥¢ËÄÖ„Éù„Éº„Éà
            (6000, 6999),  # „Çµ„Éº„Éê„É≥„Éà„Éù„Éº„Éà
            (7000, 7999),  # È®éÂ£´Âõ£„Éù„Éº„Éà
            (8000, 8999),  # „Ç®„É´„Éï„Éù„Éº„Éà
        ]

        for start_port, end_port in elder_port_ranges:
            for port in range(start_port, end_port + 1):
                if await self._is_port_used_by_unregistered_process(port):
                    violations.append(
                        {
                            "type": "port",
                            "port": port,
                            "reason": "Port used by unregistered process",
                        }
                    )

        return violations

    async def _handle_violation(self, violation: Dict[str, Any]):
        """ÈÅïÂèçÂá¶ÁêÜ"""
        violation_type = violation["type"]

        self.logger.warning(f"üö® Violation detected: {violation['reason']}")

        if violation_type == "process":
            await self._handle_process_violation(violation)
        elif violation_type == "file":
            await self._handle_file_violation(violation)
        elif violation_type == "port":
            await self._handle_port_violation(violation)

        # ÈÅïÂèçË®òÈå≤
        await self._record_violation(violation)

    async def _handle_process_violation(self, violation: Dict[str, Any]):
        """„Éó„É≠„Çª„ÇπÈÅïÂèçÂá¶ÁêÜ"""
        process_info = violation["process"]
        process_name = process_info.get("name", "unknown")

        # Ë≠¶ÂëäÊúüÈñì„ÉÅ„Çß„ÉÉ„ÇØ
        if process_name in self.warned_processes:
            warning_time = self.warned_processes[process_name]
            elapsed = (datetime.now() - warning_time).total_seconds()

            if elapsed > self.enforcement_config["grace_period"]:
                # Áå∂‰∫àÊúüÈñìÁµåÈÅé - Âº∑Âà∂Âá¶ÁêÜ
                await self._force_process_compliance(process_info)
            else:
                # Áå∂‰∫àÊúüÈñìÂÜÖ - ÂÜçË≠¶Âëä
                self.logger.warning(
                    f"Grace period remaining for {process_name}: "
                    f"{self.enforcement_config['grace_period'] - elapsed:.0f}s"
                )
        else:
            # ÂàùÂõûË≠¶Âëä
            await self._warn_process(process_info)

    async def _handle_file_violation(self, violation: Dict[str, Any]):
        """„Éï„Ç°„Ç§„É´ÈÅïÂèçÂá¶ÁêÜ"""
        file_path = violation["file"]
        file_info = violation["info"]

        # Ëá™Âãï‰øÆÊ≠£„ÇíË©¶Ë°å
        if self.enforcement_config["auto_register"]:
            await self._auto_fix_file(file_path, file_info)
        else:
            await self._warn_file_violation(file_path, file_info)

    async def _handle_port_violation(self, violation: Dict[str, Any]):
        """„Éù„Éº„ÉàÈÅïÂèçÂá¶ÁêÜ"""
        port = violation["port"]

        # „Éù„Éº„Éà‰ΩøÁî®„Éó„É≠„Çª„Çπ„ÇíÁâπÂÆö
        using_process = await self._identify_port_user(port)

        if using_process:
            self.logger.warning(
                f"üîå Port {port} used by unregistered process: {using_process}"
            )

            # „Éó„É≠„Çª„ÇπÊÉÖÂ†±„Å®„Åó„Å¶Âá¶ÁêÜ
            await self._handle_process_violation(
                {
                    "type": "process",
                    "process": using_process,
                    "reason": f"Using elder port {port} without registration",
                }
            )

    async def _force_process_compliance(self, process_info: Dict[str, Any]):
        """„Éó„É≠„Çª„ÇπÊ∫ñÊã†„ÅÆÂº∑Âà∂"""
        process_name = process_info.get("name", "unknown")
        pid = process_info.get("pid")

        if self.enforcement_config["strict_mode"]:
            self.logger.error(
                f"üõë FORCE STOPPING non-compliant process: {process_name} (PID: {pid})"
            )

            # „Éó„É≠„Çª„ÇπÁµÇ‰∫Ü
            try:
                import psutil

                proc = psutil.Process(pid)
                proc.terminate()

                # ÊïôËÇ≤„É°„ÉÉ„Çª„Éº„Ç∏Ë°®Á§∫
                await self._show_compliance_education(process_info)

            except Exception as e:
                self.logger.error(f"Failed to terminate process {pid}: {e}")
        else:
            self.logger.warning(
                f"‚ö†Ô∏è Would terminate {process_name} (strict mode disabled)"
            )

    async def _warn_process(self, process_info: Dict[str, Any]):
        """„Éó„É≠„Çª„ÇπË≠¶Âëä"""
        process_name = process_info.get("name", "unknown")

        warning_msg = f"""
üö® ELDER TREE SOUL VIOLATION DETECTED üö®

Process: {process_name}
PID: {process_info.get('pid')}
Command: {' '.join(process_info.get('cmdline', []))}

‚ö†Ô∏è This process appears to be an Elder-like service but is not registered
   with the Elder Soul system.

üîß To fix this violation:
   1. Register with Elder Soul: elder-tree-soul register {process_name}
   2. Or modify your code to use the Elder Soul framework

‚è∞ Grace period: {self.enforcement_config['grace_period']} seconds
   After this period, the process will be automatically terminated.

üìö Documentation: {PROJECT_ROOT}/docs/elder_soul_plan.md
"""

        print(warning_msg)
        self.logger.warning(f"Warned process: {process_name}")

        # Ë≠¶ÂëäÊôÇÂàªË®òÈå≤
        self.warned_processes[process_name] = datetime.now()

    async def _show_compliance_education(self, process_info: Dict[str, Any]):
        """Ê∫ñÊã†ÊïôËÇ≤„É°„ÉÉ„Çª„Éº„Ç∏"""
        education_msg = f"""
üå≤ ELDER TREE SOUL EDUCATION üå≤

Your process has been terminated because it violated Elder Soul policies.

üìã What happened:
   Your process appeared to be an Elder-like service but was not properly
   registered with the Elder Soul system.

üéØ Why this matters:
   - Elder Soul ensures proper A2A communication
   - Maintains system hierarchy and order
   - Provides automatic monitoring and management
   - Enables dynamic scaling and fault tolerance

üîß How to fix:
   1. Use the Elder Soul framework for all new roles
   2. Register existing processes: elder-tree-soul register <name>
   3. Follow the Elder Soul development guidelines

üí° Example:
   # Register a new agent
   elder-tree-soul register my_agent --type servant --auto-start

   # Check compliance
   elder-tree-soul health

üìö Learn more:
   - Documentation: {PROJECT_ROOT}/docs/
   - Examples: {PROJECT_ROOT}/processes/
   - Help: elder-tree-soul --help

üå≤ Remember: "Every Role, Every Process, Every Connection"
"""

        print(education_msg)

    async def _auto_register_function(
        self, func_info: Dict[str, Any], agent_type: AgentType
    ):
        """Èñ¢Êï∞„ÅÆËá™ÂãïÁôªÈå≤"""
        # Èñ¢Êï∞ÊÉÖÂ†±„Åã„Çâ„Ç®„Éº„Ç∏„Çß„É≥„ÉàÊÉÖÂ†±„ÇíÁîüÊàê
        agent_info = {
            "id": func_info["name"],
            "name": func_info["name"].replace("_", " ").title(),
            "description": f"Auto-registered from {func_info['module']}",
            "type": agent_type.value,
            "capabilities": ["auto_generated"],
            "dependencies": [],
            "auto_start": False,
        }

        try:
            await self.register_new_role(agent_info, auto_approve=True)
            self.logger.info(f"‚úÖ Auto-registered function: {func_info['name']}")
        except Exception as e:
            self.logger.error(
                f"‚ùå Failed to auto-register function {func_info['name']}: {e}"
            )

    async def _verify_function_compliance(self, func_info: Dict[str, Any]) -> bool:
        """Èñ¢Êï∞„ÅÆÊ∫ñÊã†ÊÄßÊ§úË®º"""
        agent_id = func_info["name"]
        return agent_id in self.registry.agents

    async def _is_excluded_process(self, process_info: Dict[str, Any]) -> bool:
        """Èô§Â§ñ„Éó„É≠„Çª„Çπ„ÉÅ„Çß„ÉÉ„ÇØ"""
        process_name = process_info.get("name", "").lower()
        cmdline = " ".join(process_info.get("cmdline", [])).lower()

        # „Ç∑„Çπ„ÉÜ„É†„Éó„É≠„Çª„ÇπÈô§Â§ñ
        for pattern in self.exclusions["system_processes"]:
            if pattern in process_name or pattern in cmdline:
                return True

        # ÈñãÁô∫„ÉÑ„Éº„É´Èô§Â§ñ
        for pattern in self.exclusions["development_tools"]:
            if pattern in process_name or pattern in cmdline:
                return True

        # „É¨„Ç¨„Ç∑„Éº„Éó„É≠„Çª„ÇπÈô§Â§ñ
        for pattern in self.exclusions["existing_legacy"]:
            if pattern in cmdline:
                return True

        return False

    async def _is_potential_elder_process(self, process_info: Dict[str, Any]) -> bool:
        """„Ç®„É´„ÉÄ„Éº„Éó„É≠„Çª„ÇπÂÄôË£ú„ÉÅ„Çß„ÉÉ„ÇØ"""
        cmdline = " ".join(process_info.get("cmdline", [])).lower()

        # „Ç®„É´„ÉÄ„ÉºÈñ¢ÈÄ£„Ç≠„Éº„ÉØ„Éº„Éâ
        elder_keywords = [
            "elder",
            "sage",
            "servant",
            "elf",
            "knight",
            "agent",
            "worker",
            "process",
            "daemon",
            "a2a",
            "soul",
        ]

        for keyword in elder_keywords:
            if keyword in cmdline:
                return True

        # „Éù„Éº„Éà„Éë„Çø„Éº„É≥„ÉÅ„Çß„ÉÉ„ÇØ
        elder_ports = ["500", "600", "700", "800"]  # „Ç®„É´„ÉÄ„Éº„Éù„Éº„ÉàÁØÑÂõ≤
        for port_prefix in elder_ports:
            if f"port {port_prefix}" in cmdline or f":{port_prefix}" in cmdline:
                return True

        return False

    async def _is_potential_elder_file(self, file_path: Path) -> bool:
        """„Ç®„É´„ÉÄ„Éº„Éï„Ç°„Ç§„É´ÂÄôË£ú„ÉÅ„Çß„ÉÉ„ÇØ"""
        # „Éï„Ç°„Ç§„É´Âêç„ÉÅ„Çß„ÉÉ„ÇØ
        filename = file_path.name.lower()
        elder_patterns = [
            "_process.py",
            "_agent.py",
            "_worker.py",
            "_servant.py",
            "_sage.py",
            "_elder.py",
        ]

        for pattern in elder_patterns:
            if filename.endswith(pattern):
                return True

        # „Éá„Ç£„É¨„ÇØ„Éà„É™„ÉÅ„Çß„ÉÉ„ÇØ
        if "processes" in file_path.parts or "agents" in file_path.parts:
            return True

        return False

    async def _analyze_file(self, file_path: Path) -> Dict[str, Any]:
        """„Éï„Ç°„Ç§„É´ÂàÜÊûê"""
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                content = f.read()

            # „ÇØ„É©„Çπ„ÉªÈñ¢Êï∞ÊäΩÂá∫
            import ast

            tree = ast.parse(content)

            classes = [
                node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)
            ]
            functions = [
                node.name
                for node in ast.walk(tree)
                if isinstance(node, ast.FunctionDef)
            ]

            return {
                "path": str(file_path),
                "classes": classes,
                "functions": functions,
                "size": len(content),
                "elder_indicators": self._find_elder_indicators(content),
            }

        except Exception as e:
            return {"path": str(file_path), "error": str(e)}

    def _find_elder_indicators(self, content: str) -> List[str]:
        """„Ç®„É´„ÉÄ„ÉºÊåáÊ®ôÊ§úÂá∫"""
        indicators = []

        elder_patterns = [
            "ElderProcessBase",
            "AgentType",
            "ElderMessage",
            "elder_name",
            "elder_role",
            "A2A",
            "elder_tree",
        ]

        for pattern in elder_patterns:
            if pattern in content:
                indicators.append(pattern)

        return indicators

    async def _is_file_compliant(self, file_info: Dict[str, Any]) -> bool:
        """„Éï„Ç°„Ç§„É´Ê∫ñÊã†ÊÄß„ÉÅ„Çß„ÉÉ„ÇØ"""
        # „Ç®„É´„ÉÄ„ÉºÊåáÊ®ô„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        if file_info.get("elder_indicators"):
            # „Ç®„É´„ÉÄ„Éº„Éï„Ç°„Ç§„É´„Å®„Åó„Å¶Ë™çË≠ò - ÁôªÈå≤„ÉÅ„Çß„ÉÉ„ÇØ
            file_path = Path(file_info["path"])
            agent_id = file_path.stem.replace("_process", "").replace("_agent", "")

            return agent_id in self.registry.agents

        # Èùû„Ç®„É´„ÉÄ„Éº„Éï„Ç°„Ç§„É´„ÅØÊ∫ñÊã†„Å®„Åø„Å™„Åô
        return True

    async def _auto_fix_file(self, file_path: str, file_info: Dict[str, Any]):
        """„Éï„Ç°„Ç§„É´„ÅÆËá™Âãï‰øÆÊ≠£"""
        self.logger.info(f"üîß Auto-fixing file: {file_path}")

        # „Éï„Ç°„Ç§„É´„Åã„Çâ„Ç®„Éº„Ç∏„Çß„É≥„ÉàÊÉÖÂ†±„ÇíÊé®ÂÆö
        path_obj = Path(file_path)
        agent_id = path_obj.stem.replace("_process", "").replace("_agent", "")

        # Ëá™ÂãïÁôªÈå≤„ÇíË©¶Ë°å
        agent_info = {
            "id": agent_id,
            "name": agent_id.replace("_", " ").title(),
            "description": f"Auto-discovered from {file_path}",
            "type": "servant",  # „Éá„Éï„Ç©„É´„Éà
            "capabilities": ["auto_discovered"],
            "dependencies": [],
            "auto_start": False,
        }

        await self.register_new_role(agent_info, auto_approve=True)

    async def _warn_file_violation(self, file_path: str, file_info: Dict[str, Any]):
        """„Éï„Ç°„Ç§„É´ÈÅïÂèçË≠¶Âëä"""
        self.logger.warning(f"üìÑ File violation: {file_path}")

    async def _is_port_used_by_unregistered_process(self, port: int) -> bool:
        """Êú™ÁôªÈå≤„Éó„É≠„Çª„Çπ„Å´„Çà„Çã„Éù„Éº„Éà‰ΩøÁî®„ÉÅ„Çß„ÉÉ„ÇØ"""
        # ÁôªÈå≤Ê∏à„Åø„Ç®„Éº„Ç∏„Çß„É≥„Éà„Éù„Éº„Éà„ÉÅ„Çß„ÉÉ„ÇØ
        for agent in self.registry.agents.values():
            if agent.port == port:
                return False  # ÁôªÈå≤Ê∏à„Åø

        # „Éù„Éº„Éà„Åå‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        import socket

        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                result = sock.connect_ex(("localhost", port))
                return result == 0  # ‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Çã
        except:
            return False

    async def _identify_port_user(self, port: int) -> Optional[Dict[str, Any]]:
        """„Éù„Éº„Éà‰ΩøÁî®„Éó„É≠„Çª„ÇπÁâπÂÆö"""
        try:
            import psutil

            for conn in psutil.net_connections():
                if conn.laddr.port == port:
                    try:
                        proc = psutil.Process(conn.pid)
                        return {
                            "pid": conn.pid,
                            "name": proc.name(),
                            "cmdline": proc.cmdline(),
                        }
                    except psutil.NoSuchProcess:
                        continue
        except ImportError:
            pass

        return None

    def _extract_agent_id(self, process_info: Dict[str, Any]) -> Optional[str]:
        """„Éó„É≠„Çª„ÇπÊÉÖÂ†±„Åã„Çâ„Ç®„Éº„Ç∏„Çß„É≥„ÉàIDÊäΩÂá∫"""
        cmdline = " ".join(process_info.get("cmdline", []))

        # _process.py „Éë„Çø„Éº„É≥
        import re

        match = re.search(r"(\w+)_process\.py", cmdline)
        if match:
            return match.group(1)

        return None

    async def _matches_elder_pattern(self, process_info: Dict[str, Any]) -> bool:
        """„Ç®„É´„ÉÄ„Éº„Éë„Çø„Éº„É≥„Éû„ÉÉ„ÉÅ„É≥„Ç∞"""
        cmdline = " ".join(process_info.get("cmdline", [])).lower()

        # Êó¢Áü•„ÅÆ„Ç®„É´„ÉÄ„Éº„Éë„Çø„Éº„É≥
        elder_patterns = [
            "elder_soul",
            "elder-tree-soul",
            "elder_process_base",
            "run_elder_process",
        ]

        for pattern in elder_patterns:
            if pattern in cmdline:
                return True

        return False

    async def _record_violation(self, violation: Dict[str, Any]):
        """ÈÅïÂèçË®òÈå≤"""
        violation_record = {
            "timestamp": datetime.now().isoformat(),
            "violation": violation,
            "action_taken": "warned",
            "resolved": False,
        }

        self.violations.append(violation_record)
        await self._save_violations()

    async def _load_violations(self):
        """ÈÅïÂèçË®òÈå≤Ë™≠„ÅøËæº„Åø"""
        violations_file = Path(self.enforcement_config["violations_log"])
        if violations_file.exists():
            try:
                with open(violations_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                    self.violations = data.get("violations", [])
            except Exception as e:
                self.logger.error(f"Failed to load violations: {e}")

    async def _save_violations(self):
        """ÈÅïÂèçË®òÈå≤‰øùÂ≠ò"""
        violations_file = Path(self.enforcement_config["violations_log"])
        violations_file.parent.mkdir(parents=True, exist_ok=True)

        try:
            with open(violations_file, "w", encoding="utf-8") as f:
                json.dump(
                    {
                        "violations": self.violations,
                        "last_updated": datetime.now().isoformat(),
                    },
                    f,
                    ensure_ascii=False,
                    indent=2,
                )
        except Exception as e:
            self.logger.error(f"Failed to save violations: {e}")

    async def _setup_enforcement_rules(self):
        """Âº∑Âà∂ÂÆüË°å„É´„Éº„É´Ë®≠ÂÆö"""
        # Áí∞Â¢ÉÂ§âÊï∞„Åã„Çâ„ÅÆË®≠ÂÆö„Ç™„Éº„Éê„Éº„É©„Ç§„Éâ
        if os.getenv("ELDER_TREE_STRICT_MODE"):
            self.enforcement_config["strict_mode"] = True

        if os.getenv("ELDER_TREE_AUTO_REGISTER"):
            self.enforcement_config["auto_register"] = True

        # Ë®≠ÂÆö„Éï„Ç°„Ç§„É´„Åã„Çâ„ÅÆË™≠„ÅøËæº„Åø
        config_file = Path("elder_tree_enforcement.json")
        if config_file.exists():
            try:
                with open(config_file, "r") as f:
                    config_override = json.load(f)
                    self.enforcement_config.update(config_override)
            except Exception as e:
                self.logger.error(f"Failed to load enforcement config: {e}")

    async def _send_education_message(self, role_info: Dict[str, Any], agent: Any):
        """ÊïôËÇ≤„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°"""
        if not self.enforcement_config["education_mode"]:
            return

        education_msg = f"""
üéâ SUCCESS: Role registered with Elder Soul!

Role: {agent.name}
Type: {agent.agent_type.value}
Port: {agent.port}

‚úÖ Your role is now part of the Elder Soul system and will benefit from:
   - Automatic A2A communication
   - Built-in monitoring and health checks
   - Dynamic scaling capabilities
   - Hierarchical management

üìö Next steps:
   1. Start your agent: elder-tree-soul start {agent.agent_id}
   2. Check status: elder-tree-soul status
   3. Monitor logs: elder-tree-soul logs {agent.agent_id}

üå≤ Welcome to the Elder Soul ecosystem!
"""

        print(education_msg)


# „Ç∞„É≠„Éº„Éê„É´„Ç§„É≥„Çπ„Çø„É≥„Çπ
_enforcement_instance: Optional[ElderTreeEnforcement] = None


async def get_enforcement() -> ElderTreeEnforcement:
    """Âº∑Âà∂ÂÆüË°å„Ç∑„Çπ„ÉÜ„É†ÂèñÂæó"""
    global _enforcement_instance

    if _enforcement_instance is None:
        _enforcement_instance = ElderTreeEnforcement()
        await _enforcement_instance.initialize()

    return _enforcement_instance


# ‰æøÂà©„Å™Èñ¢Êï∞
async def enforce_elder_tree():
    """„Ç®„É´„ÉÄ„Éº„ÉÑ„É™„ÉºÂº∑Âà∂ÂÆüË°å"""
    enforcement = await get_enforcement()
    await enforcement.enforce_elder_tree_usage()


def require_elder_registration(agent_type: AgentType = AgentType.SERVANT):
    """„Ç®„É´„ÉÄ„ÉºÁôªÈå≤ÂøÖÈ†à„Éá„Ç≥„É¨„Éº„Çø„Éº"""

    async def async_decorator(func):
        """async_decorator„É°„ÇΩ„ÉÉ„Éâ"""
        enforcement = await get_enforcement()
        return enforcement.require_elder_registration(agent_type)(func)

    # ÂêåÊúüÁâàÂØæÂøú
    def sync_decorator(func):
        """sync_decorator„É°„ÇΩ„ÉÉ„Éâ"""
        @wraps(func)
        def wrapper(*args, **kwargs):
            """wrapper„É°„ÇΩ„ÉÉ„Éâ"""
            # ÈùûÂêåÊúü„Åß„ÅÆÁôªÈå≤„ÉÅ„Çß„ÉÉ„ÇØ„ÇíÂêåÊúüÁöÑ„Å´ÂÆüË°å
            import asyncio

            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                enforcement = loop.run_until_complete(get_enforcement())
                decorated = enforcement.require_elder_registration(agent_type)(func)
                return decorated(*args, **kwargs)
            finally:
                loop.close()

        return wrapper

    return sync_decorator


# „Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂÆüË°å
async def main():
    """„É°„Ç§„É≥ÂÆüË°å"""
    enforcement = await get_enforcement()
    await enforcement.enforce_elder_tree_usage()


if __name__ == "__main__":
    asyncio.run(main())
