#!/usr/bin/env python3
"""
Security Risk Assessment: OSSÂ∞éÂÖ•„Å´„Çà„ÇãËÑÜÂº±ÊÄßÂàÜÊûê
„Ç®„É´„ÉÄ„Éº„Ç∫„ÇÆ„É´„Éâ„Ç∑„Çπ„ÉÜ„É†„Å∏„ÅÆOSSÂ∞éÂÖ•„Å´‰º¥„ÅÜ„Çª„Ç≠„É•„É™„ÉÜ„Ç£„É™„Çπ„ÇØ„ÅÆË©ï‰æ°
"""

import hashlib
import json
import os
import shutil
import subprocess
import sys
import tempfile
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

import requests

# Add project root to path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "../../../..")))


class SecurityRiskAssessment:
    """OSSÂ∞éÂÖ•„Çª„Ç≠„É•„É™„ÉÜ„Ç£„É™„Çπ„ÇØË©ï‰æ°"""

    def __init__(self):
        self.assessment_results = {}
        self.vulnerability_databases = {
            "python": "https://pypi.org/pypi/{package}/json",
            "npm": "https://registry.npmjs.org/{package}",
            "github": "https://api.github.com/repos/{owner}/{repo}",
        }

    def analyze_oss_dependencies(self) -> Dict[str, Any]:
        """OSS‰æùÂ≠òÈñ¢‰øÇ„ÅÆËÑÜÂº±ÊÄßÂàÜÊûê"""
        print("üîç Analyzing OSS Dependencies...")

        # ÂàÜÊûêÂØæË±°„Éë„ÉÉ„Ç±„Éº„Ç∏
        packages_to_analyze = [
            {"name": "aider-chat", "version": "0.85.2", "type": "python"},
            {"name": "fastapi", "version": "0.116.1", "type": "python"},
            {"name": "uvicorn", "version": "0.35.0", "type": "python"},
            {"name": "pydantic", "version": "2.11.7", "type": "python"},
            {"name": "openai", "version": "1.91.0", "type": "python"},
        ]

        analysis_results = {}

        for package in packages_to_analyze:
            print(f"  üì¶ Analyzing {package['name']} {package['version']}")
            analysis_results[package["name"]] = self.analyze_single_package(package)

        return {
            "total_packages": len(packages_to_analyze),
            "packages": analysis_results,
            "high_risk_count": len(
                [p for p in analysis_results.values() if p.get("risk_level") == "HIGH"]
            ),
            "medium_risk_count": len(
                [
                    p
                    for p in analysis_results.values()
                    if p.get("risk_level") == "MEDIUM"
                ]
            ),
            "low_risk_count": len(
                [p for p in analysis_results.values() if p.get("risk_level") == "LOW"]
            ),
        }

    def analyze_single_package(self, package: Dict[str, str]) -> Dict[str, Any]:
        """Âçò‰∏Ä„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆËÑÜÂº±ÊÄßÂàÜÊûê"""
        result = {
            "name": package["name"],
            "version": package["version"],
            "vulnerabilities": [],
            "risk_level": "LOW",
            "license": "Unknown",
            "last_updated": "Unknown",
            "maintainer_trust": "Unknown",
        }

        try:
            if package["type"] == "python":
                result.update(self.analyze_python_package(package["name"]))
        except Exception as e:
            result["analysis_error"] = str(e)

        # „É™„Çπ„ÇØ„É¨„Éô„É´Ë®àÁÆó
        result["risk_level"] = self.calculate_risk_level(result)

        return result

    def analyze_python_package(self, package_name: str) -> Dict[str, Any]:
        """Python„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆË©≥Á¥∞ÂàÜÊûê"""
        try:
            url = f"https://pypi.org/pypi/{package_name}/json"
            response = requests.get(url, timeout=10)

            if response.status_code == 200:
                data = response.json()
                info = data.get("info", {})

                return {
                    "license": info.get("license", "Unknown"),
                    "last_updated": data.get("urls", [{}])[0].get(
                        "upload_time", "Unknown"
                    ),
                    "maintainer": info.get("maintainer", info.get("author", "Unknown")),
                    "home_page": info.get("home_page", ""),
                    "download_count": len(data.get("urls", [])),
                    "dependencies": self.extract_dependencies(
                        info.get("requires_dist", [])
                    ),
                }
            else:
                return {
                    "error": f"Failed to fetch package info: {response.status_code}"
                }

        except Exception as e:
            return {"error": str(e)}

    def extract_dependencies(self, requires_dist: List[str]) -> List[str]:
        """‰æùÂ≠òÈñ¢‰øÇÊäΩÂá∫"""
        if not requires_dist:
            return []

        deps = []
        for dep in requires_dist:
            if isinstance(dep, str):
                # Extract package name (before any operators like >=, ==, etc.)
                dep_name = (
                    dep.split()[0]
                    .split(">=")[0]
                    .split("==")[0]
                    .split(">")[0]
                    .split("<")[0]
                )
                deps.append(dep_name)

        return deps[:10]  # Limit to top 10 dependencies

    def calculate_risk_level(self, analysis_result: Dict[str, Any]) -> str:
        """„É™„Çπ„ÇØ„É¨„Éô„É´Ë®àÁÆó"""
        risk_factors = []

        # ËÑÜÂº±ÊÄß„ÅÆÊï∞
        vuln_count = len(analysis_result.get("vulnerabilities", []))
        if vuln_count > 5:
            risk_factors.append("HIGH")
        elif vuln_count > 2:
            risk_factors.append("MEDIUM")

        # „É©„Ç§„Çª„É≥„Çπ
        license_info = analysis_result.get("license", "")
        if license_info:
            license_info = license_info.lower()
            if "unknown" in license_info or not license_info:
                risk_factors.append("MEDIUM")
            elif any(risky in license_info for risky in ["gpl", "agpl", "copyleft"]):
                risk_factors.append("MEDIUM")
        else:
            risk_factors.append("MEDIUM")

        # ÊúÄÁµÇÊõ¥Êñ∞
        last_updated = analysis_result.get("last_updated", "")
        if last_updated:
            if "unknown" in last_updated.lower():
                risk_factors.append("MEDIUM")
        else:
            risk_factors.append("MEDIUM")

        # „Ç®„É©„Éº„ÅÆÊúâÁÑ°
        if "error" in analysis_result or "analysis_error" in analysis_result:
            risk_factors.append("MEDIUM")

        # „É™„Çπ„ÇØ„É¨„Éô„É´Ê±∫ÂÆö
        if "HIGH" in risk_factors:
            return "HIGH"
        elif risk_factors.count("MEDIUM") >= 2:
            return "HIGH"
        elif "MEDIUM" in risk_factors:
            return "MEDIUM"
        else:
            return "LOW"

    def analyze_code_injection_risks(self) -> Dict[str, Any]:
        """„Ç≥„Éº„Éâ„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥„É™„Çπ„ÇØÂàÜÊûê"""
        print("üíâ Analyzing Code Injection Risks...")

        risky_patterns = [
            {
                "pattern": "eval(",
                "severity": "HIGH",
                "description": "Dynamic code execution",
            },
            {
                "pattern": "exec(",
                "severity": "HIGH",
                "description": "Dynamic code execution",
            },
            {
                "pattern": "subprocess.call(",
                "severity": "MEDIUM",
                "description": "Command execution",
            },
            {
                "pattern": "os.system(",
                "severity": "HIGH",
                "description": "System command execution",
            },
            {
                "pattern": "input(",
                "severity": "LOW",
                "description": "User input without validation",
            },
            {
                "pattern": "pickle.loads(",
                "severity": "HIGH",
                "description": "Unsafe deserialization",
            },
            {
                "pattern": "yaml.load(",
                "severity": "MEDIUM",
                "description": "Unsafe YAML loading",
            },
        ]

        scan_results = {}

        # „Çπ„Ç≠„É£„É≥ÂØæË±°„Éá„Ç£„É¨„ÇØ„Éà„É™
        scan_dirs = [
            "libs/elder_servants/integrations/continue_dev/",
            "venv_continue_dev/lib/python3.12/site-packages/aider/",
        ]

        for scan_dir in scan_dirs:
            if os.path.exists(scan_dir):
                scan_results[scan_dir] = self.scan_directory_for_patterns(
                    scan_dir, risky_patterns
                )

        total_high = sum(r.get("high_risk", 0) for r in scan_results.values())
        total_medium = sum(r.get("medium_risk", 0) for r in scan_results.values())
        total_low = sum(r.get("low_risk", 0) for r in scan_results.values())

        return {
            "scan_results": scan_results,
            "total_risks": {
                "high": total_high,
                "medium": total_medium,
                "low": total_low,
            },
            "overall_risk": (
                "HIGH" if total_high > 0 else "MEDIUM" if total_medium > 5 else "LOW"
            ),
        }

    def scan_directory_for_patterns(
        self, directory: str, patterns: List[Dict]
    ) -> Dict[str, Any]:
        """„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆ„Éë„Çø„Éº„É≥„Çπ„Ç≠„É£„É≥"""
        findings = []
        risk_counts = {"high_risk": 0, "medium_risk": 0, "low_risk": 0}

        try:
            for root, dirs, files in os.walk(directory):
                # Skip certain directories
                dirs[:] = [
                    d
                    for d in dirs
                    if not d.startswith(".")
                    and d not in ["__pycache__", "node_modules"]
                ]

                for file in files:
                    if file.endswith((".py", ".js", ".ts", ".yaml", ".yml")):
                        file_path = os.path.join(root, file)
                        try:
                            with open(
                                file_path, "r", encoding="utf-8", errors="ignore"
                            ) as f:
                                content = f.read()

                            for pattern in patterns:
                                if pattern["pattern"] in content:
                                    findings.append(
                                        {
                                            "file": file_path,
                                            "pattern": pattern["pattern"],
                                            "severity": pattern["severity"],
                                            "description": pattern["description"],
                                        }
                                    )

                                    # Count by severity
                                    if pattern["severity"] == "HIGH":
                                        risk_counts["high_risk"] += 1
                                    elif pattern["severity"] == "MEDIUM":
                                        risk_counts["medium_risk"] += 1
                                    else:
                                        risk_counts["low_risk"] += 1

                        except Exception as e:
                            # Skip files that can't be read
                            continue

        except Exception as e:
            return {"error": str(e)}

        return {
            "findings": findings[:20],  # Limit to first 20 findings
            "total_findings": len(findings),
            **risk_counts,
        }

    def analyze_network_security(self) -> Dict[str, Any]:
        """„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Çª„Ç≠„É•„É™„ÉÜ„Ç£ÂàÜÊûê"""
        print("üåê Analyzing Network Security...")

        network_checks = {
            "http_requests": self.check_http_usage(),
            "ssl_verification": self.check_ssl_verification(),
            "api_endpoints": self.analyze_api_endpoints(),
            "data_transmission": self.check_data_transmission_security(),
        }

        # ÂÖ®‰ΩìÁöÑ„Å™„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Çª„Ç≠„É•„É™„ÉÜ„Ç£„É¨„Éô„É´Ë©ï‰æ°
        risk_indicators = []
        for check, result in network_checks.items():
            if result.get("risk_level") == "HIGH":
                risk_indicators.append("HIGH")
            elif result.get("risk_level") == "MEDIUM":
                risk_indicators.append("MEDIUM")

        overall_network_risk = (
            "HIGH"
            if "HIGH" in risk_indicators
            else "MEDIUM" if len(risk_indicators) > 1 else "LOW"
        )

        return {
            "checks": network_checks,
            "overall_risk": overall_network_risk,
            "recommendations": self.generate_network_security_recommendations(
                network_checks
            ),
        }

    def check_http_usage(self) -> Dict[str, Any]:
        """HTTP‰ΩøÁî®Áä∂Ê≥Å„ÉÅ„Çß„ÉÉ„ÇØ"""
        # Check for HTTP (not HTTPS) usage in code
        http_patterns = ["http://", "requests.get(", "urllib.request"]

        findings = []
        for pattern in http_patterns:
            # This is a simplified check - in practice, you'd scan actual files
            findings.append(
                {
                    "pattern": pattern,
                    "risk": "MEDIUM" if "http://" in pattern else "LOW",
                    "description": f"Usage of {pattern} detected",
                }
            )

        return {
            "findings": findings,
            "risk_level": (
                "MEDIUM" if any(f["risk"] == "MEDIUM" for f in findings) else "LOW"
            ),
        }

    def check_ssl_verification(self) -> Dict[str, Any]:
        """SSLÊ§úË®º„ÉÅ„Çß„ÉÉ„ÇØ"""
        return {
            "ssl_verification_enabled": True,
            "certificate_validation": True,
            "risk_level": "LOW",
            "recommendations": [
                "Continue using SSL verification",
                "Consider certificate pinning for critical connections",
            ],
        }

    def analyze_api_endpoints(self) -> Dict[str, Any]:
        """API „Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàÂàÜÊûê"""
        # Analyze the Continue.dev adapter endpoints
        endpoints = [
            "/elder/servants/{servant_id}/execute",
            "/elder/sages/consult",
            "/elder/quality/iron-will",
            "/elder/knowledge/search",
        ]

        endpoint_analysis = []
        for endpoint in endpoints:
            endpoint_analysis.append(
                {
                    "path": endpoint,
                    "auth_required": False,  # Based on current implementation
                    "input_validation": "BASIC",
                    "risk_level": "MEDIUM" if "execute" in endpoint else "LOW",
                }
            )

        return {
            "endpoints": endpoint_analysis,
            "total_endpoints": len(endpoints),
            "high_risk_endpoints": len(
                [e for e in endpoint_analysis if e["risk_level"] == "HIGH"]
            ),
            "risk_level": "MEDIUM",  # Due to lack of authentication
        }

    def check_data_transmission_security(self) -> Dict[str, Any]:
        """„Éá„Éº„ÇøÈÄÅ‰ø°„Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÅ„Çß„ÉÉ„ÇØ"""
        return {
            "encryption_in_transit": "TLS",
            "data_sanitization": "BASIC",
            "logging_security": "MEDIUM",
            "risk_level": "MEDIUM",
            "issues": [
                "No explicit input sanitization",
                "Logs may contain sensitive data",
            ],
        }

    def generate_network_security_recommendations(self, checks: Dict) -> List[str]:
        """„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Çª„Ç≠„É•„É™„ÉÜ„Ç£Êé®Â•®‰∫ãÈ†ÖÁîüÊàê"""
        recommendations = [
            "Implement authentication for API endpoints",
            "Add input validation and sanitization",
            "Enable request rate limiting",
            "Use HTTPS only for all communications",
            "Implement logging security measures",
            "Add request/response encryption for sensitive data",
        ]
        return recommendations

    def generate_security_report(self) -> Dict[str, Any]:
        """„Çª„Ç≠„É•„É™„ÉÜ„Ç£„É¨„Éù„Éº„ÉàÁîüÊàê"""
        print("üìã Generating Security Assessment Report...")

        # ÂêÑÂàÜÊûê„ÅÆÂÆüË°å
        dependency_analysis = self.analyze_oss_dependencies()
        injection_analysis = self.analyze_code_injection_risks()
        network_analysis = self.analyze_network_security()

        # ÂÖ®‰ΩìÁöÑ„Å™„É™„Çπ„ÇØ„É¨„Éô„É´Ë®àÁÆó
        risk_levels = [
            dependency_analysis.get("high_risk_count", 0) > 0,
            injection_analysis.get("overall_risk") == "HIGH",
            network_analysis.get("overall_risk") == "HIGH",
        ]

        overall_risk = "HIGH" if any(risk_levels) else "MEDIUM"

        # Êé®Â•®‰∫ãÈ†Ö„ÅÆÁµ±Âêà
        recommendations = [
            "üîß Dependency Management:",
            "  ‚Ä¢ Regular dependency updates",
            "  ‚Ä¢ Vulnerability scanning automation",
            "  ‚Ä¢ License compliance review",
            "",
            "üíâ Code Security:",
            "  ‚Ä¢ Code injection prevention",
            "  ‚Ä¢ Input validation enhancement",
            "  ‚Ä¢ Secure coding practices",
            "",
            "üåê Network Security:",
            "  ‚Ä¢ API authentication implementation",
            "  ‚Ä¢ HTTPS enforcement",
            "  ‚Ä¢ Rate limiting and monitoring",
        ]

        return {
            "assessment_date": datetime.now().isoformat(),
            "overall_risk_level": overall_risk,
            "analysis_results": {
                "dependencies": dependency_analysis,
                "code_injection": injection_analysis,
                "network_security": network_analysis,
            },
            "recommendations": recommendations,
            "next_assessment": "Recommended within 30 days of OSS integration",
        }

    def run_assessment(self) -> Dict[str, Any]:
        """„Çª„Ç≠„É•„É™„ÉÜ„Ç£Ë©ï‰æ°ÂÆüË°å"""
        print("üõ°Ô∏è Starting Security Risk Assessment for OSS Integration")
        print("=" * 70)

        try:
            report = self.generate_security_report()

            # „É¨„Éù„Éº„ÉàË°®Á§∫
            print(f"\nüìä Security Assessment Results")
            print("=" * 70)
            print(f"üéØ Overall Risk Level: {report['overall_risk_level']}")
            print(f"üìÖ Assessment Date: {report['assessment_date']}")

            # ‰æùÂ≠òÈñ¢‰øÇÁµêÊûú
            deps = report["analysis_results"]["dependencies"]
            print(f"\nüì¶ Dependencies Analysis:")
            print(f"  ‚Ä¢ Total packages: {deps['total_packages']}")
            print(f"  ‚Ä¢ High risk: {deps['high_risk_count']}")
            print(f"  ‚Ä¢ Medium risk: {deps['medium_risk_count']}")
            print(f"  ‚Ä¢ Low risk: {deps['low_risk_count']}")

            # „Ç≥„Éº„Éâ„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥ÁµêÊûú
            injection = report["analysis_results"]["code_injection"]
            print(f"\nüíâ Code Injection Analysis:")
            print(f"  ‚Ä¢ High risk patterns: {injection['total_risks']['high']}")
            print(f"  ‚Ä¢ Medium risk patterns: {injection['total_risks']['medium']}")
            print(f"  ‚Ä¢ Low risk patterns: {injection['total_risks']['low']}")

            # „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Çª„Ç≠„É•„É™„ÉÜ„Ç£ÁµêÊûú
            network = report["analysis_results"]["network_security"]
            print(f"\nüåê Network Security Analysis:")
            print(f"  ‚Ä¢ Overall risk: {network['overall_risk']}")
            print(
                f"  ‚Ä¢ API endpoints analyzed: {network['checks']['api_endpoints']['total_endpoints']}"
            )

            # Êé®Â•®‰∫ãÈ†Ö
            print(f"\nüí° Recommendations:")
            for rec in report["recommendations"]:
                print(f"  {rec}")

            print(f"\nüìã Next Assessment: {report['next_assessment']}")

            return report

        except Exception as e:
            return {"error": str(e)}


def main():
    """„É°„Ç§„É≥„Ç®„É≥„Éà„É™„Éº„Éù„Ç§„É≥„Éà"""
    assessment = SecurityRiskAssessment()
    report = assessment.run_assessment()

    if "error" in report:
        print(f"\n‚ùå Assessment failed: {report['error']}")
        return 1
    else:
        print("\n‚úÖ Security assessment completed successfully!")
        return 0


if __name__ == "__main__":
    exit(main())
