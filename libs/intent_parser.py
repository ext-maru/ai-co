#!/usr/bin/env python3
"""
Intent Parser v0.1
Ëá™ÁÑ∂Ë®ÄË™û„Åã„Çâ„Ç≥„Éû„É≥„Éâ„Å∏„ÅÆÂ§âÊèõ„Ç∑„Çπ„ÉÜ„É†

üí≠ nWo Natural Language Parser Implementation
Convert maruÊßò's natural language to structured commands
"""

import asyncio
import json
import re
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any, Union
from dataclasses import dataclass, asdict
from enum import Enum
from pathlib import Path
import logging

from libs.mind_reading_core import IntentResult, IntentType


class CommandType(Enum):
    """„Ç≥„Éû„É≥„Éâ„Çø„Ç§„Éó"""
    CREATE = "create"          # ‰ΩúÊàêÁ≥ª„Ç≥„Éû„É≥„Éâ
    UPDATE = "update"          # Êõ¥Êñ∞Á≥ª„Ç≥„Éû„É≥„Éâ
    DELETE = "delete"          # ÂâäÈô§Á≥ª„Ç≥„Éû„É≥„Éâ
    READ = "read"              # Ë™≠„ÅøÂèñ„ÇäÁ≥ª„Ç≥„Éû„É≥„Éâ
    EXECUTE = "execute"        # ÂÆüË°åÁ≥ª„Ç≥„Éû„É≥„Éâ
    ANALYZE = "analyze"        # ÂàÜÊûêÁ≥ª„Ç≥„Éû„É≥„Éâ
    CONFIGURE = "configure"    # Ë®≠ÂÆöÁ≥ª„Ç≥„Éû„É≥„Éâ
    DEPLOY = "deploy"          # „Éá„Éó„É≠„Ç§Á≥ª„Ç≥„Éû„É≥„Éâ
    TEST = "test"              # „ÉÜ„Çπ„ÉàÁ≥ª„Ç≥„Éû„É≥„Éâ
    OPTIMIZE = "optimize"      # ÊúÄÈÅ©ÂåñÁ≥ª„Ç≥„Éû„É≥„Éâ


class ParameterType(Enum):
    """„Éë„É©„É°„Éº„Çø„Çø„Ç§„Éó"""
    STRING = "string"
    NUMBER = "number"
    BOOLEAN = "boolean"
    LIST = "list"
    DICT = "dict"
    FILE_PATH = "file_path"
    URL = "url"
    DATE = "date"
    CODE = "code"
    CONFIG = "config"


@dataclass
class ParsedCommand:
    """„Éë„Éº„Çπ„Åï„Çå„Åü„Ç≥„Éû„É≥„Éâ"""
    command_type: CommandType
    action: str
    target: str
    parameters: Dict[str, Any]
    modifiers: List[str]
    context: Dict[str, Any]
    confidence: float
    original_text: str
    timestamp: str


@dataclass
class CommandTemplate:
    """„Ç≥„Éû„É≥„Éâ„ÉÜ„É≥„Éó„É¨„Éº„Éà"""
    template_id: str
    command_type: CommandType
    pattern: str
    required_params: List[str]
    optional_params: List[str]
    examples: List[str]
    description: str


class IntentParser:
    """Intent Parser - Ëá™ÁÑ∂Ë®ÄË™û„Çí„Ç≥„Éû„É≥„Éâ„Å´Â§âÊèõ"""

    def __init__(self, template_dir: str = "data/command_templates"):
        self.template_dir = Path(template_dir)
        self.template_dir.mkdir(parents=True, exist_ok=True)

        self.logger = self._setup_logger()

        # „ÉÜ„É≥„Éó„É¨„Éº„ÉàÁÆ°ÁêÜ
        self.templates_file = self.template_dir / "command_templates.json"
        self.parse_history_file = self.template_dir / "parse_history.json"

        # „É°„É¢„É™ÂÜÖ„Éá„Éº„Çø
        self.command_templates: List[CommandTemplate] = []
        self.parse_cache: Dict[str, ParsedCommand] = {}

        # ÂàùÊúüÂåñ
        self._load_default_templates()
        self._load_custom_templates()

        self.logger.info("üí≠ Intent Parser v0.1 initialized")

    def _setup_logger(self) -> logging.Logger:
        """„É≠„Ç¨„ÉºË®≠ÂÆö"""
        logger = logging.getLogger("intent_parser")
        logger.setLevel(logging.INFO)

        if not logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                "%(asctime)s - Intent Parser - %(levelname)s - %(message)s"
            )
            handler.setFormatter(formatter)
            logger.addHandler(handler)

        return logger

    def _load_default_templates(self):
        """„Éá„Éï„Ç©„É´„Éà„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÅÆË™≠„ÅøËæº„Åø"""
        self.command_templates = [
            # CREATEÁ≥ª
            CommandTemplate(
                template_id="create_feature",
                command_type=CommandType.CREATE,
                pattern=r"(.+?)„Çí(ÂÆüË£Ö|‰ΩúÊàê|‰Ωú„Å£„Å¶|ÈñãÁô∫|build|create)",
                required_params=["feature_name"],
                optional_params=["technology", "priority"],
                examples=["OAuthË™çË®º„ÇíÂÆüË£Ö", "API„Çí‰ΩúÊàê„Åó„Å¶"],
                description="Êñ∞Ê©üËÉΩ„ÅÆ‰ΩúÊàê"
            ),
            CommandTemplate(
                template_id="create_file",
                command_type=CommandType.CREATE,
                pattern=r"(.+?)(„Éï„Ç°„Ç§„É´|file)„Çí(‰ΩúÊàê|‰Ωú„Å£„Å¶|create)",
                required_params=["file_name"],
                optional_params=["content", "directory"],
                examples=["config.json„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê", "README„Éï„Ç°„Ç§„É´„Çí‰Ωú„Å£„Å¶"],
                description="„Éï„Ç°„Ç§„É´„ÅÆ‰ΩúÊàê"
            ),

            # UPDATEÁ≥ª
            CommandTemplate(
                template_id="update_code",
                command_type=CommandType.UPDATE,
                pattern=r"(.+?)„Çí(‰øÆÊ≠£|Êõ¥Êñ∞|Â§âÊõ¥|update|fix)",
                required_params=["target"],
                optional_params=["change_type", "reason"],
                examples=["„Éê„Ç∞„Çí‰øÆÊ≠£", "Ë®≠ÂÆö„ÇíÊõ¥Êñ∞"],
                description="„Ç≥„Éº„Éâ„ÅÆÊõ¥Êñ∞"
            ),

            # DELETEÁ≥ª
            CommandTemplate(
                template_id="delete_resource",
                command_type=CommandType.DELETE,
                pattern=r"(.+?)„Çí(ÂâäÈô§|Ê∂à„Åó„Å¶|remove|delete)",
                required_params=["target"],
                optional_params=["confirm", "backup"],
                examples=["Âè§„ÅÑ„Éï„Ç°„Ç§„É´„ÇíÂâäÈô§", "„Ç≠„É£„ÉÉ„Ç∑„É•„ÇíÊ∂à„Åó„Å¶"],
                description="„É™„ÇΩ„Éº„Çπ„ÅÆÂâäÈô§"
            ),

            # EXECUTEÁ≥ª
            CommandTemplate(
                template_id="execute_command",
                command_type=CommandType.EXECUTE,
                pattern=r"(.+?)„Çí(ÂÆüË°å|Âãï„Åã„Åó„Å¶|run|execute)",
                required_params=["command"],
                optional_params=["args", "env"],
                examples=["„ÉÜ„Çπ„Éà„ÇíÂÆüË°å", "„Éì„É´„Éâ„ÇíÂãï„Åã„Åó„Å¶"],
                description="„Ç≥„Éû„É≥„Éâ„ÅÆÂÆüË°å"
            ),

            # TESTÁ≥ª
            CommandTemplate(
                template_id="run_test",
                command_type=CommandType.TEST,
                pattern=r"(.+?)„Çí?(„ÉÜ„Çπ„Éà|test)",
                required_params=["test_target"],
                optional_params=["test_type", "coverage"],
                examples=["API„Çí„ÉÜ„Çπ„Éà", "ÂÖ®‰Ωì„Çí„ÉÜ„Çπ„Éà"],
                description="„ÉÜ„Çπ„Éà„ÅÆÂÆüË°å"
            ),

            # OPTIMIZEÁ≥ª
            CommandTemplate(
                template_id="optimize_performance",
                command_type=CommandType.OPTIMIZE,
                pattern=r"(.+?)„Çí(ÊúÄÈÅ©Âåñ|È´òÈÄüÂåñ|optimize)",
                required_params=["optimization_target"],
                optional_params=["metrics", "constraints"],
                examples=["DB„ÇØ„Ç®„É™„ÇíÊúÄÈÅ©Âåñ", "„É¨„É≥„ÉÄ„É™„É≥„Ç∞„ÇíÈ´òÈÄüÂåñ"],
                description="„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ"
            )
        ]

    def _load_custom_templates(self):
        """„Ç´„Çπ„Çø„É†„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÅÆË™≠„ÅøËæº„Åø"""
        if self.templates_file.exists():
            try:
                with open(self.templates_file, 'r') as f:
                    data = json.load(f)
                    custom_templates = [
                        CommandTemplate(**t) for t in data
                    ]
                    self.command_templates.extend(custom_templates)
                    self.logger.info(f"üìã Loaded {len(custom_templates)} custom templates")
            except Exception as e:
                self.logger.error(f"Template loading error: {e}")

    async def parse_intent(self, intent_result: IntentResult, original_text: str) -> ParsedCommand:
        """
        IntentResult„Åã„ÇâÊßãÈÄ†Âåñ„Ç≥„Éû„É≥„Éâ„Å∏„ÅÆÂ§âÊèõ

        Args:
            intent_result: Mind Reading Core„ÅÆÁµêÊûú
            original_text: ÂÖÉ„ÅÆÂÖ•Âäõ„ÉÜ„Ç≠„Çπ„Éà

        Returns:
            ParsedCommand: ÊßãÈÄ†Âåñ„Åï„Çå„Åü„Ç≥„Éû„É≥„Éâ
        """
        self.logger.info(f"üí≠ Parsing intent: {intent_result.intent_type.value}")

        # „Ç≠„É£„ÉÉ„Ç∑„É•„ÉÅ„Çß„ÉÉ„ÇØ
        cache_key = f"{intent_result.intent_type.value}:{original_text}"
        if cache_key in self.parse_cache:
            return self.parse_cache[cache_key]

        # IntentType„Å´Âü∫„Å•„Åè„Ç≥„Éû„É≥„Éâ„Çø„Ç§„Éó„Éû„ÉÉ„Éî„É≥„Ç∞
        command_type = self._map_intent_to_command(intent_result.intent_type)

        # „ÉÜ„Ç≠„Çπ„Éà„Åã„Çâ„Ç¢„ÇØ„Ç∑„Éß„É≥„Å®„Çø„Éº„Ç≤„ÉÉ„Éà„ÇíÊäΩÂá∫
        action, target = self._extract_action_target(original_text, intent_result)

        # „Éë„É©„É°„Éº„ÇøÊäΩÂá∫
        parameters = self._extract_command_parameters(
            original_text,
            intent_result,
            command_type
        )

        # „É¢„Éá„Ç£„Éï„Ç°„Ç§„Ç¢ÊäΩÂá∫ÔºàÁ∑äÊÄ•„ÄÅÈáçË¶Å„Å™„Å©Ôºâ
        modifiers = self._extract_modifiers(original_text, intent_result)

        # „Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÊÉÖÂ†±
        context = {
            "intent_type": intent_result.intent_type.value,
            "confidence_level": intent_result.confidence_level.value,
            "priority": intent_result.priority,
            "urgency": intent_result.urgency,
            "keywords": intent_result.extracted_keywords
        }

        parsed_command = ParsedCommand(
            command_type=command_type,
            action=action,
            target=target,
            parameters=parameters,
            modifiers=modifiers,
            context=context,
            confidence=intent_result.confidence,
            original_text=original_text,
            timestamp=datetime.now().isoformat()
        )

        # „Ç≠„É£„ÉÉ„Ç∑„É•„Å´‰øùÂ≠ò
        self.parse_cache[cache_key] = parsed_command

        # Â±•Ê≠¥‰øùÂ≠ò
        await self._save_parse_history(parsed_command)

        self.logger.info(f"‚úÖ Parsed command: {command_type.value} {action} {target}")

        return parsed_command

    def _map_intent_to_command(self, intent_type: IntentType) -> CommandType:
        """IntentType„ÇíCommandType„Å´„Éû„ÉÉ„Éî„É≥„Ç∞"""
        mapping = {
            IntentType.DEVELOPMENT: CommandType.CREATE,
            IntentType.FEATURE_REQUEST: CommandType.CREATE,
            IntentType.BUG_FIX: CommandType.UPDATE,
            IntentType.OPTIMIZATION: CommandType.OPTIMIZE,
            IntentType.RESEARCH: CommandType.ANALYZE,
            IntentType.STRATEGY: CommandType.CONFIGURE,
            IntentType.DIRECTIVE: CommandType.EXECUTE,
            IntentType.QUESTION: CommandType.READ,
            IntentType.PRAISE: CommandType.READ,
            IntentType.VISION: CommandType.ANALYZE
        }

        return mapping.get(intent_type, CommandType.EXECUTE)

    def _extract_action_target(self, text: str, intent_result: IntentResult) -> Tuple[str, str]:
        """„Ç¢„ÇØ„Ç∑„Éß„É≥„Å®„Çø„Éº„Ç≤„ÉÉ„Éà„ÅÆÊäΩÂá∫"""
        # „ÉÜ„É≥„Éó„É¨„Éº„Éà„Éû„ÉÉ„ÉÅ„É≥„Ç∞
        for template in self.command_templates:
            match = re.search(template.pattern, text)
            if match:
                groups = match.groups()
                if len(groups) >= 1:
                    target = groups[0]
                    action = template.template_id.split('_')[0]  # create, update, etc.
                    return action, target

        # „Éá„Éï„Ç©„É´„ÉàÂá¶ÁêÜ
        keywords = intent_result.extracted_keywords

        # „Ç¢„ÇØ„Ç∑„Éß„É≥ÂÄôË£ú
        action_keywords = ["ÂÆüË£Ö", "‰ΩúÊàê", "‰øÆÊ≠£", "ÂâäÈô§", "ÂÆüË°å", "„ÉÜ„Çπ„Éà", "ÊúÄÈÅ©Âåñ"]
        action = "execute"  # „Éá„Éï„Ç©„É´„Éà

        for keyword in keywords:
            for action_keyword in action_keywords:
                if action_keyword in keyword:
                    action = self._normalize_action(action_keyword)
                    break

        # „Çø„Éº„Ç≤„ÉÉ„ÉàÂÄôË£úÔºàÊúÄ„ÇÇÈï∑„ÅÑ„Ç≠„Éº„ÉØ„Éº„Éâ„Çí„Çø„Éº„Ç≤„ÉÉ„Éà„Å®„Åô„ÇãÔºâ
        target = max(keywords, key=len) if keywords else "unknown"

        return action, target

    def _normalize_action(self, action_keyword: str) -> str:
        """„Ç¢„ÇØ„Ç∑„Éß„É≥„Ç≠„Éº„ÉØ„Éº„Éâ„ÅÆÊ≠£Ë¶èÂåñ"""
        action_map = {
            "ÂÆüË£Ö": "create",
            "‰ΩúÊàê": "create",
            "‰Ωú„Å£„Å¶": "create",
            "‰øÆÊ≠£": "update",
            "Êõ¥Êñ∞": "update",
            "ÂâäÈô§": "delete",
            "Ê∂à„Åó„Å¶": "delete",
            "ÂÆüË°å": "execute",
            "Âãï„Åã„Åó„Å¶": "execute",
            "„ÉÜ„Çπ„Éà": "test",
            "ÊúÄÈÅ©Âåñ": "optimize",
            "È´òÈÄüÂåñ": "optimize"
        }

        return action_map.get(action_keyword, action_keyword)

    def _extract_command_parameters(
        self,
        text: str,
        intent_result: IntentResult,
        command_type: CommandType
    ) -> Dict[str, Any]:
        """„Ç≥„Éû„É≥„Éâ„Éë„É©„É°„Éº„Çø„ÅÆÊäΩÂá∫"""
        parameters = {}

        # IntentResult„ÅÆ„Éë„É©„É°„Éº„Çø„ÇíÂü∫„Å´
        parameters.update(intent_result.parameters)

        # „Ç≥„Éû„É≥„Éâ„Çø„Ç§„ÉóÂà•„ÅÆÁâπÂà•„Å™Âá¶ÁêÜ
        if command_type == CommandType.CREATE:
            # ÊäÄË°ì„Çπ„Çø„ÉÉ„ÇØ
            if "technologies" in parameters and parameters["technologies"]:
                parameters["tech_stack"] = parameters["technologies"]

            # „Éï„Ç°„Ç§„É´„Çø„Ç§„Éó
            if "file_types" in parameters and parameters["file_types"]:
                parameters["output_format"] = parameters["file_types"][0]

        elif command_type == CommandType.UPDATE:
            # ÈáçË¶ÅÂ∫¶
            if "severity" in parameters:
                parameters["importance"] = parameters["severity"]

        elif command_type == CommandType.TEST:
            # „ÉÜ„Çπ„Éà„Çø„Ç§„Éó
            if "unit" in text or "„É¶„Éã„ÉÉ„Éà" in text:
                parameters["test_type"] = "unit"
            elif "integration" in text or "Áµ±Âêà" in text:
                parameters["test_type"] = "integration"
            else:
                parameters["test_type"] = "all"

        elif command_type == CommandType.OPTIMIZE:
            # ÊúÄÈÅ©ÂåñÁõÆÊ®ô
            if "ÈÄüÂ∫¶" in text or "speed" in text:
                parameters["optimization_goal"] = "speed"
            elif "„É°„É¢„É™" in text or "memory" in text:
                parameters["optimization_goal"] = "memory"
            else:
                parameters["optimization_goal"] = "general"

        return parameters

    def _extract_modifiers(self, text: str, intent_result: IntentResult) -> List[str]:
        """„É¢„Éá„Ç£„Éï„Ç°„Ç§„Ç¢„ÅÆÊäΩÂá∫"""
        modifiers = []

        # Á∑äÊÄ•Â∫¶
        if intent_result.urgency in ["urgent", "high"]:
            modifiers.append("urgent")

        # ÂÑ™ÂÖàÂ∫¶
        if intent_result.priority in ["critical", "high"]:
            modifiers.append("high_priority")

        # „Åù„ÅÆ‰ªñ„ÅÆ„É¢„Éá„Ç£„Éï„Ç°„Ç§„Ç¢
        modifier_patterns = {
            "force": ["Âº∑Âà∂", "force", "ÂøÖ„Åö"],
            "dry_run": ["„ÉÜ„Çπ„ÉàÂÆüË°å", "dry-run", "„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥"],
            "verbose": ["Ë©≥Á¥∞", "verbose", "Ë©≥„Åó„Åè"],
            "quiet": ["Èùô„Åã„Å´", "quiet", "„Çµ„Ç§„É¨„É≥„Éà"]
        }

        text_lower = text.lower()
        for modifier, patterns in modifier_patterns.items():
            if any(pattern in text_lower for pattern in patterns):
                modifiers.append(modifier)

        return modifiers

    async def generate_command(self, parsed_command: ParsedCommand) -> str:
        """
        ParsedCommand„Åã„ÇâÂÆüË°åÂèØËÉΩ„Å™„Ç≥„Éû„É≥„ÉâÊñáÂ≠óÂàó„ÇíÁîüÊàê

        Args:
            parsed_command: „Éë„Éº„ÇπÊ∏à„Åø„Ç≥„Éû„É≥„Éâ

        Returns:
            str: ÂÆüË°åÂèØËÉΩ„Å™„Ç≥„Éû„É≥„ÉâÊñáÂ≠óÂàó
        """
        # „Ç≥„Éû„É≥„Éâ„Çø„Ç§„ÉóÂà•„ÅÆÁîüÊàê
        if parsed_command.command_type == CommandType.CREATE:
            return self._generate_create_command(parsed_command)
        elif parsed_command.command_type == CommandType.UPDATE:
            return self._generate_update_command(parsed_command)
        elif parsed_command.command_type == CommandType.DELETE:
            return self._generate_delete_command(parsed_command)
        elif parsed_command.command_type == CommandType.EXECUTE:
            return self._generate_execute_command(parsed_command)
        elif parsed_command.command_type == CommandType.TEST:
            return self._generate_test_command(parsed_command)
        elif parsed_command.command_type == CommandType.OPTIMIZE:
            return self._generate_optimize_command(parsed_command)
        else:
            return f"echo 'Command type {parsed_command.command_type.value} not implemented'"

    def _generate_create_command(self, parsed_command: ParsedCommand) -> str:
        """CREATEÁ≥ª„Ç≥„Éû„É≥„Éâ„ÅÆÁîüÊàê"""
        target = parsed_command.target
        params = parsed_command.parameters

        # Elder FlowÂÆüË°å
        if "elder" in target.lower() or "flow" in target.lower():
            priority = params.get("priority", "medium")
            return f'elder-flow execute "{target}" --priority {priority}'

        # „Éï„Ç°„Ç§„É´‰ΩúÊàê
        if "file" in target or "„Éï„Ç°„Ç§„É´" in target:
            file_name = params.get("file_name", target)
            return f'touch {file_name}'

        # „Éá„Éï„Ç©„É´„ÉàÔºöTDDÈñãÁô∫
        return f'ai-tdd new "{target}" "Implementation of {target}"'

    def _generate_update_command(self, parsed_command: ParsedCommand) -> str:
        """UPDATEÁ≥ª„Ç≥„Éû„É≥„Éâ„ÅÆÁîüÊàê"""
        target = parsed_command.target

        # „Éê„Ç∞‰øÆÊ≠£
        if "bug" in target or "„Éê„Ç∞" in target:
            return f'ai-fix-bug "{target}"'

        # „Éá„Éï„Ç©„É´„ÉàÔºöÁ∑®ÈõÜ
        return f'ai-edit "{target}"'

    def _generate_delete_command(self, parsed_command: ParsedCommand) -> str:
        """DELETEÁ≥ª„Ç≥„Éû„É≥„Éâ„ÅÆÁîüÊàê"""
        target = parsed_command.target
        modifiers = parsed_command.modifiers

        # Âº∑Âà∂„Éï„É©„Ç∞
        force_flag = "-f" if "force" in modifiers else "-i"

        return f'rm {force_flag} {target}'

    def _generate_execute_command(self, parsed_command: ParsedCommand) -> str:
        """EXECUTEÁ≥ª„Ç≥„Éû„É≥„Éâ„ÅÆÁîüÊàê"""
        target = parsed_command.target

        # „Çà„Åè‰Ωø„ÅÜ„Ç≥„Éû„É≥„Éâ„ÅÆ„Éû„ÉÉ„Éî„É≥„Ç∞
        common_commands = {
            "test": "pytest",
            "build": "python setup.py build",
            "deploy": "./deploy.sh",
            "start": "ai-start",
            "stop": "ai-stop"
        }

        for key, command in common_commands.items():
            if key in target.lower():
                return command

        return target

    def _generate_test_command(self, parsed_command: ParsedCommand) -> str:
        """TESTÁ≥ª„Ç≥„Éû„É≥„Éâ„ÅÆÁîüÊàê"""
        target = parsed_command.target
        params = parsed_command.parameters
        test_type = params.get("test_type", "all")

        if test_type == "unit":
            return f'pytest tests/unit/ -v'
        elif test_type == "integration":
            return f'pytest tests/integration/ -v'
        else:
            return f'pytest -v'

    def _generate_optimize_command(self, parsed_command: ParsedCommand) -> str:
        """OPTIMIZEÁ≥ª„Ç≥„Éû„É≥„Éâ„ÅÆÁîüÊàê"""
        target = parsed_command.target
        params = parsed_command.parameters
        goal = params.get("optimization_goal", "general")

        return f'ai-optimize "{target}" --goal {goal}'

    async def _save_parse_history(self, parsed_command: ParsedCommand):
        """„Éë„Éº„ÇπÂ±•Ê≠¥„ÅÆ‰øùÂ≠ò"""
        try:
            history = []
            if self.parse_history_file.exists():
                with open(self.parse_history_file, 'r') as f:
                    history = json.load(f)

            # ParsedCommand„ÇíËæûÊõ∏„Å´Â§âÊèõ
            command_dict = asdict(parsed_command)
            command_dict["command_type"] = parsed_command.command_type.value

            history.append(command_dict)

            # ÊúÄÂ§ß1000‰ª∂„Åæ„Åß‰øùÊåÅ
            if len(history) > 1000:
                history = history[-1000:]

            with open(self.parse_history_file, 'w') as f:
                json.dump(history, f, indent=2, ensure_ascii=False)

        except Exception as e:
            self.logger.error(f"Parse history saving error: {e}")

    def add_custom_template(self, template: CommandTemplate):
        """„Ç´„Çπ„Çø„É†„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÅÆËøΩÂä†"""
        self.command_templates.append(template)
        self._save_templates()

    def _save_templates(self):
        """„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÅÆ‰øùÂ≠ò"""
        try:
            # „Éá„Éï„Ç©„É´„Éà„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÅØÈô§Â§ñ
            custom_templates = [
                t for t in self.command_templates
                if not t.template_id.startswith("create_")
                and not t.template_id.startswith("update_")
                and not t.template_id.startswith("delete_")
                and not t.template_id.startswith("execute_")
                and not t.template_id.startswith("run_")
                and not t.template_id.startswith("optimize_")
            ]

            template_dicts = [asdict(t) for t in custom_templates]

            with open(self.templates_file, 'w') as f:
                json.dump(template_dicts, f, indent=2, ensure_ascii=False)

        except Exception as e:
            self.logger.error(f"Template saving error: {e}")

    def get_command_suggestions(self, partial_text: str) -> List[str]:
        """„Ç≥„Éû„É≥„ÉâÂÄôË£ú„ÅÆÂèñÂæó"""
        suggestions = []

        for template in self.command_templates:
            for example in template.examples:
                if partial_text.lower() in example.lower():
                    suggestions.append(example)

        return suggestions[:5]  # ‰∏ä‰Ωç5ÂÄã„Åæ„Åß


# „Éá„É¢„Å®‰ΩøÁî®‰æã
async def demo_intent_parser():
    """Intent Parser „Éá„É¢"""
    print("üí≠ Intent Parser v0.1 Demo")
    print("=" * 50)

    from libs.mind_reading_core import MindReadingCore

    # ÂàùÊúüÂåñ
    mind_reader = MindReadingCore()
    parser = IntentParser()

    # „ÉÜ„Çπ„Éà„Ç±„Éº„Çπ
    test_cases = [
        "OAuth2.0Ë™çË®º„Ç∑„Çπ„ÉÜ„É†„ÇíÂÆüË£Ö„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
        "„Éê„Ç∞„Çí‰ªä„Åô„Åê‰øÆÊ≠£„Åó„Å¶",
        "ÂÖ®‰Ωì„ÅÆ„ÉÜ„Çπ„Éà„ÇíÂÆüË°å",
        "DB„ÇØ„Ç®„É™„ÇíÊúÄÈÅ©Âåñ„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
        "Âè§„ÅÑ„Ç≠„É£„ÉÉ„Ç∑„É•„Éï„Ç°„Ç§„É´„ÇíÂâäÈô§"
    ]

    for text in test_cases:
        print(f"\nüìù Input: {text}")

        # Mind Reading
        intent_result = await mind_reader.understand_intent(text)
        print(f"üß† Intent: {intent_result.intent_type.value}")

        # Parse to Command
        parsed_command = await parser.parse_intent(intent_result, text)
        print(f"üí≠ Command Type: {parsed_command.command_type.value}")
        print(f"üéØ Action: {parsed_command.action}")
        print(f"üìå Target: {parsed_command.target}")

        # Generate Command
        command = await parser.generate_command(parsed_command)
        print(f"‚ö° Generated Command: {command}")


if __name__ == "__main__":
    asyncio.run(demo_intent_parser())
