#!/usr/bin/env python3
"""
Knights GitHub Integration - é¨å£«å›£ã®GitHubçµ±åˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
Provides GitHub API integration for automated fixes and PR creation
"""

import os
import json
import subprocess
from pathlib import Path
from typing import Dict, List, Any, Optional
from datetime import datetime
from dataclasses import dataclass

@dataclass
class GitHubFixContext:
    """GitHubä¿®æ­£ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ"""
    repo_owner: str
    repo_name: str
    branch: str
    commit_message: str
    pr_title: Optional[str] = None
    pr_body: Optional[str] = None
    labels: List[str] = None

class KnightsGitHubIntegration:
    """é¨å£«å›£GitHubçµ±åˆã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, github_token: Optional[str] = None):
        """åˆæœŸåŒ–"""
        self.github_token = github_token or os.environ.get('GITHUB_TOKEN')
        self.git_configured = False
        
    def configure_git(self, name: str = "Incident Knights Bot", 
                      email: str = "knights@ai-company.example"):
        """Gitè¨­å®š"""
        subprocess.run(['git', 'config', 'user.name', name], check=True)
        subprocess.run(['git', 'config', 'user.email', email], check=True)
        self.git_configured = True
        
    def create_fix_branch(self, branch_name: str) -> bool:
        """ä¿®æ­£ç”¨ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆ"""
        try:
            # Create and checkout new branch
            subprocess.run(['git', 'checkout', '-b', branch_name], check=True)
            return True
        except subprocess.CalledProcessError:
            print(f"Failed to create branch: {branch_name}")
            return False
    
    def commit_fixes(self, files: List[str], context: GitHubFixContext) -> bool:
        """ä¿®æ­£ã‚’ã‚³ãƒŸãƒƒãƒˆ"""
        if not self.git_configured:
            self.configure_git()
        
        try:
            # Stage files
            subprocess.run(['git', 'add'] + files, check=True)
            
            # Create commit
            commit_message = self._format_commit_message(context)
            subprocess.run(['git', 'commit', '-m', commit_message], check=True)
            
            return True
        except subprocess.CalledProcessError as e:
            print(f"Failed to commit: {e}")
            return False
    
    def push_branch(self, branch_name: str, force: bool = False) -> bool:
        """ãƒ–ãƒ©ãƒ³ãƒã‚’ãƒ—ãƒƒã‚·ãƒ¥"""
        try:
            cmd = ['git', 'push', 'origin', branch_name]
            if force:
                cmd.insert(2, '-f')
            
            subprocess.run(cmd, check=True)
            return True
        except subprocess.CalledProcessError:
            print(f"Failed to push branch: {branch_name}")
            return False
    
    def create_pull_request(self, context: GitHubFixContext) -> Optional[Dict[str, Any]]:
        """ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä½œæˆï¼ˆGitHub CLIä½¿ç”¨ï¼‰"""
        try:
            cmd = [
                'gh', 'pr', 'create',
                '--title', context.pr_title,
                '--body', context.pr_body,
                '--base', 'main',
                '--head', context.branch
            ]
            
            if context.labels:
                cmd.extend(['--label', ','.join(context.labels)])
            
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            
            # Extract PR URL from output
            pr_url = result.stdout.strip()
            
            return {
                'url': pr_url,
                'created_at': datetime.now().isoformat()
            }
            
        except subprocess.CalledProcessError as e:
            print(f"Failed to create PR: {e}")
            return None
    
    def _format_commit_message(self, context: GitHubFixContext) -> str:
        """ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        return f"""ğŸ›¡ï¸ [Knights] {context.commit_message}

This commit was automatically generated by the Incident Knights system.
The Knights have detected and fixed issues to maintain code quality.

ğŸ¤– Generated by Incident Knights
Co-authored-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"""
    
    def analyze_fix_impact(self, files_modified: List[str]) -> Dict[str, Any]:
        """ä¿®æ­£ã®å½±éŸ¿ã‚’åˆ†æ"""
        impact = {
            'files_modified': len(files_modified),
            'lines_changed': 0,
            'test_files_affected': [],
            'core_files_affected': [],
            'risk_level': 'low'
        }
        
        for file_path in files_modified:
            path = Path(file_path)
            
            # Count lines changed
            try:
                result = subprocess.run(
                    ['git', 'diff', '--cached', '--numstat', file_path],
                    capture_output=True,
                    text=True
                )
                if result.stdout:
                    added, removed, _ = result.stdout.strip().split('\t')
                    impact['lines_changed'] += int(added) + int(removed)
            except:
                pass
            
            # Categorize files
            if 'test' in path.parts:
                impact['test_files_affected'].append(str(path))
            elif path.name in ['base_worker.py', 'task_worker.py', 'env_config.py']:
                impact['core_files_affected'].append(str(path))
        
        # Assess risk level
        if impact['core_files_affected']:
            impact['risk_level'] = 'high'
        elif impact['lines_changed'] > 100:
            impact['risk_level'] = 'medium'
        
        return impact
    
    def generate_pr_description(self, fix_summary: Dict[str, Any], 
                               impact: Dict[str, Any]) -> str:
        """PRèª¬æ˜æ–‡ã‚’ç”Ÿæˆ"""
        return f"""## ğŸ›¡ï¸ Incident Knights Auto-Fix Report

The Knights have detected and automatically fixed issues in your codebase.

### ğŸ“Š Fix Summary
- **Total Issues Fixed**: {fix_summary['total_fixed']}
- **Files Modified**: {len(fix_summary['files_modified'])}
- **Lines Changed**: {impact['lines_changed']}
- **Risk Level**: {impact['risk_level'].upper()}

### ğŸ”§ Fixes by Category
{self._format_category_fixes(fix_summary['by_category'])}

### ğŸ“ Modified Files
{self._format_file_list(fix_summary['files_modified'])}

### ğŸ¯ Impact Analysis
- **Core Files Affected**: {len(impact['core_files_affected'])}
- **Test Files Affected**: {len(impact['test_files_affected'])}

### âœ… Automated Checks
- [x] Syntax validation passed
- [x] Import resolution completed
- [x] Code formatting applied
- [x] Security scan performed

### ğŸ” Review Checklist
- [ ] Review all changes
- [ ] Run local tests
- [ ] Verify functionality
- [ ] Approve and merge

---
ğŸ¤– *This PR was automatically generated by the Incident Knights system*
âš”ï¸ *Protecting your code quality 24/7*"""
    
    def _format_category_fixes(self, by_category: Dict[str, int]) -> str:
        """ã‚«ãƒ†ã‚´ãƒªåˆ¥ä¿®æ­£ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        lines = []
        emoji_map = {
            'syntax_errors': 'ğŸ”§',
            'import_errors': 'ğŸ“¦',
            'security_issues': 'ğŸ”’',
            'formatting_issues': 'ğŸ¨',
            'test_failures': 'ğŸ§ª'
        }
        
        for category, count in by_category.items():
            emoji = emoji_map.get(category, 'ğŸ“Œ')
            category_name = category.replace('_', ' ').title()
            lines.append(f"{emoji} **{category_name}**: {count} fixed")
        
        return '\n'.join(lines) if lines else '*No fixes applied*'
    
    def _format_file_list(self, files: List[str]) -> str:
        """ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        if not files:
            return '*No files modified*'
        
        # Group files by directory
        from collections import defaultdict
        by_dir = defaultdict(list)
        
        for file_path in sorted(files):
            path = Path(file_path)
            dir_path = str(path.parent)
            by_dir[dir_path].append(path.name)
        
        lines = []
        for dir_path, file_names in sorted(by_dir.items()):
            lines.append(f"**{dir_path}/**")
            for name in sorted(file_names):
                lines.append(f"  - {name}")
        
        return '\n'.join(lines)