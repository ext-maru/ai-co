#!/usr/bin/env python3
"""
Learning Data Collection System v0.1
ÈÅéÂéª„ÅÆÊåáÁ§∫„Å®ÂÆüË°åÁµêÊûú„Çí„Éö„Ç¢„ÅßÂèéÈõÜ„ÉªÂ≠¶Áøí

üéØ nWo Learning Data Collector Implementation
Collect and learn from maruÊßò's commands and results
"""

import asyncio
import json
import sqlite3
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, asdict
from enum import Enum
from pathlib import Path
import logging
import hashlib

from libs.mind_reading_core import IntentResult, IntentType
from libs.intent_parser import ParsedCommand, CommandType


class ExecutionStatus(Enum):
    """ÂÆüË°å„Çπ„ÉÜ„Éº„Çø„Çπ"""
    SUCCESS = "success"
    FAILURE = "failure"
    PARTIAL = "partial"
    PENDING = "pending"
    CANCELLED = "cancelled"


class DataQuality(Enum):
    """„Éá„Éº„ÇøÂìÅË≥™"""
    HIGH = "high"         # ÊàêÂäüÔºãË©≥Á¥∞„Å™„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ
    MEDIUM = "medium"     # ÊàêÂäü„Åæ„Åü„ÅØ„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ„ÅÇ„Çä
    LOW = "low"           # Â§±Êïó„Åæ„Åü„ÅØÊúÄÂ∞èÈôê„ÅÆÊÉÖÂ†±
    UNVERIFIED = "unverified"  # Êú™Ê§úË®º


@dataclass
class CommandExecution:
    """„Ç≥„Éû„É≥„ÉâÂÆüË°åË®òÈå≤"""
    execution_id: str
    original_text: str
    intent_result: Dict[str, Any]  # IntentResult„ÅÆJSONË°®Áèæ
    parsed_command: Dict[str, Any]  # ParsedCommand„ÅÆJSONË°®Áèæ
    executed_command: str
    execution_time: float
    status: ExecutionStatus
    output: str
    error: Optional[str]
    feedback: Optional[Dict[str, Any]]
    quality: DataQuality
    timestamp: str


@dataclass
class LearningPattern:
    """Â≠¶Áøí„Éë„Çø„Éº„É≥"""
    pattern_id: str
    intent_type: str
    command_type: str
    success_count: int
    failure_count: int
    avg_execution_time: float
    common_parameters: Dict[str, Any]
    best_practices: List[str]
    common_errors: List[str]
    last_updated: str


@dataclass
class InsightReport:
    """Ê¥ûÂØü„É¨„Éù„Éº„Éà"""
    report_id: str
    period: str
    total_executions: int
    success_rate: float
    avg_confidence: float
    top_intents: List[Tuple[str, int]]
    top_commands: List[Tuple[str, int]]
    improvement_suggestions: List[str]
    generated_at: str


class LearningDataCollector:
    """Learning Data Collector - ÊåáÁ§∫„Å®ÁµêÊûú„ÅÆ„Éö„Ç¢ÂèéÈõÜ„ÉªÂ≠¶Áøí"""

    def __init__(self, db_path: str = "data/learning_data.db"):
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)

        self.logger = self._setup_logger()

        # „Éá„Éº„Çø„Éô„Éº„ÇπÂàùÊúüÂåñ
        self._init_database()

        # „É°„É¢„É™„Ç≠„É£„ÉÉ„Ç∑„É•
        self.execution_cache: Dict[str, CommandExecution] = {}
        self.pattern_cache: Dict[str, LearningPattern] = {}

        self.logger.info("üéØ Learning Data Collector v0.1 initialized")

    def _setup_logger(self) -> logging.Logger:
        """„É≠„Ç¨„ÉºË®≠ÂÆö"""
        logger = logging.getLogger("learning_data_collector")
        logger.setLevel(logging.INFO)

        if not logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                "%(asctime)s - Learning Collector - %(levelname)s - %(message)s"
            )
            handler.setFormatter(formatter)
            logger.addHandler(handler)

        return logger

    def _init_database(self):
        """„Éá„Éº„Çø„Éô„Éº„ÇπÂàùÊúüÂåñ"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # „Ç≥„Éû„É≥„ÉâÂÆüË°åÂ±•Ê≠¥„ÉÜ„Éº„Éñ„É´
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS command_executions (
                execution_id TEXT PRIMARY KEY,
                original_text TEXT NOT NULL,
                intent_result TEXT NOT NULL,
                parsed_command TEXT NOT NULL,
                executed_command TEXT NOT NULL,
                execution_time REAL NOT NULL,
                status TEXT NOT NULL,
                output TEXT,
                error TEXT,
                feedback TEXT,
                quality TEXT NOT NULL,
                timestamp TEXT NOT NULL
            )
        """)

        # Â≠¶Áøí„Éë„Çø„Éº„É≥„ÉÜ„Éº„Éñ„É´
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS learning_patterns (
                pattern_id TEXT PRIMARY KEY,
                intent_type TEXT NOT NULL,
                command_type TEXT NOT NULL,
                success_count INTEGER DEFAULT 0,
                failure_count INTEGER DEFAULT 0,
                avg_execution_time REAL DEFAULT 0.0,
                common_parameters TEXT,
                best_practices TEXT,
                common_errors TEXT,
                last_updated TEXT NOT NULL
            )
        """)

        # Ê¥ûÂØü„É¨„Éù„Éº„Éà„ÉÜ„Éº„Éñ„É´
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS insight_reports (
                report_id TEXT PRIMARY KEY,
                period TEXT NOT NULL,
                total_executions INTEGER NOT NULL,
                success_rate REAL NOT NULL,
                avg_confidence REAL NOT NULL,
                top_intents TEXT NOT NULL,
                top_commands TEXT NOT NULL,
                improvement_suggestions TEXT NOT NULL,
                generated_at TEXT NOT NULL
            )
        """)

        # „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ‰ΩúÊàê
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_timestamp ON command_executions(timestamp)")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_intent_type ON learning_patterns(intent_type)")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_command_type ON learning_patterns(command_type)")

        conn.commit()
        conn.close()

    async def record_execution(
        self,
        original_text: str,
        intent_result: IntentResult,
        parsed_command: ParsedCommand,
        executed_command: str,
        execution_time: float,
        status: ExecutionStatus,
        output: str = "",
        error: Optional[str] = None,
        feedback: Optional[Dict[str, Any]] = None
    ) -> CommandExecution:
        """
        „Ç≥„Éû„É≥„ÉâÂÆüË°å„ÅÆË®òÈå≤

        Args:
            original_text: ÂÖÉ„ÅÆÂÖ•Âäõ„ÉÜ„Ç≠„Çπ„Éà
            intent_result: ÊÑèÂõ≥ÁêÜËß£ÁµêÊûú
            parsed_command: „Éë„Éº„ÇπÊ∏à„Åø„Ç≥„Éû„É≥„Éâ
            executed_command: ÂÆüÈöõ„Å´ÂÆüË°å„Åï„Çå„Åü„Ç≥„Éû„É≥„Éâ
            execution_time: ÂÆüË°åÊôÇÈñìÔºàÁßíÔºâ
            status: ÂÆüË°å„Çπ„ÉÜ„Éº„Çø„Çπ
            output: ÂÆüË°åÂá∫Âäõ
            error: „Ç®„É©„ÉºÊÉÖÂ†±
            feedback: „Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØÊÉÖÂ†±

        Returns:
            CommandExecution: Ë®òÈå≤„Åï„Çå„ÅüÂÆüË°åÊÉÖÂ†±
        """
        # ÂÆüË°åID„ÅÆÁîüÊàê
        execution_id = self._generate_execution_id(original_text, executed_command)

        # „Éá„Éº„ÇøÂìÅË≥™„ÅÆÂà§ÂÆö
        quality = self._assess_data_quality(status, output, feedback)

        # IntentResult„Å®ParsedCommand„ÇíJSONÂΩ¢Âºè„Å´Â§âÊèõ
        intent_dict = asdict(intent_result)
        intent_dict["intent_type"] = intent_result.intent_type.value
        intent_dict["confidence_level"] = intent_result.confidence_level.value

        command_dict = asdict(parsed_command)
        command_dict["command_type"] = parsed_command.command_type.value

        # ÂÆüË°åË®òÈå≤„ÅÆ‰ΩúÊàê
        execution = CommandExecution(
            execution_id=execution_id,
            original_text=original_text,
            intent_result=intent_dict,
            parsed_command=command_dict,
            executed_command=executed_command,
            execution_time=execution_time,
            status=status,
            output=output[:5000],  # ÊúÄÂ§ß5000ÊñáÂ≠ó
            error=error,
            feedback=feedback,
            quality=quality,
            timestamp=datetime.now().isoformat()
        )

        # „Éá„Éº„Çø„Éô„Éº„Çπ„Å´‰øùÂ≠ò
        await self._save_execution(execution)

        # „Éë„Çø„Éº„É≥Êõ¥Êñ∞
        await self._update_patterns(execution)

        # „Ç≠„É£„ÉÉ„Ç∑„É•Êõ¥Êñ∞
        self.execution_cache[execution_id] = execution

        self.logger.info(f"üìù Recorded execution: {execution_id} ({status.value})")

        return execution

    def _generate_execution_id(self, original_text: str, command: str) -> str:
        """ÂÆüË°åID„ÅÆÁîüÊàê"""
        content = f"{original_text}:{command}:{datetime.now().isoformat()}"
        return hashlib.md5(content.encode()).hexdigest()[:16]

    def _assess_data_quality(
        self,
        status: ExecutionStatus,
        output: str,
        feedback: Optional[Dict]
    ) -> DataQuality:
        """„Éá„Éº„ÇøÂìÅË≥™„ÅÆË©ï‰æ°"""
        if status == ExecutionStatus.SUCCESS:
            if feedback and len(output) > 100:
                return DataQuality.HIGH
            else:
                return DataQuality.MEDIUM
        elif status == ExecutionStatus.PARTIAL:
            return DataQuality.MEDIUM
        else:
            return DataQuality.LOW

    async def _save_execution(self, execution: CommandExecution):
        """ÂÆüË°åË®òÈå≤„ÅÆ‰øùÂ≠ò"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        try:
            cursor.execute("""
                INSERT INTO command_executions VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                execution.execution_id,
                execution.original_text,
                json.dumps(execution.intent_result, ensure_ascii=False),
                json.dumps(execution.parsed_command, ensure_ascii=False),
                execution.executed_command,
                execution.execution_time,
                execution.status.value,
                execution.output,
                execution.error,
                json.dumps(execution.feedback, ensure_ascii=False) if execution.feedback else None,
                execution.quality.value,
                execution.timestamp
            ))

            conn.commit()
        except Exception as e:
            self.logger.error(f"Failed to save execution: {e}")
        finally:
            conn.close()

    async def _update_patterns(self, execution: CommandExecution):
        """Â≠¶Áøí„Éë„Çø„Éº„É≥„ÅÆÊõ¥Êñ∞"""
        intent_type = execution.intent_result["intent_type"]
        command_type = execution.parsed_command["command_type"]
        pattern_id = f"{intent_type}_{command_type}"

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        try:
            # Êó¢Â≠ò„Éë„Çø„Éº„É≥„ÅÆÂèñÂæó
            cursor.execute("""
                SELECT * FROM learning_patterns WHERE pattern_id = ?
            """, (pattern_id,))

            existing = cursor.fetchone()

            if existing:
                # Êõ¥Êñ∞
                success_count = existing[3]
                failure_count = existing[4]
                avg_time = existing[5]

                if execution.status == ExecutionStatus.SUCCESS:
                    success_count += 1
                else:
                    failure_count += 1

                # ÂÆüË°åÊôÇÈñì„ÅÆÊõ¥Êñ∞ÔºàÁßªÂãïÂπ≥ÂùáÔºâ
                total_count = success_count + failure_count
                avg_time = (avg_time * (total_count - 1) + execution.execution_time) / total_count

                cursor.execute("""
                    UPDATE learning_patterns
                    SET success_count = ?, failure_count = ?, avg_execution_time = ?, last_updated = ?
                    WHERE pattern_id = ?
                """, (success_count, failure_count, avg_time, datetime.now().isoformat(), pattern_id))
            else:
                # Êñ∞Ë¶è‰ΩúÊàê
                cursor.execute("""
                    INSERT INTO learning_patterns VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    pattern_id,
                    intent_type,
                    command_type,
                    1 if execution.status == ExecutionStatus.SUCCESS else 0,
                    0 if execution.status == ExecutionStatus.SUCCESS else 1,
                    execution.execution_time,
                    json.dumps({}),
                    json.dumps([]),
                    json.dumps([]),
                    datetime.now().isoformat()
                ))

            conn.commit()
        except Exception as e:
            self.logger.error(f"Failed to update patterns: {e}")
        finally:
            conn.close()

    async def get_similar_executions(
        self,
        intent_type: IntentType,
        command_type: CommandType,
        limit: int = 10
    ) -> List[CommandExecution]:
        """
        È°û‰ºº„Åó„ÅüÂÆüË°åÂ±•Ê≠¥„ÅÆÂèñÂæó

        Args:
            intent_type: ÊÑèÂõ≥„Çø„Ç§„Éó
            command_type: „Ç≥„Éû„É≥„Éâ„Çø„Ç§„Éó
            limit: ÂèñÂæó‰ª∂Êï∞‰∏äÈôê

        Returns:
            List[CommandExecution]: È°û‰ººÂÆüË°åÂ±•Ê≠¥
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        try:
            cursor.execute("""
                SELECT * FROM command_executions
                WHERE json_extract(intent_result, '$.intent_type') = ?
                AND json_extract(parsed_command, '$.command_type') = ?
                ORDER BY timestamp DESC
                LIMIT ?
            """, (intent_type.value, command_type.value, limit))

            rows = cursor.fetchall()
            executions = []

            for row in rows:
                execution = CommandExecution(
                    execution_id=row[0],
                    original_text=row[1],
                    intent_result=json.loads(row[2]),
                    parsed_command=json.loads(row[3]),
                    executed_command=row[4],
                    execution_time=row[5],
                    status=ExecutionStatus(row[6]),
                    output=row[7] or "",
                    error=row[8],
                    feedback=json.loads(row[9]) if row[9] else None,
                    quality=DataQuality(row[10]),
                    timestamp=row[11]
                )
                executions.append(execution)

            return executions

        except Exception as e:
            self.logger.error(f"Failed to get similar executions: {e}")
            return []
        finally:
            conn.close()

    async def get_success_patterns(self, intent_type: Optional[IntentType] = None) -> List[LearningPattern]:
        """
        ÊàêÂäü„Éë„Çø„Éº„É≥„ÅÆÂèñÂæó

        Args:
            intent_type: „Éï„Ç£„É´„Çø„Åô„ÇãÊÑèÂõ≥„Çø„Ç§„ÉóÔºàÁúÅÁï•ÊôÇ„ÅØÂÖ®„Å¶Ôºâ

        Returns:
            List[LearningPattern]: ÊàêÂäüÁéá„ÅÆÈ´ò„ÅÑ„Éë„Çø„Éº„É≥
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        try:
            if intent_type:
                cursor.execute("""
                    SELECT * FROM learning_patterns
                    WHERE intent_type = ? AND success_count > failure_count
                    ORDER BY (success_count * 1.0 / (success_count + failure_count)) DESC
                """, (intent_type.value,))
            else:
                cursor.execute("""
                    SELECT * FROM learning_patterns
                    WHERE success_count > failure_count
                    ORDER BY (success_count * 1.0 / (success_count + failure_count)) DESC
                """)

            rows = cursor.fetchall()
            patterns = []

            for row in rows:
                pattern = LearningPattern(
                    pattern_id=row[0],
                    intent_type=row[1],
                    command_type=row[2],
                    success_count=row[3],
                    failure_count=row[4],
                    avg_execution_time=row[5],
                    common_parameters=json.loads(row[6]),
                    best_practices=json.loads(row[7]),
                    common_errors=json.loads(row[8]),
                    last_updated=row[9]
                )
                patterns.append(pattern)

            return patterns

        except Exception as e:
            self.logger.error(f"Failed to get success patterns: {e}")
            return []
        finally:
            conn.close()

    async def generate_insights(self, period_days: int = 7) -> InsightReport:
        """
        Ê¥ûÂØü„É¨„Éù„Éº„Éà„ÅÆÁîüÊàê

        Args:
            period_days: ÂàÜÊûêÊúüÈñìÔºàÊó•Êï∞Ôºâ

        Returns:
            InsightReport: ÁîüÊàê„Åï„Çå„ÅüÊ¥ûÂØü„É¨„Éù„Éº„Éà
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        try:
            # ÊúüÈñì„ÅÆË®àÁÆó
            start_date = (datetime.now() - timedelta(days=period_days)).isoformat()

            # Âü∫Êú¨Áµ±Ë®à
            cursor.execute("""
                SELECT COUNT(*),
                       SUM(CASE WHEN status = 'success' THEN 1 ELSE 0 END),
                       AVG(json_extract(intent_result, '$.confidence'))
                FROM command_executions
                WHERE timestamp > ?
            """, (start_date,))

            total, success_count, avg_confidence = cursor.fetchone()
            success_rate = success_count / total if total > 0 else 0.0

            # „Éà„ÉÉ„ÉóÊÑèÂõ≥
            cursor.execute("""
                SELECT json_extract(intent_result, '$.intent_type'), COUNT(*) as cnt
                FROM command_executions
                WHERE timestamp > ?
                GROUP BY json_extract(intent_result, '$.intent_type')
                ORDER BY cnt DESC
                LIMIT 5
            """, (start_date,))

            top_intents = cursor.fetchall()

            # „Éà„ÉÉ„Éó„Ç≥„Éû„É≥„Éâ
            cursor.execute("""
                SELECT json_extract(parsed_command, '$.command_type'), COUNT(*) as cnt
                FROM command_executions
                WHERE timestamp > ?
                GROUP BY json_extract(parsed_command, '$.command_type')
                ORDER BY cnt DESC
                LIMIT 5
            """, (start_date,))

            top_commands = cursor.fetchall()

            # ÊîπÂñÑÊèêÊ°à„ÅÆÁîüÊàê
            improvement_suggestions = self._generate_improvement_suggestions(
                success_rate, avg_confidence, top_intents, top_commands
            )

            # „É¨„Éù„Éº„Éà‰ΩúÊàê
            report = InsightReport(
                report_id=f"insight_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                period=f"{period_days}_days",
                total_executions=total or 0,
                success_rate=success_rate,
                avg_confidence=avg_confidence or 0.0,
                top_intents=top_intents,
                top_commands=top_commands,
                improvement_suggestions=improvement_suggestions,
                generated_at=datetime.now().isoformat()
            )

            # „É¨„Éù„Éº„Éà‰øùÂ≠ò
            await self._save_insight_report(report)

            return report

        except Exception as e:
            self.logger.error(f"Failed to generate insights: {e}")
            # „Ç®„É©„ÉºÊôÇ„ÅÆ„Éá„Éï„Ç©„É´„Éà„É¨„Éù„Éº„Éà
            return InsightReport(
                report_id="error_report",
                period=f"{period_days}_days",
                total_executions=0,
                success_rate=0.0,
                avg_confidence=0.0,
                top_intents=[],
                top_commands=[],
                improvement_suggestions=["„Éá„Éº„ÇøÂèñÂæó„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü"],
                generated_at=datetime.now().isoformat()
            )
        finally:
            conn.close()

    def _generate_improvement_suggestions(
        self,
        success_rate: float,
        avg_confidence: float,
        top_intents: List[Tuple[str, int]],
        top_commands: List[Tuple[str, int]]
    ) -> List[str]:
        """ÊîπÂñÑÊèêÊ°à„ÅÆÁîüÊàê"""
        suggestions = []

        # ÊàêÂäüÁéá„Å´Âü∫„Å•„ÅèÊèêÊ°à
        if success_rate < 0.7:
            suggestions.append("ÊàêÂäüÁéá„Åå70%Êú™Ê∫Ä„Åß„Åô„ÄÇÂ§±Êïó„Éë„Çø„Éº„É≥„ÇíÂàÜÊûê„Åó„ÄÅ„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„ÇíÊîπÂñÑ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")

        # ‰ø°È†ºÂ∫¶„Å´Âü∫„Å•„ÅèÊèêÊ°à
        if avg_confidence < 0.6:
            suggestions.append("Âπ≥Âùá‰ø°È†ºÂ∫¶„Åå‰Ωé„ÅÑ„Åß„Åô„ÄÇ„Çà„ÇäÊòéÁ¢∫„Å™ÊåáÁ§∫„Éë„Çø„Éº„É≥„ÇíÂ≠¶Áøí„Åï„Åõ„Çã„Åì„Å®„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")

        # ÊÑèÂõ≥„ÅÆÂÅè„Çä„ÉÅ„Çß„ÉÉ„ÇØ
        if top_intents and top_intents[0][1] > sum(count for _, count in top_intents) * 0.5:
            suggestions.append(f"{top_intents[0][0]}„ÅÆ‰ΩøÁî®„ÅåÂ§ö„Åô„Åé„Åæ„Åô„ÄÇ‰ªñ„ÅÆÊ©üËÉΩ„ÇÇÊ¥ªÁî®„Åó„Å¶„Éê„É©„É≥„Çπ„ÇíÂèñ„Çä„Åæ„Åó„Çá„ÅÜ„ÄÇ")

        # „Ç≥„Éû„É≥„Éâ„ÅÆÂ§öÊßòÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
        if len(top_commands) < 3:
            suggestions.append("‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Çã„Ç≥„Éû„É≥„Éâ„Çø„Ç§„Éó„ÅåÂ∞ë„Å™„ÅÑ„Åß„Åô„ÄÇ„Çà„ÇäÂ§öÊßò„Å™Êìç‰Ωú„ÇíË©¶„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")

        # „Éá„Éï„Ç©„É´„ÉàÊèêÊ°à
        if not suggestions:
            suggestions.append("È†ÜË™ø„Å´Á®ºÂÉç„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÁèæÂú®„ÅÆ‰ΩøÁî®„Éë„Çø„Éº„É≥„ÇíÁ∂ôÁ∂ö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")

        return suggestions

    async def _save_insight_report(self, report: InsightReport):
        """Ê¥ûÂØü„É¨„Éù„Éº„Éà„ÅÆ‰øùÂ≠ò"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        try:
            cursor.execute("""
                INSERT INTO insight_reports VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                report.report_id,
                report.period,
                report.total_executions,
                report.success_rate,
                report.avg_confidence,
                json.dumps(report.top_intents),
                json.dumps(report.top_commands),
                json.dumps(report.improvement_suggestions, ensure_ascii=False),
                report.generated_at
            ))

            conn.commit()
        except Exception as e:
            self.logger.error(f"Failed to save insight report: {e}")
        finally:
            conn.close()

    async def export_training_data(self, output_path: str, quality_threshold: DataQuality = DataQuality.MEDIUM):
        """
        „Éà„É¨„Éº„Éã„É≥„Ç∞„Éá„Éº„Çø„ÅÆ„Ç®„ÇØ„Çπ„Éù„Éº„Éà

        Args:
            output_path: Âá∫Âäõ„Éï„Ç°„Ç§„É´„Éë„Çπ
            quality_threshold: ÂìÅË≥™ÈñæÂÄ§
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        try:
            # ÂìÅË≥™Âü∫Ê∫ñ„ÇíÊ∫Ä„Åü„Åô„Éá„Éº„Çø„ÇíÂèñÂæó
            quality_values = {
                DataQuality.HIGH: ["high"],
                DataQuality.MEDIUM: ["high", "medium"],
                DataQuality.LOW: ["high", "medium", "low"],
                DataQuality.UNVERIFIED: ["high", "medium", "low", "unverified"]
            }

            placeholders = ",".join("?" * len(quality_values[quality_threshold]))
            cursor.execute(f"""
                SELECT original_text, intent_result, parsed_command,
                       executed_command, status, output
                FROM command_executions
                WHERE quality IN ({placeholders})
                AND status = 'success'
            """, quality_values[quality_threshold])

            rows = cursor.fetchall()

            # „Éà„É¨„Éº„Éã„É≥„Ç∞„Éá„Éº„ÇøÂΩ¢Âºè„Å´Â§âÊèõ
            training_data = []
            for row in rows:
                data = {
                    "input": row[0],
                    "intent": json.loads(row[1]),
                    "command": json.loads(row[2]),
                    "execution": row[3],
                    "output": row[5]
                }
                training_data.append(data)

            # „Éï„Ç°„Ç§„É´„Å´‰øùÂ≠ò
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)

            with open(output_file, 'w') as f:
                json.dump(training_data, f, indent=2, ensure_ascii=False)

            self.logger.info(f"Exported {len(training_data)} training samples to {output_path}")

        except Exception as e:
            self.logger.error(f"Failed to export training data: {e}")
        finally:
            conn.close()

    def get_statistics(self) -> Dict[str, Any]:
        """Áµ±Ë®àÊÉÖÂ†±„ÅÆÂèñÂæó"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        try:
            stats = {}

            # Á∑èÂÆüË°åÊï∞
            cursor.execute("SELECT COUNT(*) FROM command_executions")
            stats["total_executions"] = cursor.fetchone()[0]

            # „Çπ„ÉÜ„Éº„Çø„ÇπÂà•„Ç´„Ç¶„É≥„Éà
            cursor.execute("""
                SELECT status, COUNT(*) FROM command_executions
                GROUP BY status
            """)
            stats["status_counts"] = dict(cursor.fetchall())

            # ÂìÅË≥™Âà•„Ç´„Ç¶„É≥„Éà
            cursor.execute("""
                SELECT quality, COUNT(*) FROM command_executions
                GROUP BY quality
            """)
            stats["quality_counts"] = dict(cursor.fetchall())

            # „Éë„Çø„Éº„É≥Êï∞
            cursor.execute("SELECT COUNT(*) FROM learning_patterns")
            stats["total_patterns"] = cursor.fetchone()[0]

            # Âπ≥ÂùáÂÆüË°åÊôÇÈñì
            cursor.execute("SELECT AVG(execution_time) FROM command_executions")
            stats["avg_execution_time"] = cursor.fetchone()[0] or 0.0

            return stats

        except Exception as e:
            self.logger.error(f"Failed to get statistics: {e}")
            return {}
        finally:
            conn.close()


# „Éá„É¢„Å®‰ΩøÁî®‰æã
async def demo_learning_collector():
    """Learning Data Collector „Éá„É¢"""
    print("üéØ Learning Data Collector v0.1 Demo")
    print("=" * 50)

    from libs.mind_reading_core import MindReadingCore
    from libs.intent_parser import IntentParser

    # ÂàùÊúüÂåñ
    mind_reader = MindReadingCore()
    parser = IntentParser()
    collector = LearningDataCollector()

    # „ÉÜ„Çπ„ÉàÂÆüË°å
    test_text = "OAuth2.0Ë™çË®º„Ç∑„Çπ„ÉÜ„É†„ÇíÂÆüË£Ö„Åó„Å¶„Åè„Å†„Åï„ÅÑ"

    # ÊÑèÂõ≥ÁêÜËß£„Å®„Éë„Éº„Çπ
    intent_result = await mind_reader.understand_intent(test_text)
    parsed_command = await parser.parse_intent(intent_result, test_text)
    command = await parser.generate_command(parsed_command)

    # ÂÆüË°åË®òÈå≤Ôºà„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºâ
    execution = await collector.record_execution(
        original_text=test_text,
        intent_result=intent_result,
        parsed_command=parsed_command,
        executed_command=command,
        execution_time=2.5,
        status=ExecutionStatus.SUCCESS,
        output="OAuth2.0 authentication system implemented successfully",
        feedback={"accuracy": 0.9, "usefulness": "high"}
    )

    print(f"\nüìù Recorded execution: {execution.execution_id}")
    print(f"Status: {execution.status.value}")
    print(f"Quality: {execution.quality.value}")

    # Áµ±Ë®àÊÉÖÂ†±
    stats = collector.get_statistics()
    print(f"\nüìä Statistics:")
    for key, value in stats.items():
        print(f"  {key}: {value}")

    # Ê¥ûÂØü„É¨„Éù„Éº„ÉàÁîüÊàê
    report = await collector.generate_insights(period_days=7)
    print(f"\nüîç Insight Report:")
    print(f"Total executions: {report.total_executions}")
    print(f"Success rate: {report.success_rate:.2%}")
    print(f"Average confidence: {report.avg_confidence:.2f}")
    print(f"Suggestions: {', '.join(report.improvement_suggestions)}")


if __name__ == "__main__":
    asyncio.run(demo_learning_collector())
