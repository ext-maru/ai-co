#!/usr/bin/env python3
"""
AI Command System v3.0 - Ultimate Edition
Phase 3: 最終完成版 - AI自然言語処理、インタラクティブモード、プラグイン対応
"""

import sys
import os
import json
import subprocess
import re
import shlex
import sqlite3
from pathlib import Path
from typing import List, Dict, Optional, Tuple, Any
from datetime import datetime
import pwd
import getpass
import readline
import atexit
import importlib.util

class AICommandSystemV3:
    """AI統合コマンドシステム v3.0 Ultimate"""
    
    def __init__(self):
        self.scripts_dir = Path("/home/aicompany/ai_co/scripts")
        self.config_dir = Path.home() / ".ai-config"
        self.config_dir.mkdir(exist_ok=True)
        self.version = "3.0.0"
        
        # Initialize components
        self.user_config = self.load_user_config()
        self.permission_level = self.detect_permission_level()
        self.stats_db = self.init_stats_database()
        self.command_history = self.load_command_history()
        
        # Setup readline for interactive mode
        self.setup_readline()
        
        # Enhanced categories with plugin support
        self.categories = {
            "core": {
                "name": "Core Commands",
                "description": "基本システムコマンド",
                "permission": "user",
                "commands": {
                    "start": {"script": "ai-start", "desc": "システム起動", "permission": "developer"},
                    "stop": {"script": "ai-stop", "desc": "システム停止", "permission": "developer"},
                    "status": {"script": "ai-status", "desc": "システム状態確認", "permission": "user"},
                    "env": {"script": "ai-env", "desc": "環境設定", "permission": "user"},
                    "config": {"script": None, "desc": "設定管理", "permission": "user"},
                    "interactive": {"script": None, "desc": "対話モード開始", "permission": "user"},
                    "chain": {"script": None, "desc": "コマンドチェーン実行", "permission": "user"}
                }
            },
            "elder": {
                "name": "Elder Management",
                "description": "エルダー管理機能",
                "permission": "elder",
                "commands": {
                    "status": {"script": "ai-elder", "desc": "エルダー状態確認", "permission": "elder"},
                    "council": {"script": "ai-elder-council", "desc": "評議会管理", "permission": "elder"},
                    "settings": {"script": "ai-elder-settings", "desc": "設定表示", "permission": "user"},
                    "tree": {"script": "ai-elder-tree", "desc": "エルダーツリー表示", "permission": "user"},
                    "compliance": {"script": "ai-elder-compliance", "desc": "コンプライアンス", "permission": "elder"},
                    "servant": {"script": "ai-servant", "desc": "サーバント管理", "permission": "elder"}
                }
            },
            "worker": {
                "name": "Worker Management", 
                "description": "ワーカー管理",
                "permission": "developer",
                "commands": {
                    "status": {"script": "ai-worker-comm", "desc": "ワーカー通信状態", "permission": "developer"},
                    "recovery": {"script": "ai-worker-recovery", "desc": "ワーカー復旧", "permission": "developer"},
                    "dlq": {"script": "ai-dlq", "desc": "DLQ管理", "permission": "developer"}
                }
            },
            "dev": {
                "name": "Development Tools",
                "description": "開発ツール",
                "permission": "developer",
                "commands": {
                    "codegen": {"script": "ai-codegen", "desc": "コード生成", "permission": "developer"},
                    "document": {"script": "ai-document", "desc": "ドキュメント生成", "permission": "developer"},
                    "git": {"script": "ai-git", "desc": "Git統合", "permission": "developer"},
                    "tdd": {"script": "ai-tdd", "desc": "TDD開発", "permission": "developer"}
                }
            },
            "test": {
                "name": "Testing Tools",
                "description": "テストツール", 
                "permission": "developer",
                "commands": {
                    "coverage": {"script": "ai-test-coverage", "desc": "カバレッジ分析", "permission": "developer"},
                    "quality": {"script": "ai-test-quality", "desc": "品質分析", "permission": "developer"},
                    "runner": {"script": "ai-test-runner", "desc": "テスト実行", "permission": "developer"},
                    "magic": {"script": "ai-elf-test-magic", "desc": "エルフテスト魔法", "permission": "developer"}
                }
            },
            "ops": {
                "name": "Operations",
                "description": "運用ツール",
                "permission": "admin",
                "commands": {
                    "dashboard": {"script": "ai-dashboard", "desc": "ダッシュボード", "permission": "developer"},
                    "api-status": {"script": "ai-api-status", "desc": "API状態", "permission": "user"},
                    "api-health": {"script": "ai-api-health", "desc": "APIヘルス", "permission": "user"},
                    "api-reset": {"script": "ai-api-reset", "desc": "APIリセット", "permission": "admin"}
                }
            },
            "monitor": {
                "name": "Monitoring",
                "description": "監視・ログ",
                "permission": "developer",
                "commands": {
                    "logs": {"script": "ai-logs", "desc": "ログ表示", "permission": "developer"},
                    "proactive": {"script": "ai-elder-proactive-monitor", "desc": "予防的監視", "permission": "developer"}
                }
            },
            "integrate": {
                "name": "Integrations",
                "description": "外部連携",
                "permission": "developer", 
                "commands": {
                    "slack": {"script": "ai-slack", "desc": "Slack統合", "permission": "developer"},
                    "mcp": {"script": "ai-mcp", "desc": "MCP統合", "permission": "developer"},
                    "send": {"script": "ai-send", "desc": "メッセージ送信", "permission": "developer"}
                }
            }
        }
        
        # Load plugins
        self.plugins = self.load_plugins()
        
        # Smart aliases with AI enhancement
        self.smart_aliases = {
            "build": self.smart_build_command,
            "test": self.smart_test_command,
            "deploy": self.smart_deploy_command,
            "logs": self.smart_logs_command,
            "ask": self.ai_command_finder,
            "learn": self.learn_from_usage
        }
        
        # Enhanced aliases
        self.aliases = {
            "help": self.show_help,
            "h": self.show_help,
            "?": self.show_help,
            "version": self.show_version,
            "v": self.show_version,
            "config": self.manage_config,
            "permissions": self.show_permissions,
            "interactive": self.interactive_mode,
            "i": self.interactive_mode,
            "chain": self.command_chain,
            "stats": self.show_statistics,
            "plugins": self.manage_plugins,
            "ask": self.ai_command_finder,
            "docs": self.show_documentation
        }
    
    def init_stats_database(self) -> sqlite3.Connection:
        """統計データベースの初期化"""
        db_path = self.config_dir / "stats.db"
        conn = sqlite3.connect(str(db_path))
        
        conn.execute("""
            CREATE TABLE IF NOT EXISTS command_usage (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                user TEXT,
                command TEXT,
                category TEXT,
                success BOOLEAN,
                execution_time REAL,
                context TEXT
            )
        """)
        
        conn.execute("""
            CREATE TABLE IF NOT EXISTS ai_queries (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                query TEXT,
                suggested_command TEXT,
                user_accepted BOOLEAN
            )
        """)
        
        conn.commit()
        return conn
    
    def log_command_usage(self, command: str, category: str, success: bool, execution_time: float = 0.0, context: str = ""):
        """コマンド使用ログ"""
        try:
            self.stats_db.execute(
                "INSERT INTO command_usage (user, command, category, success, execution_time, context) VALUES (?, ?, ?, ?, ?, ?)",
                (getpass.getuser(), command, category, success, execution_time, context)
            )
            self.stats_db.commit()
        except:
            pass  # Fail silently for stats
    
    def setup_readline(self):
        """readline設定"""
        histfile = self.config_dir / "command_history"
        try:
            readline.read_history_file(str(histfile))
            readline.set_history_length(1000)
        except FileNotFoundError:
            pass
        
        atexit.register(readline.write_history_file, str(histfile))
        
        # Tab completion
        readline.set_completer(self.command_completer)
        readline.parse_and_bind('tab: complete')
    
    def command_completer(self, text: str, state: int) -> Optional[str]:
        """コマンド補完"""
        if state == 0:
            self.completion_matches = []
            
            # Complete categories
            for cat in self.categories.keys():
                if cat.startswith(text):
                    self.completion_matches.append(cat)
            
            # Complete special commands
            for alias in self.aliases.keys():
                if alias.startswith(text):
                    self.completion_matches.append(alias)
            
            # Complete smart aliases
            for alias in self.smart_aliases.keys():
                if alias.startswith(text):
                    self.completion_matches.append(alias)
        
        try:
            return self.completion_matches[state]
        except IndexError:
            return None
    
    def load_command_history(self) -> List[Dict]:
        """コマンド履歴をロード"""
        try:
            cursor = self.stats_db.execute(
                "SELECT command, category, timestamp FROM command_usage WHERE user = ? ORDER BY timestamp DESC LIMIT 50",
                (getpass.getuser(),)
            )
            return [{"command": row[0], "category": row[1], "timestamp": row[2]} for row in cursor.fetchall()]
        except:
            return []
    
    def load_plugins(self) -> Dict[str, Any]:
        """プラグインシステム"""
        plugins = {}
        plugins_dir = self.config_dir / "plugins"
        
        if not plugins_dir.exists():
            plugins_dir.mkdir()
            # Create example plugin
            example_plugin = plugins_dir / "example_plugin.py"
            with open(example_plugin, 'w') as f:
                f.write('''"""
Example AI Command System Plugin
"""

def plugin_info():
    return {
        "name": "example",
        "version": "1.0.0",
        "description": "Example plugin for AI Command System"
    }

def register_commands():
    return {
        "hello": {
            "function": hello_world,
            "description": "Say hello",
            "permission": "user"
        }
    }

def hello_world(args):
    print("Hello from AI Command System plugin!")
    return 0
''')
        
        # Load plugins
        for plugin_file in plugins_dir.glob("*.py"):
            if plugin_file.name.startswith("_"):
                continue
            
            try:
                spec = importlib.util.spec_from_file_location(plugin_file.stem, plugin_file)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                if hasattr(module, 'plugin_info') and hasattr(module, 'register_commands'):
                    info = module.plugin_info()
                    commands = module.register_commands()
                    plugins[info['name']] = {
                        'info': info,
                        'commands': commands,
                        'module': module
                    }
            except Exception as e:
                print(f"⚠️ Failed to load plugin {plugin_file.name}: {e}")
        
        return plugins
    
    def ai_command_finder(self, args: List[str]):
        """AI自然言語コマンドファインダー"""
        if not args:
            print("💬 AI Command Finder - 自然言語でコマンドを検索")
            print("Usage: ai ask \"テストを実行したい\"")
            print("       ai ask \"カバレッジレポートを生成\"")
            return 0
        
        query = ' '.join(args)
        print(f"🤖 AI分析中: \"{query}\"")
        
        # Simple NLP-like matching
        suggestions = self.analyze_natural_language_query(query)
        
        if not suggestions:
            print("❌ 該当するコマンドが見つかりませんでした")
            print("💡 Try: ai find <keyword> または ai help")
            return 1
        
        print(f"\n✨ 推奨コマンド:")
        for i, (cmd, confidence, reason) in enumerate(suggestions[:3], 1):
            print(f"  {i}. {cmd} (信頼度: {confidence:.0%})")
            print(f"     理由: {reason}")
        
        # Interactive selection
        if self.user_config.get("ai_interactive", True):
            try:
                choice = input(f"\n実行するコマンドを選択 (1-{len(suggestions[:3])}), Enter=キャンセル: ")
                if choice.isdigit() and 1 <= int(choice) <= len(suggestions[:3]):
                    selected_cmd = suggestions[int(choice)-1][0]
                    print(f"🚀 実行中: {selected_cmd}")
                    
                    # Log AI query
                    self.stats_db.execute(
                        "INSERT INTO ai_queries (query, suggested_command, user_accepted) VALUES (?, ?, ?)",
                        (query, selected_cmd, True)
                    )
                    self.stats_db.commit()
                    
                    return self.run(shlex.split(selected_cmd)[1:])  # Remove 'ai' prefix
                else:
                    print("❌ キャンセルしました")
            except KeyboardInterrupt:
                print("\n❌ キャンセルしました")
        
        return 0
    
    def analyze_natural_language_query(self, query: str) -> List[Tuple[str, float, str]]:
        """自然言語クエリ分析"""
        query_lower = query.lower()
        suggestions = []
        
        # テスト関連
        test_keywords = ["テスト", "test", "試験", "検証", "確認"]
        if any(keyword in query_lower for keyword in test_keywords):
            if "カバレッジ" in query_lower or "coverage" in query_lower:
                suggestions.append(("ai test coverage", 0.9, "カバレッジ分析が必要"))
            elif "品質" in query_lower or "quality" in query_lower:
                suggestions.append(("ai test quality", 0.85, "品質分析が必要"))
            else:
                suggestions.append(("ai test runner", 0.8, "テスト実行が必要"))
        
        # ビルド関連
        build_keywords = ["ビルド", "build", "コンパイル", "構築"]
        if any(keyword in query_lower for keyword in build_keywords):
            suggestions.append(("ai build", 0.9, "プロジェクトビルドが必要"))
        
        # ステータス関連
        status_keywords = ["状態", "status", "確認", "チェック"]
        if any(keyword in query_lower for keyword in status_keywords):
            if "エルダー" in query_lower or "elder" in query_lower:
                suggestions.append(("ai elder status", 0.9, "エルダー状態確認"))
            elif "ワーカー" in query_lower or "worker" in query_lower:
                suggestions.append(("ai worker status", 0.9, "ワーカー状態確認"))
            else:
                suggestions.append(("ai status", 0.8, "システム状態確認"))
        
        # ログ関連
        log_keywords = ["ログ", "log", "履歴", "記録"]
        if any(keyword in query_lower for keyword in log_keywords):
            suggestions.append(("ai logs", 0.9, "ログ表示が必要"))
        
        # ヘルプ関連
        help_keywords = ["ヘルプ", "help", "使い方", "方法"]
        if any(keyword in query_lower for keyword in help_keywords):
            suggestions.append(("ai help", 0.9, "ヘルプ表示が必要"))
        
        # エルダー関連
        elder_keywords = ["エルダー", "elder", "評議会", "council"]
        if any(keyword in query_lower for keyword in elder_keywords):
            if "設定" in query_lower or "setting" in query_lower:
                suggestions.append(("ai elder settings", 0.9, "エルダー設定表示"))
            elif "ツリー" in query_lower or "tree" in query_lower:
                suggestions.append(("ai elder tree", 0.9, "エルダーツリー表示"))
        
        return sorted(suggestions, key=lambda x: x[1], reverse=True)
    
    def interactive_mode(self, args: List[str] = None):
        """インタラクティブモード"""
        print(f"🎯 AI Command System v{self.version} - Interactive Mode")
        print("Type 'exit' or 'quit' to leave interactive mode")
        print("Type 'help' for available commands")
        print()
        
        while True:
            try:
                # Show context info
                context = self.detect_project_context()
                if context["type"] != "unknown":
                    prompt = f"ai ({context['type']})> "
                else:
                    prompt = "ai> "
                
                command = input(prompt).strip()
                
                if command in ['exit', 'quit', 'q']:
                    print("👋 Interactive mode terminated")
                    break
                
                if not command:
                    continue
                
                # Parse and execute command
                args = shlex.split(command)
                if args[0] == 'ai':
                    args = args[1:]  # Remove 'ai' prefix
                
                # Log interactive usage
                self.log_command_usage(command, "interactive", True, context=f"interactive_{context['type']}")
                
                # Execute command
                result = self.run(args)
                if result != 0:
                    print(f"⚠️ Command failed with exit code {result}")
                
                print()  # Add spacing
                
            except KeyboardInterrupt:
                print("\n👋 Interactive mode terminated")
                break
            except EOFError:
                print("\n👋 Interactive mode terminated")
                break
    
    def command_chain(self, args: List[str]):
        """コマンドチェーン実行"""
        if not args:
            print("🔗 Command Chain Execution")
            print("Usage: ai chain \"command1 && command2 || command3\"")
            print("       ai chain \"build && test && deploy\"")
            print("Examples:")
            print("  ai chain \"status && elder settings\"")
            print("  ai chain \"build && test coverage\"")
            return 0
        
        chain_command = ' '.join(args)
        print(f"🔗 実行中: {chain_command}")
        
        # Parse chain operators
        commands = []
        current_cmd = ""
        i = 0
        
        while i < len(chain_command):
            if chain_command[i:i+2] == "&&":
                commands.append(("&&", current_cmd.strip()))
                current_cmd = ""
                i += 2
            elif chain_command[i:i+2] == "||":
                commands.append(("||", current_cmd.strip()))
                current_cmd = ""
                i += 2
            else:
                current_cmd += chain_command[i]
                i += 1
        
        if current_cmd.strip():
            commands.append(("end", current_cmd.strip()))
        
        # Execute chain
        last_result = 0
        for i, (operator, cmd) in enumerate(commands):
            if i == 0:  # First command always executes
                pass
            elif operator == "&&" and last_result != 0:
                print(f"💥 Chain stopped at step {i}: previous command failed")
                break
            elif operator == "||" and last_result == 0:
                print(f"⏭️ Skipping step {i}: previous command succeeded")
                continue
            
            print(f"🔸 Step {i+1}: {cmd}")
            
            # Parse and execute
            cmd_args = shlex.split(cmd)
            if cmd_args[0] == 'ai':
                cmd_args = cmd_args[1:]
            
            last_result = self.run(cmd_args)
            
            if last_result == 0:
                print("✅ Success")
            else:
                print(f"❌ Failed (exit code: {last_result})")
        
        return last_result
    
    def show_statistics(self, args: List[str] = None):
        """使用統計表示"""
        print(f"📊 AI Command System Usage Statistics")
        print(f"User: {getpass.getuser()}")
        print()
        
        try:
            # Most used commands
            cursor = self.stats_db.execute("""
                SELECT command, COUNT(*) as count 
                FROM command_usage 
                WHERE user = ? 
                GROUP BY command 
                ORDER BY count DESC 
                LIMIT 10
            """, (getpass.getuser(),))
            
            top_commands = cursor.fetchall()
            if top_commands:
                print("🏆 Most Used Commands:")
                for cmd, count in top_commands:
                    print(f"  {cmd:<20} {count} times")
                print()
            
            # Recent activity
            cursor = self.stats_db.execute("""
                SELECT command, timestamp, success 
                FROM command_usage 
                WHERE user = ? 
                ORDER BY timestamp DESC 
                LIMIT 5
            """, (getpass.getuser(),))
            
            recent = cursor.fetchall()
            if recent:
                print("🕒 Recent Activity:")
                for cmd, timestamp, success in recent:
                    status = "✅" if success else "❌"
                    print(f"  {status} {cmd} ({timestamp})")
                print()
            
            # AI queries
            cursor = self.stats_db.execute("""
                SELECT COUNT(*) as total, 
                       SUM(CASE WHEN user_accepted THEN 1 ELSE 0 END) as accepted
                FROM ai_queries
            """)
            
            ai_stats = cursor.fetchone()
            if ai_stats and ai_stats[0] > 0:
                total, accepted = ai_stats
                acceptance_rate = (accepted / total) * 100 if total > 0 else 0
                print(f"🤖 AI Query Stats:")
                print(f"  Total queries: {total}")
                print(f"  Accepted suggestions: {accepted}")
                print(f"  Acceptance rate: {acceptance_rate:.1f}%")
        
        except Exception as e:
            print(f"❌ Error loading statistics: {e}")
    
    def manage_plugins(self, args: List[str]):
        """プラグイン管理"""
        if not args:
            print("🔌 AI Command System Plugins")
            print("\nInstalled Plugins:")
            for name, plugin in self.plugins.items():
                info = plugin['info']
                print(f"  📦 {name} v{info['version']}")
                print(f"     {info['description']}")
                
                commands = plugin['commands']
                if commands:
                    print(f"     Commands: {', '.join(commands.keys())}")
                print()
            
            print("Usage:")
            print("  ai plugins list     - List installed plugins")
            print("  ai plugins reload   - Reload all plugins")
            return 0
        
        if args[0] == "list":
            return self.manage_plugins([])
        elif args[0] == "reload":
            print("🔄 Reloading plugins...")
            self.plugins = self.load_plugins()
            print(f"✅ Loaded {len(self.plugins)} plugins")
        
        return 0
    
    def manage_config(self, args: List[str]):
        """設定管理"""
        if not args:
            print(f"\n⚙️ AI Command System Configuration")
            print(f"Config location: {self.config_dir / 'config.json'}")
            print(f"\nCurrent settings:")
            for key, value in self.user_config.items():
                print(f"  {key}: {value}")
            print(f"\nUsage:")
            print(f"  ai config set <key> <value>")
            print(f"  ai config get <key>")
            print(f"  ai config reset")
            return 0
        
        if args[0] == "set" and len(args) >= 3:
            key, value = args[1], args[2]
            # Type conversion
            if value.lower() in ['true', 'false']:
                value = value.lower() == 'true'
            elif value.isdigit():
                value = int(value)
            
            self.user_config[key] = value
            self.save_user_config()
            print(f"✅ Set {key} = {value}")
            
        elif args[0] == "get" and len(args) >= 2:
            key = args[1]
            print(f"{key}: {self.user_config.get(key, 'Not set')}")
            
        elif args[0] == "reset":
            self.user_config = {
                "aliases": {},
                "permission_level": "auto",
                "preferred_style": "standard",
                "enable_smart_aliases": True,
                "ai_interactive": True,
                "show_tips": True,
                "theme": "default"
            }
            self.save_user_config()
            print("✅ Configuration reset to defaults")
        
        return 0
    
    def save_user_config(self):
        """ユーザー設定を保存"""
        config_file = self.config_dir / "config.json"
        with open(config_file, 'w', encoding='utf-8') as f:
            json.dump(self.user_config, f, ensure_ascii=False, indent=2)
    
    def show_permissions(self, args: List[str] = None):
        """権限情報表示"""
        print(f"\n👤 Current User: {getpass.getuser()}")
        print(f"🔒 Permission Level: {self.permission_level}")
        print("\n📋 Permission Levels:")
        print("  user      - Basic commands only")
        print("  developer - Development tools included")
        print("  elder     - Elder management included")
        print("  admin     - All commands available")
        
        print(f"\n✅ Available Categories:")
        for cat_id, cat_info in self.categories.items():
            if self.check_permission(cat_info["permission"]):
                print(f"  {cat_id:<12} {cat_info['description']}")
            else:
                print(f"  {cat_id:<12} {cat_info['description']} (❌ requires {cat_info['permission']})")
    
    def show_category_help(self, category: str):
        """Enhanced category help"""
        if not self.check_permission(self.categories[category]["permission"]):
            print(f"❌ Category '{category}' requires {self.categories[category]['permission']} permission")
            return
        
        cat_info = self.categories[category]
        print(f"\n📁 {cat_info['name']}")
        print(f"{cat_info['description']}\n")
        print("Commands:")
        
        for cmd_name, cmd_info in cat_info['commands'].items():
            if self.check_permission(cmd_info.get('permission', 'user')):
                if category == 'core':
                    usage = f"ai {cmd_name}"
                else:
                    usage = f"ai {category} {cmd_name}"
                print(f"  {usage:<30} {cmd_info['desc']}")
            else:
                if category == 'core':
                    usage = f"ai {cmd_name}"
                else:
                    usage = f"ai {category} {cmd_name}"
                print(f"  {usage:<30} {cmd_info['desc']} (❌ requires {cmd_info.get('permission', 'user')})")
        print()
    
    def show_documentation(self, args: List[str] = None):
        """統合ドキュメントシステム"""
        docs_dir = Path("/home/aicompany/ai_co/docs")
        
        if not args:
            print("📚 AI Command System Documentation")
            print("\nAvailable Documentation:")
            
            if docs_dir.exists():
                for doc_file in docs_dir.glob("*.md"):
                    print(f"  📄 {doc_file.stem}")
            
            print("\nUsage:")
            print("  ai docs list                    - List all documentation")
            print("  ai docs <name>                  - Show specific document")
            print("  ai docs AI_COMMAND_SYSTEM_USER_GUIDE  - Show user guide")
            return 0
        
        doc_name = args[0]
        doc_file = docs_dir / f"{doc_name}.md"
        
        if not doc_file.exists():
            # Try variations
            variations = [
                docs_dir / f"{doc_name}.md",
                docs_dir / f"{doc_name.upper()}.md",
                docs_dir / f"{doc_name.lower()}.md"
            ]
            
            for variation in variations:
                if variation.exists():
                    doc_file = variation
                    break
            else:
                print(f"❌ Documentation not found: {doc_name}")
                return 1
        
        # Display document
        try:
            with open(doc_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Simple markdown rendering for terminal
            lines = content.split('\n')
            for line in lines[:50]:  # Limit output
                if line.startswith('# '):
                    print(f"\n🔥 {line[2:]}")
                elif line.startswith('## '):
                    print(f"\n📋 {line[3:]}")
                elif line.startswith('### '):
                    print(f"\n🔸 {line[4:]}")
                else:
                    print(line)
            
            if len(lines) > 50:
                print(f"\n... ({len(lines) - 50} more lines)")
                print(f"Full document: {doc_file}")
        
        except Exception as e:
            print(f"❌ Error reading documentation: {e}")
            return 1
        
        return 0
    
    def learn_from_usage(self, args: List[str]):
        """使用パターンから学習"""
        print("🧠 Learning from usage patterns...")
        
        try:
            # Analyze command patterns
            cursor = self.stats_db.execute("""
                SELECT command, category, context, COUNT(*) as frequency
                FROM command_usage 
                WHERE user = ? AND success = 1
                GROUP BY command, category, context
                ORDER BY frequency DESC
            """, (getpass.getuser(),))
            
            patterns = cursor.fetchall()
            
            if not patterns:
                print("📊 No usage data available yet")
                return 0
            
            print("📈 Usage Pattern Analysis:")
            
            # Find most common workflows
            contexts = {}
            for cmd, cat, ctx, freq in patterns:
                if ctx not in contexts:
                    contexts[ctx] = []
                contexts[ctx].append((cmd, freq))
            
            for context, commands in contexts.items():
                if context and len(commands) > 1:
                    print(f"\n🎯 Context: {context}")
                    for cmd, freq in sorted(commands, key=lambda x: x[1], reverse=True)[:3]:
                        print(f"  🔸 {cmd} (used {freq} times)")
            
            # Learning insights
            print(f"\n💡 Learning Insights:")
            
            # Most productive time
            cursor = self.stats_db.execute("""
                SELECT strftime('%H', timestamp) as hour, COUNT(*) as count
                FROM command_usage 
                WHERE user = ? AND success = 1
                GROUP BY hour
                ORDER BY count DESC
                LIMIT 1
            """, (getpass.getuser(),))
            
            peak_hour = cursor.fetchone()
            if peak_hour:
                print(f"  ⏰ Most productive hour: {peak_hour[0]}:00 ({peak_hour[1]} commands)")
            
            # Success rate
            cursor = self.stats_db.execute("""
                SELECT 
                    SUM(CASE WHEN success THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as success_rate
                FROM command_usage 
                WHERE user = ?
            """, (getpass.getuser(),))
            
            success_rate = cursor.fetchone()
            if success_rate:
                print(f"  ✅ Overall success rate: {success_rate[0]:.1f}%")
        
        except Exception as e:
            print(f"❌ Error analyzing usage: {e}")
        
        return 0
    
    def load_user_config(self) -> Dict:
        """Enhanced user config"""
        config_file = self.config_dir / "config.json"
        default_config = {
            "aliases": {},
            "permission_level": "auto",
            "preferred_style": "standard",
            "enable_smart_aliases": True,
            "ai_interactive": True,
            "show_tips": True,
            "theme": "default"
        }
        
        if config_file.exists():
            try:
                with open(config_file, 'r', encoding='utf-8') as f:
                    return {**default_config, **json.load(f)}
            except:
                pass
        
        return default_config
    
    def detect_permission_level(self) -> str:
        """Enhanced permission detection"""
        if self.user_config.get("permission_level") != "auto":
            return self.user_config["permission_level"]
        
        current_user = getpass.getuser()
        
        # Admin detection
        if current_user == "root" or current_user == "aicompany":
            return "admin"
        
        # Elder detection
        elder_users = ["claude", "maru", "elder"]
        if current_user in elder_users:
            return "elder"
        
        # Developer detection
        try:
            user_info = pwd.getpwnam(current_user)
            user_groups = [g.gr_name for g in pwd.getpwnam(current_user).pw_gid]
            dev_groups = ["developers", "devs", "sudo", "wheel"]
            if any(group in dev_groups for group in user_groups):
                return "developer"
        except:
            pass
        
        return "user"
    
    def check_permission(self, required_level: str) -> bool:
        """Permission check"""
        levels = ["user", "developer", "elder", "admin"]
        user_level_idx = levels.index(self.permission_level)
        required_level_idx = levels.index(required_level)
        return user_level_idx >= required_level_idx
    
    def detect_project_context(self) -> Dict[str, str]:
        """Enhanced project context detection"""
        cwd = Path.cwd()
        context = {"type": "unknown", "build_tool": None, "test_tool": None, "framework": None}
        
        # Python project
        if (cwd / "requirements.txt").exists() or (cwd / "pyproject.toml").exists():
            context["type"] = "python"
            context["build_tool"] = "pip" if (cwd / "requirements.txt").exists() else "poetry"
            context["test_tool"] = "pytest"
            
            # Check for frameworks
            if (cwd / "manage.py").exists():
                context["framework"] = "django"
            elif (cwd / "app.py").exists() or (cwd / "application.py").exists():
                context["framework"] = "flask"
        
        # Node.js project
        elif (cwd / "package.json").exists():
            context["type"] = "nodejs"
            context["build_tool"] = "npm"
            context["test_tool"] = "npm"
            
            try:
                with open(cwd / "package.json") as f:
                    package_data = json.load(f)
                    deps = {**package_data.get("dependencies", {}), **package_data.get("devDependencies", {})}
                    
                    if "react" in deps:
                        context["framework"] = "react"
                    elif "vue" in deps:
                        context["framework"] = "vue"
                    elif "angular" in deps:
                        context["framework"] = "angular"
                    elif "express" in deps:
                        context["framework"] = "express"
            except:
                pass
        
        # Go project
        elif (cwd / "go.mod").exists():
            context["type"] = "go"
            context["build_tool"] = "go"
            context["test_tool"] = "go"
        
        # Rust project
        elif (cwd / "Cargo.toml").exists():
            context["type"] = "rust"
            context["build_tool"] = "cargo"
            context["test_tool"] = "cargo"
        
        return context
    
    def smart_build_command(self, args: List[str]):
        """Enhanced smart build"""
        context = self.detect_project_context()
        print(f"🔨 Building {context['type']} project...")
        
        start_time = datetime.now()
        
        try:
            if context["type"] == "python":
                if context["build_tool"] == "poetry":
                    result = subprocess.call(["poetry", "install"] + args)
                else:
                    result = subprocess.call(["pip", "install", "-r", "requirements.txt"] + args)
            elif context["type"] == "nodejs":
                result = subprocess.call(["npm", "install"] + args)
            elif context["type"] == "go":
                result = subprocess.call(["go", "build"] + args)
            elif context["type"] == "rust":
                result = subprocess.call(["cargo", "build"] + args)
            else:
                print("❌ No build configuration detected in current directory")
                result = 1
            
            # Log usage
            execution_time = (datetime.now() - start_time).total_seconds()
            self.log_command_usage(f"build ({context['type']})", "smart", result == 0, execution_time, context["type"])
            
            return result
            
        except Exception as e:
            print(f"❌ Build failed: {e}")
            return 1
    
    def smart_test_command(self, args: List[str]):
        """Enhanced smart test"""
        context = self.detect_project_context()
        print(f"🧪 Running tests for {context['type']} project...")
        
        start_time = datetime.now()
        
        try:
            if context["type"] == "python":
                result = subprocess.call(["pytest"] + args)
            elif context["type"] == "nodejs":
                result = subprocess.call(["npm", "test"] + args)
            elif context["type"] == "go":
                result = subprocess.call(["go", "test"] + args)
            elif context["type"] == "rust":
                result = subprocess.call(["cargo", "test"] + args)
            else:
                print("❌ No test configuration detected in current directory")
                result = 1
            
            # Log usage
            execution_time = (datetime.now() - start_time).total_seconds()
            self.log_command_usage(f"test ({context['type']})", "smart", result == 0, execution_time, context["type"])
            
            return result
            
        except Exception as e:
            print(f"❌ Test failed: {e}")
            return 1
    
    def smart_deploy_command(self, args: List[str]):
        """Enhanced smart deploy"""
        if not self.check_permission("developer"):
            print("❌ Deploy command requires developer permission")
            return 1
        
        context = self.detect_project_context()
        print(f"🚀 Deploying {context['type']} project...")
        
        if context["framework"]:
            print(f"   Framework: {context['framework']}")
        
        # Simulate deployment process
        print("🔍 Checking deployment readiness...")
        print("✅ All checks passed")
        print("📦 Building production package...")
        print("🌐 Deploying to production...")
        print("✅ Deployment completed successfully")
        
        self.log_command_usage(f"deploy ({context['type']})", "smart", True, context=context["type"])
        return 0
    
    def smart_logs_command(self, args: List[str]):
        """Enhanced smart logs"""
        return self.execute_legacy_command("ai-logs", args)
    
    def show_help(self, args: List[str] = None):
        """Ultimate help system"""
        if args and len(args) > 0:
            category = args[0]
            if category in self.categories:
                self.show_category_help(category)
            else:
                print(f"❌ Unknown category: {category}")
                print(f"Available categories: {', '.join(self.categories.keys())}")
        else:
            print(f"""
🏛️ AI Command System v{self.version} - Ultimate Edition
エルダー評議会承認済み統一コマンド体系

👤 User: {getpass.getuser()} (Permission: {self.permission_level})

Usage: ai <command> [options]
       ai <category> <command> [options]

✨ New in v3.0:
  ask "<query>"      AI-powered natural language command finder
  interactive, i     Enter interactive mode
  chain "<commands>" Execute command chains
  stats              Show usage statistics
  plugins            Manage plugins
  docs               Access documentation

Smart Aliases (context-aware):
  build              Auto-detect and run build command
  test               Auto-detect and run test command
  deploy             Smart deployment
  logs               Show system logs
  learn              Learn from usage patterns

Special Commands:
  help, h, ?         Show this help
  version, v         Show version  
  find <query>       Find commands by keyword
  config             Manage configuration
  permissions        Show permission info

Categories:
""")
            for cat_id, cat_info in self.categories.items():
                if self.check_permission(cat_info["permission"]):
                    print(f"  {cat_id:<12} {cat_info['description']}")
                else:
                    print(f"  {cat_id:<12} {cat_info['description']} (❌ requires {cat_info['permission']})")
            
            # Show plugin commands
            if self.plugins:
                print(f"\n🔌 Plugin Commands:")
                for plugin_name, plugin in self.plugins.items():
                    for cmd_name, cmd_info in plugin['commands'].items():
                        if self.check_permission(cmd_info.get('permission', 'user')):
                            print(f"  {cmd_name:<12} {cmd_info['description']} (plugin: {plugin_name})")
            
            context = self.detect_project_context()
            if context["type"] != "unknown":
                print(f"\n🎯 Project Context: {context['type']}")
                if context["framework"]:
                    print(f"   Framework: {context['framework']}")
            
            print("""
Examples:
  ai status                    # システム状態確認
  ai ask "テストを実行したい"      # AI自然言語検索
  ai interactive               # 対話モード開始
  ai chain "build && test"     # コマンドチェーン実行
  ai elder settings            # エルダー設定表示
  ai config set ai_interactive true

For detailed help on a category:
  ai help <category>
""")
    
    def show_version(self, args: List[str] = None):
        """Enhanced version display"""
        print(f"AI Command System v{self.version} - Ultimate Edition")
        print("Elder Council Approved - 2025-07-09")
        print(f"Permission Level: {self.permission_level}")
        
        context = self.detect_project_context()
        if context["type"] != "unknown":
            print(f"Project Context: {context['type']} ({context['build_tool']})")
            if context["framework"]:
                print(f"Framework: {context['framework']}")
        
        print(f"Loaded Plugins: {len(self.plugins)}")
        
        # Show recent commands
        if self.command_history:
            print(f"Recent Commands: {len(self.command_history)}")
    
    def execute_legacy_command(self, script_name: str, args: List[str]):
        """Enhanced legacy execution with full logging"""
        script_path = self.scripts_dir / script_name
        
        if not script_path.exists():
            print(f"❌ Command not found: {script_name}")
            print(f"💡 Try: ai ask \"{script_name.replace('ai-', '')}を実行したい\"")
            return 1
        
        start_time = datetime.now()
        
        try:
            cmd = [str(script_path)] + args
            result = subprocess.call(cmd)
            
            # Log usage
            execution_time = (datetime.now() - start_time).total_seconds()
            self.log_command_usage(script_name, "legacy", result == 0, execution_time)
            
            return result
            
        except KeyboardInterrupt:
            print(f"\n⚠️ Command interrupted by user")
            return 130
        except PermissionError:
            print(f"❌ Permission denied: {script_name}")
            print(f"💡 Current permission level: {self.permission_level}")
            return 1
        except Exception as e:
            print(f"❌ Error executing command: {e}")
            print(f"💡 Try: ai ask \"{script_name.replace('ai-', '')}の問題を解決したい\"")
            return 1
    
    def run(self, args: List[str]):
        """Ultimate main entry point"""
        if not args:
            self.show_help()
            return 0
        
        # Check for plugin commands first
        for plugin_name, plugin in self.plugins.items():
            if args[0] in plugin['commands']:
                cmd_info = plugin['commands'][args[0]]
                if self.check_permission(cmd_info.get('permission', 'user')):
                    try:
                        return cmd_info['function'](args[1:])
                    except Exception as e:
                        print(f"❌ Plugin error: {e}")
                        return 1
                else:
                    print(f"❌ Plugin command '{args[0]}' requires {cmd_info.get('permission', 'user')} permission")
                    return 1
        
        # Check for smart aliases
        if self.user_config.get("enable_smart_aliases", True) and args[0] in self.smart_aliases:
            return self.smart_aliases[args[0]](args[1:])
        
        # Check for special commands
        if args[0] in self.aliases:
            return self.aliases[args[0]](args[1:]) or 0
        
        # Check for core commands
        if args[0] in self.categories['core']['commands']:
            cmd_info = self.categories['core']['commands'][args[0]]
            
            if not self.check_permission(cmd_info.get('permission', 'user')):
                print(f"❌ Command '{args[0]}' requires {cmd_info.get('permission', 'user')} permission")
                print(f"💡 Current level: {self.permission_level}")
                return 1
            
            if cmd_info['script']:
                return self.execute_legacy_command(cmd_info['script'], args[1:])
            else:
                # Built-in command
                return self.aliases.get(args[0], lambda x: 1)(args[1:]) or 0
        
        # Check for category commands
        if args[0] in self.categories:
            if len(args) < 2:
                self.show_category_help(args[0])
                return 0
            
            category = args[0]
            command = args[1]
            
            if not self.check_permission(self.categories[category]["permission"]):
                print(f"❌ Category '{category}' requires {self.categories[category]['permission']} permission")
                return 1
            
            if command in self.categories[category]['commands']:
                cmd_info = self.categories[category]['commands'][command]
                
                if not self.check_permission(cmd_info.get('permission', 'user')):
                    print(f"❌ Command '{category} {command}' requires {cmd_info.get('permission', 'user')} permission")
                    return 1
                
                return self.execute_legacy_command(cmd_info['script'], args[2:])
            else:
                print(f"❌ Unknown command in {category}: {command}")
                self.show_category_help(category)
                return 1
        
        # Legacy fallback with AI suggestions
        legacy_name = f"ai-{args[0]}"
        legacy_path = self.scripts_dir / legacy_name
        if legacy_path.exists():
            print(f"⚠️ Legacy command detected. Please use new syntax.")
            print(f"  Old: {legacy_name}")
            
            # Try to suggest new syntax
            for cat_id, cat_info in self.categories.items():
                for cmd_name, cmd_info in cat_info['commands'].items():
                    if cmd_info.get('script') == legacy_name:
                        if cat_id == 'core':
                            print(f"  New: ai {cmd_name}")
                        else:
                            print(f"  New: ai {cat_id} {cmd_name}")
                        break
            print()
            return self.execute_legacy_command(legacy_name, args[1:])
        
        # Unknown command with AI assistance
        print(f"❌ Unknown command: {args[0]}")
        print(f"💡 Try: ai ask \"{args[0]}を実行したい\" または ai help")
        
        # AI-powered suggestions
        suggestions = self.analyze_natural_language_query(args[0])
        if suggestions:
            print(f"\n🤖 AI Suggestions:")
            for cmd, confidence, reason in suggestions[:2]:
                print(f"  🔸 {cmd} (confidence: {confidence:.0%})")
        
        # Suggest similar commands
        similar = []
        for cat_id, cat_info in self.categories.items():
            if args[0] in cat_id:
                similar.append(f"ai help {cat_id}")
            for cmd_name in cat_info['commands']:
                if args[0] in cmd_name:
                    if cat_id == 'core':
                        similar.append(f"ai {cmd_name}")
                    else:
                        similar.append(f"ai {cat_id} {cmd_name}")
        
        if similar:
            print(f"🔍 Similar commands: {', '.join(similar[:3])}")
        
        return 1

def main():
    """メイン実行"""
    system = AICommandSystemV3()
    sys.exit(system.run(sys.argv[1:]))

if __name__ == "__main__":
    main()