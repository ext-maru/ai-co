#!/usr/bin/env python3
"""
AI Meeting to Code - ä¼šè­°éŒ²éŸ³ã‹ã‚‰ç›´æ¥ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
éŒ²éŸ³ â†’ æ–‡å­—èµ·ã“ã— â†’ Geminiè¦ç´„ â†’ AI Company â†’ ã‚³ãƒ¼ãƒ‰å®Œæˆ
"""

import sys
import os
import argparse
import json
import tempfile
from pathlib import Path
import logging
from datetime import datetime

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã‚’ãƒ‘ã‚¹ã«è¿½åŠ 
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

class MeetingToCodeProcessor:
    """ä¼šè­°ã‹ã‚‰ã‚³ãƒ¼ãƒ‰ã¸ã®å¤‰æ›ãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        logging.basicConfig(level=logging.INFO)
        
    def transcribe_audio(self, audio_file: str) -> str:
        """éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ–‡å­—èµ·ã“ã—ï¼ˆOpenAI Whisper APIä½¿ç”¨ï¼‰"""
        try:
            import openai
            
            self.logger.info(f"ğŸ“¼ éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ–‡å­—èµ·ã“ã—ä¸­: {audio_file}")
            
            with open(audio_file, 'rb') as audio:
                # OpenAI Whisper APIã‚’ä½¿ç”¨
                transcript = openai.Audio.transcribe(
                    model="whisper-1",
                    file=audio,
                    language="ja"  # æ—¥æœ¬èªæŒ‡å®š
                )
                
            text = transcript.text
            self.logger.info(f"âœ… æ–‡å­—èµ·ã“ã—å®Œäº† ({len(text)} æ–‡å­—)")
            return text
            
        except ImportError:
            self.logger.error("OpenAI package not installed. Run: pip install openai")
            return self._fallback_transcription(audio_file)
        except Exception as e:
            self.logger.error(f"æ–‡å­—èµ·ã“ã—ã‚¨ãƒ©ãƒ¼: {e}")
            return self._fallback_transcription(audio_file)
    
    def _fallback_transcription(self, audio_file: str) -> str:
        """ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ­ãƒ¼ã‚«ãƒ«ãƒ„ãƒ¼ãƒ«ã§æ–‡å­—èµ·ã“ã—"""
        try:
            # ffmpegã§WAVã«å¤‰æ› â†’ SpeechRecognitionã§å‡¦ç†
            import speech_recognition as sr
            
            recognizer = sr.Recognizer()
            
            # éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
            with sr.AudioFile(audio_file) as source:
                audio = recognizer.record(source)
            
            # Google Web Speech APIã§æ–‡å­—èµ·ã“ã—
            text = recognizer.recognize_google(audio, language='ja-JP')
            return text
            
        except Exception as e:
            self.logger.error(f"ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ–‡å­—èµ·ã“ã—ã‚‚å¤±æ•—: {e}")
            # æœ€å¾Œã®æ‰‹æ®µ: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«æ‰‹å‹•å…¥åŠ›ã‚’æ±‚ã‚ã‚‹
            print("\nâš ï¸  è‡ªå‹•æ–‡å­—èµ·ã“ã—ãŒå¤±æ•—ã—ã¾ã—ãŸ")
            print("ä¼šè­°ã®å†…å®¹ã‚’æ‰‹å‹•ã§å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆCtrl+D ã§çµ‚äº†ï¼‰:")
            
            lines = []
            try:
                while True:
                    line = input()
                    lines.append(line)
            except EOFError:
                pass
            
            return "\\n".join(lines)
    
    def summarize_with_gemini(self, transcript: str) -> dict:
        """Geminiã§ä¼šè­°å†…å®¹ã‚’è¦ç´„ãƒ»æ§‹é€ åŒ–"""
        try:
            import google.generativeai as genai
            
            self.logger.info("ğŸ¤– Geminiã§ä¼šè­°å†…å®¹ã‚’åˆ†æä¸­...")
            
            # Gemini APIã‚­ãƒ¼ã®è¨­å®š
            api_key = os.environ.get('GEMINI_API_KEY')
            if not api_key:
                raise ValueError("GEMINI_API_KEY environment variable not set")
            
            genai.configure(api_key=api_key)
            model = genai.GenerativeModel('gemini-pro')
            
            # è¦ç´„ãƒ»æ§‹é€ åŒ–ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
            prompt = f"""
ä¼šè­°ã®éŒ²éŸ³ã‚’æ–‡å­—èµ·ã“ã—ã—ãŸãƒ†ã‚­ã‚¹ãƒˆã‚’åˆ†æã—ã¦ã€é–‹ç™ºè¦ä»¶ã‚’æŠ½å‡ºã—ã¦ãã ã•ã„ã€‚

# ä¼šè­°å†…å®¹:
{transcript}

# å‡ºåŠ›å½¢å¼ï¼ˆJSONï¼‰:
{{
  "project_overview": "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æ¦‚è¦ï¼ˆ1-2æ–‡ï¼‰",
  "main_requirements": [
    "ä¸»è¦ãªæ©Ÿèƒ½è¦ä»¶1",
    "ä¸»è¦ãªæ©Ÿèƒ½è¦ä»¶2",
    "ä¸»è¦ãªæ©Ÿèƒ½è¦ä»¶3"
  ],
  "technical_specs": {{
    "framework": "ä½¿ç”¨æŠ€è¡“ãƒ»ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯",
    "database": "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¦ä»¶",
    "api_endpoints": ["å¿…è¦ãªAPIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ"],
    "ui_components": ["UI/UXã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ"]
  }},
  "user_stories": [
    "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ãƒˆãƒ¼ãƒªãƒ¼1",
    "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ãƒˆãƒ¼ãƒªãƒ¼2"
  ],
  "acceptance_criteria": [
    "å—ã‘å…¥ã‚ŒåŸºæº–1",
    "å—ã‘å…¥ã‚ŒåŸºæº–2"
  ],
  "priority": "high|medium|low",
  "deadline": "æœŸé™ãŒã‚ã‚Œã°æŠ½å‡º",
  "development_approach": "TDD|BDD|agileç­‰ã®é–‹ç™ºæ‰‹æ³•",
  "ai_company_tasks": [
    "AI Companyã«å®Ÿè¡Œã•ã›ã‚‹ã‚¿ã‚¹ã‚¯1",
    "AI Companyã«å®Ÿè¡Œã•ã›ã‚‹ã‚¿ã‚¹ã‚¯2"
  ]
}}

JSONã®ã¿ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚èª¬æ˜æ–‡ã¯ä¸è¦ã§ã™ã€‚
"""
            
            response = model.generate_content(prompt)
            
            # JSONãƒ‘ãƒ¼ã‚¹
            json_text = response.text.strip()
            if json_text.startswith('```json'):
                json_text = json_text.split('```json')[1].split('```')[0].strip()
            elif json_text.startswith('```'):
                json_text = json_text.split('```')[1].strip()
            
            requirements = json.loads(json_text)
            
            self.logger.info("âœ… Geminiåˆ†æå®Œäº†")
            return requirements
            
        except ImportError:
            self.logger.error("Google Generative AI package not installed. Run: pip install google-generativeai")
            return self._manual_requirements_input()
        except Exception as e:
            self.logger.error(f"Geminiåˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            return self._manual_requirements_input()
    
    def _manual_requirements_input(self) -> dict:
        """æ‰‹å‹•ã§è¦ä»¶ã‚’å…¥åŠ›"""
        print("\\nâš ï¸  è‡ªå‹•è¦ä»¶æŠ½å‡ºãŒå¤±æ•—ã—ã¾ã—ãŸ")
        print("é–‹ç™ºè¦ä»¶ã‚’æ‰‹å‹•ã§å…¥åŠ›ã—ã¦ãã ã•ã„:")
        
        overview = input("ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦: ")
        requirements = []
        
        print("ä¸»è¦æ©Ÿèƒ½ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆç©ºè¡Œã§çµ‚äº†ï¼‰:")
        while True:
            req = input("- ")
            if not req.strip():
                break
            requirements.append(req.strip())
        
        framework = input("ä½¿ç”¨ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ (fastapi/flask/django): ") or "fastapi"
        
        return {
            "project_overview": overview,
            "main_requirements": requirements,
            "technical_specs": {"framework": framework},
            "priority": "medium",
            "ai_company_tasks": requirements
        }
    
    def generate_code_with_aicompany(self, requirements: dict, output_dir: str) -> bool:
        """AI Companyã§ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ"""
        try:
            self.logger.info("ğŸ—ï¸  AI Companyã§ã‚³ãƒ¼ãƒ‰ç”Ÿæˆé–‹å§‹...")
            
            # å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
            output_path = Path(output_dir)
            output_path.mkdir(parents=True, exist_ok=True)
            
            # è¦ä»¶ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
            requirements_file = output_path / "requirements.json"
            with open(requirements_file, 'w', encoding='utf-8') as f:
                json.dump(requirements, f, indent=2, ensure_ascii=False)
            
            success_count = 0
            total_tasks = len(requirements.get('ai_company_tasks', []))
            
            # AI Companyã‚¿ã‚¹ã‚¯ã‚’é †æ¬¡å®Ÿè¡Œ
            for i, task in enumerate(requirements.get('ai_company_tasks', []), 1):
                self.logger.info(f"ğŸ“‹ ã‚¿ã‚¹ã‚¯ {i}/{total_tasks}: {task}")
                
                # AI Companyã«ã‚¿ã‚¹ã‚¯é€ä¿¡
                task_file = output_path / f"task_{i}.txt"
                with open(task_file, 'w', encoding='utf-8') as f:
                    f.write(f"""
# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: {requirements.get('project_overview', 'Unknown')}
# ã‚¿ã‚¹ã‚¯ {i}: {task}

## æŠ€è¡“ä»•æ§˜
- ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯: {requirements.get('technical_specs', {}).get('framework', 'fastapi')}
- é–‹ç™ºæ‰‹æ³•: TDD
- å„ªå…ˆåº¦: {requirements.get('priority', 'medium')}

## ã‚¿ã‚¹ã‚¯è©³ç´°
{task}

## å—ã‘å…¥ã‚ŒåŸºæº–
{chr(10).join('- ' + criteria for criteria in requirements.get('acceptance_criteria', []))}

## æŒ‡ç¤º
1. ã¾ãšãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’ä½œæˆ
2. ãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
3. æœ€å°é™ã®å®Ÿè£…ã§ãƒ†ã‚¹ãƒˆã‚’é€šã™
4. ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã—ã¦å“è³ªã‚’å‘ä¸Š
5. å…¨ä½“çš„ãªæ•´åˆæ€§ã‚’ç¢ºèª

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {output_dir}
""")
                
                # AI Companyå®Ÿè¡Œ
                import subprocess
                result = subprocess.run([
                    sys.executable, 
                    "scripts/ai-send-simple",
                    "--type", "code",
                    "--priority", "high",
                    task
                ], capture_output=True, text=True, cwd=str(Path(__file__).parent.parent))
                
                if result.returncode == 0:
                    success_count += 1
                    self.logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {i} é€ä¿¡å®Œäº†")
                else:
                    self.logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ {i} é€ä¿¡å¤±æ•—: {result.stderr}")
            
            # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚µãƒãƒªãƒ¼ç”Ÿæˆ
            self._generate_project_summary(requirements, output_path, success_count, total_tasks)
            
            self.logger.info(f"ğŸ‰ ã‚³ãƒ¼ãƒ‰ç”Ÿæˆå®Œäº†: {success_count}/{total_tasks} ã‚¿ã‚¹ã‚¯æˆåŠŸ")
            return success_count > 0
            
        except Exception as e:
            self.logger.error(f"AI Companyã‚³ãƒ¼ãƒ‰ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    def _generate_project_summary(self, requirements: dict, output_path: Path, 
                                success_count: int, total_tasks: int):
        """ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚µãƒãƒªãƒ¼ã‚’ç”Ÿæˆ"""
        summary = f"""# {requirements.get('project_overview', 'AI Generated Project')}

## ğŸ“‹ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦
{requirements.get('project_overview', 'N/A')}

## ğŸ¯ ä¸»è¦æ©Ÿèƒ½
{chr(10).join('- ' + req for req in requirements.get('main_requirements', []))}

## ğŸ› ï¸ æŠ€è¡“ä»•æ§˜
- **ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**: {requirements.get('technical_specs', {}).get('framework', 'N/A')}
- **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹**: {requirements.get('technical_specs', {}).get('database', 'N/A')}
- **é–‹ç™ºæ‰‹æ³•**: {requirements.get('development_approach', 'TDD')}

## âœ… ã‚¿ã‚¹ã‚¯å®Ÿè¡ŒçŠ¶æ³
- **æˆåŠŸ**: {success_count}/{total_tasks} ã‚¿ã‚¹ã‚¯
- **ç”Ÿæˆæ—¥æ™‚**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## ğŸš€ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—
1. AI Companyã®å®Ÿè¡Œçµæœã‚’ç¢ºèª
2. ç”Ÿæˆã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼
3. ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¦å“è³ªç¢ºèª
4. å¿…è¦ã«å¿œã˜ã¦è¿½åŠ é–‹ç™º

## ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ
```
{output_path.name}/
â”œâ”€â”€ requirements.json      # æŠ½å‡ºã•ã‚ŒãŸè¦ä»¶
â”œâ”€â”€ README.md             # ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«
â”œâ”€â”€ task_*.txt            # AI Companyã‚¿ã‚¹ã‚¯
â””â”€â”€ [ç”Ÿæˆã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰]      # AI Companyã®å‡ºåŠ›
```

---
*Generated by AI Meeting-to-Code System*
"""
        
        readme_file = output_path / "README.md"
        with open(readme_file, 'w', encoding='utf-8') as f:
            f.write(summary)
    
    def process_meeting(self, audio_file: str, output_dir: str) -> bool:
        """ä¼šè­°éŒ²éŸ³ã‹ã‚‰å®Œæˆã‚³ãƒ¼ãƒ‰ã¾ã§ã®å…¨ãƒ—ãƒ­ã‚»ã‚¹"""
        try:
            # ã‚¹ãƒ†ãƒƒãƒ—1: æ–‡å­—èµ·ã“ã—
            transcript = self.transcribe_audio(audio_file)
            if not transcript.strip():
                self.logger.error("æ–‡å­—èµ·ã“ã—çµæœãŒç©ºã§ã™")
                return False
            
            # ã‚¹ãƒ†ãƒƒãƒ—2: Geminiè¦ç´„
            requirements = self.summarize_with_gemini(transcript)
            if not requirements:
                self.logger.error("è¦ä»¶æŠ½å‡ºã«å¤±æ•—ã—ã¾ã—ãŸ")
                return False
            
            # ã‚¹ãƒ†ãƒƒãƒ—3: AI Companyã§ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
            success = self.generate_code_with_aicompany(requirements, output_dir)
            
            if success:
                print(f"\\nğŸ‰ ä¼šè­°ã‹ã‚‰ã‚³ãƒ¼ãƒ‰ã¸ã®å¤‰æ›ãŒå®Œäº†ã—ã¾ã—ãŸï¼")
                print(f"ğŸ“ å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {output_dir}")
                print(f"ğŸ“‹ è¦ä»¶ãƒ•ã‚¡ã‚¤ãƒ«: {output_dir}/requirements.json")
                print(f"ğŸ“– ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦: {output_dir}/README.md")
            
            return success
            
        except Exception as e:
            self.logger.error(f"ãƒ—ãƒ­ã‚»ã‚¹å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description='ä¼šè­°éŒ²éŸ³ã‹ã‚‰ç›´æ¥ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ä½¿ç”¨ä¾‹:
  # ä¼šè­°éŒ²éŸ³ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰
  ai-meeting-to-code meeting.mp4 --output ./my-project
  
  # ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ï¼ˆæ—¢ã«æ–‡å­—èµ·ã“ã—æ¸ˆã¿ï¼‰
  ai-meeting-to-code transcript.txt --text --output ./my-project
  
  # ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰
  ai-meeting-to-code --interactive --output ./my-project

ç’°å¢ƒå¤‰æ•°:
  OPENAI_API_KEY     - OpenAI API key (æ–‡å­—èµ·ã“ã—ç”¨)
  GEMINI_API_KEY     - Google Gemini API key (è¦ç´„ç”¨)
  ANTHROPIC_API_KEY  - Anthropic API key (AI Companyç”¨)
        """
    )
    
    parser.add_argument('input_file', nargs='?', help='éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«')
    parser.add_argument('--output', '-o', required=True, help='å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª')
    parser.add_argument('--text', action='store_true', help='å…¥åŠ›ãŒãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«')
    parser.add_argument('--interactive', '-i', action='store_true', help='ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰')
    
    args = parser.parse_args()
    
    processor = MeetingToCodeProcessor()
    
    if args.interactive:
        # ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰
        print("ğŸ¤ AI Meeting-to-Code ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰")
        print("ä¼šè­°ã®å†…å®¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆCtrl+D ã§çµ‚äº†ï¼‰:")
        
        lines = []
        try:
            while True:
                line = input()
                lines.append(line)
        except EOFError:
            pass
        
        transcript = "\\n".join(lines)
        
        # è¦ç´„ãƒ»ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
        requirements = processor.summarize_with_gemini(transcript)
        success = processor.generate_code_with_aicompany(requirements, args.output)
        
    elif args.input_file:
        if args.text:
            # ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰
            with open(args.input_file, 'r', encoding='utf-8') as f:
                transcript = f.read()
            
            requirements = processor.summarize_with_gemini(transcript)
            success = processor.generate_code_with_aicompany(requirements, args.output)
        else:
            # éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰
            success = processor.process_meeting(args.input_file, args.output)
    else:
        parser.print_help()
        return
    
    exit_code = 0 if success else 1
    sys.exit(exit_code)

if __name__ == "__main__":
    main()