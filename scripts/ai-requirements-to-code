#!/usr/bin/env python3
"""
AI Requirements to Code - è¦ä»¶JSONã‹ã‚‰ç›´æ¥ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
Geminiè¦ç´„çµæœã‚’å—ã‘å–ã£ã¦AI Companyã§å³åº§ã«é–‹ç™ºé–‹å§‹
"""

import sys
import os
import json
import argparse
from pathlib import Path

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã‚’ãƒ‘ã‚¹ã«è¿½åŠ 
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def load_requirements(requirements_file: str) -> dict:
    """è¦ä»¶JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿"""
    try:
        with open(requirements_file, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        print(f"âŒ è¦ä»¶ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å¤±æ•—: {e}")
        return None

def start_development(requirements: dict, output_dir: str, parallel: bool = False) -> bool:
    """AI Companyã§é–‹ç™ºé–‹å§‹"""
    try:
        import subprocess
        
        # å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        # è¦ä»¶ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
        requirements_file = output_path / "requirements.json"
        with open(requirements_file, 'w', encoding='utf-8') as f:
            json.dump(requirements, f, indent=2, ensure_ascii=False)
        
        tasks = requirements.get('ai_company_tasks', [])
        if not tasks:
            print("âŒ AI Companyã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return False
        
        print(f"ğŸš€ {len(tasks)}å€‹ã®ã‚¿ã‚¹ã‚¯ã§é–‹ç™ºé–‹å§‹...")
        
        if parallel:
            # ä¸¦åˆ—å®Ÿè¡Œ
            processes = []
            for i, task in enumerate(tasks, 1):
                print(f"ğŸ“‹ ã‚¿ã‚¹ã‚¯ {i} ä¸¦åˆ—å®Ÿè¡Œ: {task}")
                
                cmd = [
                    sys.executable,
                    "scripts/ai-send-simple", 
                    "--type", "code",
                    "--priority", "high",
                    f"ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: {requirements.get('project_overview', 'Unknown')}\\n\\n{task}\\n\\nå‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {output_dir}"
                ]
                
                process = subprocess.Popen(
                    cmd, 
                    cwd=str(Path(__file__).parent.parent),
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE
                )
                processes.append((i, task, process))
            
            # çµæœã‚’å¾…æ©Ÿ
            success_count = 0
            for i, task, process in processes:
                stdout, stderr = process.communicate()
                if process.returncode == 0:
                    print(f"âœ… ã‚¿ã‚¹ã‚¯ {i} é€ä¿¡å®Œäº†")
                    success_count += 1
                else:
                    print(f"âŒ ã‚¿ã‚¹ã‚¯ {i} é€ä¿¡å¤±æ•—: {stderr.decode()}")
        
        else:
            # é †æ¬¡å®Ÿè¡Œ
            success_count = 0
            for i, task in enumerate(tasks, 1):
                print(f"ğŸ“‹ ã‚¿ã‚¹ã‚¯ {i}/{len(tasks)}: {task}")
                
                # æŠ€è¡“ä»•æ§˜ã‚’å«ã‚ãŸè©³ç´°ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä½œæˆ
                detailed_prompt = f"""
ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: {requirements.get('project_overview', 'Unknown')}

# ã‚¿ã‚¹ã‚¯
{task}

# æŠ€è¡“ä»•æ§˜
- ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯: {requirements.get('technical_specs', {}).get('framework', 'fastapi')}
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹: {requirements.get('technical_specs', {}).get('database', 'postgresql')}
- é–‹ç™ºæ‰‹æ³•: TDD (ãƒ†ã‚¹ãƒˆé§†å‹•é–‹ç™º)

# å—ã‘å…¥ã‚ŒåŸºæº–
{chr(10).join('- ' + criteria for criteria in requirements.get('acceptance_criteria', []))}

# å‡ºåŠ›å…ˆ
{output_dir}

# æŒ‡ç¤º
1. TDDã§ãƒ†ã‚¹ãƒˆã‚’å…ˆã«ä½œæˆ
2. æœ€å°é™ã®å®Ÿè£…ã§ãƒ†ã‚¹ãƒˆã‚’é€šã™
3. æ®µéšçš„ã«ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
4. ä»–ã®ã‚¿ã‚¹ã‚¯ã¨ã®æ•´åˆæ€§ã‚’è€ƒæ…®
5. é©åˆ‡ãªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã§æ•´ç†
"""
                
                result = subprocess.run([
                    sys.executable,
                    "scripts/ai-send-simple",
                    "--type", "code", 
                    "--priority", "high",
                    detailed_prompt
                ], cwd=str(Path(__file__).parent.parent), capture_output=True, text=True)
                
                if result.returncode == 0:
                    print(f"âœ… ã‚¿ã‚¹ã‚¯ {i} é€ä¿¡å®Œäº†")
                    success_count += 1
                else:
                    print(f"âŒ ã‚¿ã‚¹ã‚¯ {i} é€ä¿¡å¤±æ•—: {result.stderr}")
        
        # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
        create_project_info(requirements, output_path, success_count, len(tasks))
        
        print(f"\\nğŸ‰ é–‹ç™ºã‚¿ã‚¹ã‚¯é€ä¿¡å®Œäº†: {success_count}/{len(tasks)} æˆåŠŸ")
        print(f"ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {output_dir}")
        print(f"ğŸ“‹ è¦ä»¶ãƒ•ã‚¡ã‚¤ãƒ«: {requirements_file}")
        
        return success_count > 0
        
    except Exception as e:
        print(f"âŒ é–‹ç™ºé–‹å§‹ã‚¨ãƒ©ãƒ¼: {e}")
        return False

def create_project_info(requirements: dict, output_path: Path, success_count: int, total_tasks: int):
    """ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ"""
    from datetime import datetime
    
    info = f"""# {requirements.get('project_overview', 'AI Generated Project')}

## ğŸ“‹ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦
{requirements.get('project_overview', 'N/A')}

## ğŸ¯ ä¸»è¦æ©Ÿèƒ½
{chr(10).join('- ' + req for req in requirements.get('main_requirements', []))}

## ğŸ› ï¸ æŠ€è¡“ä»•æ§˜
- **ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**: {requirements.get('technical_specs', {}).get('framework', 'N/A')}
- **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹**: {requirements.get('technical_specs', {}).get('database', 'N/A')}
- **é–‹ç™ºæ‰‹æ³•**: TDD

## âœ… é–‹ç™ºã‚¿ã‚¹ã‚¯çŠ¶æ³
- **é€ä¿¡æ¸ˆã¿**: {success_count}/{total_tasks} ã‚¿ã‚¹ã‚¯
- **é–‹å§‹æ—¥æ™‚**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## ğŸ“‹ å®Ÿè¡Œã‚¿ã‚¹ã‚¯ä¸€è¦§
{chr(10).join(f'{i}. {task}' for i, task in enumerate(requirements.get('ai_company_tasks', []), 1))}

## ğŸš€ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—
1. AI Companyã®å‡¦ç†ã‚’ç¢ºèª: `./scripts/ai-status`
2. ç”Ÿæˆã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼
3. ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ: `pytest`
4. è¿½åŠ è¦ä»¶ãŒã‚ã‚Œã°è¿½åŠ é–‹ç™º

## ğŸ“Š é€²æ—ç¢ºèªæ–¹æ³•
```bash
# ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ç¢ºèª
./scripts/ai-status

# ãƒ­ã‚°ç›£è¦–
tail -f logs/simple_task_worker.log

# ã‚­ãƒ¥ãƒ¼çŠ¶æ³ç¢ºèª
./scripts/ai-status | grep "queue:"
```

---
*Generated by AI Requirements-to-Code System*
"""
    
    readme_file = output_path / "PROJECT_INFO.md"
    with open(readme_file, 'w', encoding='utf-8') as f:
        f.write(info)

def main():
    parser = argparse.ArgumentParser(
        description='è¦ä»¶JSONã‹ã‚‰AI Companyã§ç›´æ¥é–‹ç™ºé–‹å§‹',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ä½¿ç”¨ä¾‹:
  # è¦ä»¶JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰é–‹ç™ºé–‹å§‹
  ai-requirements-to-code requirements.json --output ./my-project
  
  # ä¸¦åˆ—å®Ÿè¡Œã§ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—
  ai-requirements-to-code requirements.json --output ./my-project --parallel
  
  # ç‰¹å®šã®ã‚¿ã‚¹ã‚¯ã®ã¿å®Ÿè¡Œ
  ai-requirements-to-code requirements.json --output ./my-project --tasks 1,3,5

è¦ä»¶JSONãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ:
  {
    "project_overview": "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦",
    "main_requirements": ["è¦ä»¶1", "è¦ä»¶2"],
    "technical_specs": {
      "framework": "fastapi",
      "database": "postgresql"
    },
    "ai_company_tasks": [
      "ã‚¿ã‚¹ã‚¯1ã®è©³ç´°èª¬æ˜",
      "ã‚¿ã‚¹ã‚¯2ã®è©³ç´°èª¬æ˜"
    ]
  }
        """
    )
    
    parser.add_argument('requirements_file', help='è¦ä»¶JSONãƒ•ã‚¡ã‚¤ãƒ«')
    parser.add_argument('--output', '-o', required=True, help='å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª')
    parser.add_argument('--parallel', '-p', action='store_true', help='ã‚¿ã‚¹ã‚¯ã‚’ä¸¦åˆ—å®Ÿè¡Œ')
    parser.add_argument('--tasks', '-t', help='å®Ÿè¡Œã™ã‚‹ã‚¿ã‚¹ã‚¯ç•ªå· (ä¾‹: 1,3,5)')
    parser.add_argument('--dry-run', action='store_true', help='å®Ÿéš›ã«å®Ÿè¡Œã›ãšã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®ã¿')
    
    args = parser.parse_args()
    
    # è¦ä»¶èª­ã¿è¾¼ã¿
    requirements = load_requirements(args.requirements_file)
    if not requirements:
        sys.exit(1)
    
    # ã‚¿ã‚¹ã‚¯ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    if args.tasks:
        try:
            task_indices = [int(x.strip()) - 1 for x in args.tasks.split(',')]
            all_tasks = requirements.get('ai_company_tasks', [])
            filtered_tasks = [all_tasks[i] for i in task_indices if 0 <= i < len(all_tasks)]
            requirements['ai_company_tasks'] = filtered_tasks
            print(f"ğŸ¯ é¸æŠã•ã‚ŒãŸã‚¿ã‚¹ã‚¯: {len(filtered_tasks)}å€‹")
        except Exception as e:
            print(f"âŒ ã‚¿ã‚¹ã‚¯ç•ªå·ã®è§£æã‚¨ãƒ©ãƒ¼: {e}")
            sys.exit(1)
    
    # ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰
    if args.dry_run:
        print(f"ğŸ“‹ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: {requirements.get('project_overview', 'Unknown')}")
        print(f"ğŸ“ å‡ºåŠ›å…ˆ: {args.output}")
        print(f"ğŸ“Š å®Ÿè¡Œäºˆå®šã‚¿ã‚¹ã‚¯: {len(requirements.get('ai_company_tasks', []))}å€‹")
        print("\\nğŸ¯ ã‚¿ã‚¹ã‚¯ä¸€è¦§:")
        for i, task in enumerate(requirements.get('ai_company_tasks', []), 1):
            print(f"  {i}. {task}")
        print("\\nâ€» å®Ÿéš›ã®å®Ÿè¡Œã¯ --dry-run ã‚’å¤–ã—ã¦ãã ã•ã„")
        return
    
    # é–‹ç™ºé–‹å§‹
    success = start_development(requirements, args.output, args.parallel)
    
    if success:
        print(f"\\nğŸ‰ é–‹ç™ºãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸï¼")
        print(f"ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: {args.output}")
        print(f"ğŸ“Š çŠ¶æ…‹ç¢ºèª: ./scripts/ai-status")
    else:
        print("âŒ é–‹ç™ºé–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ")
        sys.exit(1)

if __name__ == "__main__":
    main()