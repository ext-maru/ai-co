#!/usr/bin/env python3
"""
AI Command System v2.1 - Enhanced Edition
Phase 2: é«˜åº¦ãªæ©Ÿèƒ½ã‚’çµ±åˆã—ãŸå®Œå…¨ç‰ˆ
"""

import sys
import os
import json
import subprocess
import re
from pathlib import Path
from typing import List, Dict, Optional, Tuple
from datetime import datetime
import pwd
import getpass

class AICommandSystemV2:
    """AIçµ±åˆã‚³ãƒãƒ³ãƒ‰ã‚·ã‚¹ãƒ†ãƒ  v2.1"""
    
    def __init__(self):
        self.scripts_dir = Path("/home/aicompany/ai_co/scripts")
        self.config_dir = Path.home() / ".ai-config"
        self.config_dir.mkdir(exist_ok=True)
        self.version = "2.1.0"
        
        self.user_config = self.load_user_config()
        self.permission_level = self.detect_permission_level()
        
        # Enhanced categories with permission levels
        self.categories = {
            "core": {
                "name": "Core Commands",
                "description": "åŸºæœ¬ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒãƒ³ãƒ‰",
                "permission": "user",
                "commands": {
                    "start": {"script": "ai-start", "desc": "ã‚·ã‚¹ãƒ†ãƒ èµ·å‹•", "permission": "developer"},
                    "stop": {"script": "ai-stop", "desc": "ã‚·ã‚¹ãƒ†ãƒ åœæ­¢", "permission": "developer"},
                    "status": {"script": "ai-status", "desc": "ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ç¢ºèª", "permission": "user"},
                    "env": {"script": "ai-env", "desc": "ç’°å¢ƒè¨­å®š", "permission": "user"},
                    "config": {"script": None, "desc": "è¨­å®šç®¡ç†", "permission": "user"}
                }
            },
            "elder": {
                "name": "Elder Management",
                "description": "ã‚¨ãƒ«ãƒ€ãƒ¼ç®¡ç†æ©Ÿèƒ½",
                "permission": "elder",
                "commands": {
                    "status": {"script": "ai-elder", "desc": "ã‚¨ãƒ«ãƒ€ãƒ¼çŠ¶æ…‹ç¢ºèª", "permission": "elder"},
                    "council": {"script": "ai-elder-council", "desc": "è©•è­°ä¼šç®¡ç†", "permission": "elder"},
                    "settings": {"script": "ai-elder-settings", "desc": "è¨­å®šè¡¨ç¤º", "permission": "user"},
                    "tree": {"script": "ai-elder-tree", "desc": "ã‚¨ãƒ«ãƒ€ãƒ¼ãƒ„ãƒªãƒ¼è¡¨ç¤º", "permission": "user"},
                    "compliance": {"script": "ai-elder-compliance", "desc": "ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹", "permission": "elder"},
                    "servant": {"script": "ai-servant", "desc": "ã‚µãƒ¼ãƒãƒ³ãƒˆç®¡ç†", "permission": "elder"}
                }
            },
            "worker": {
                "name": "Worker Management", 
                "description": "ãƒ¯ãƒ¼ã‚«ãƒ¼ç®¡ç†",
                "permission": "developer",
                "commands": {
                    "status": {"script": "ai-worker-comm", "desc": "ãƒ¯ãƒ¼ã‚«ãƒ¼é€šä¿¡çŠ¶æ…‹", "permission": "developer"},
                    "recovery": {"script": "ai-worker-recovery", "desc": "ãƒ¯ãƒ¼ã‚«ãƒ¼å¾©æ—§", "permission": "developer"},
                    "dlq": {"script": "ai-dlq", "desc": "DLQç®¡ç†", "permission": "developer"}
                }
            },
            "dev": {
                "name": "Development Tools",
                "description": "é–‹ç™ºãƒ„ãƒ¼ãƒ«",
                "permission": "developer",
                "commands": {
                    "codegen": {"script": "ai-codegen", "desc": "ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ", "permission": "developer"},
                    "document": {"script": "ai-document", "desc": "ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆç”Ÿæˆ", "permission": "developer"},
                    "git": {"script": "ai-git", "desc": "Gitçµ±åˆ", "permission": "developer"},
                    "tdd": {"script": "ai-tdd", "desc": "TDDé–‹ç™º", "permission": "developer"}
                }
            },
            "test": {
                "name": "Testing Tools",
                "description": "ãƒ†ã‚¹ãƒˆãƒ„ãƒ¼ãƒ«", 
                "permission": "developer",
                "commands": {
                    "coverage": {"script": "ai-test-coverage", "desc": "ã‚«ãƒãƒ¬ãƒƒã‚¸åˆ†æ", "permission": "developer"},
                    "quality": {"script": "ai-test-quality", "desc": "å“è³ªåˆ†æ", "permission": "developer"},
                    "runner": {"script": "ai-test-runner", "desc": "ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ", "permission": "developer"},
                    "magic": {"script": "ai-elf-test-magic", "desc": "ã‚¨ãƒ«ãƒ•ãƒ†ã‚¹ãƒˆé­”æ³•", "permission": "developer"}
                }
            },
            "ops": {
                "name": "Operations",
                "description": "é‹ç”¨ãƒ„ãƒ¼ãƒ«",
                "permission": "admin",
                "commands": {
                    "dashboard": {"script": "ai-dashboard", "desc": "ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰", "permission": "developer"},
                    "api-status": {"script": "ai-api-status", "desc": "APIçŠ¶æ…‹", "permission": "user"},
                    "api-health": {"script": "ai-api-health", "desc": "APIãƒ˜ãƒ«ã‚¹", "permission": "user"},
                    "api-reset": {"script": "ai-api-reset", "desc": "APIãƒªã‚»ãƒƒãƒˆ", "permission": "admin"}
                }
            },
            "monitor": {
                "name": "Monitoring",
                "description": "ç›£è¦–ãƒ»ãƒ­ã‚°",
                "permission": "developer",
                "commands": {
                    "logs": {"script": "ai-logs", "desc": "ãƒ­ã‚°è¡¨ç¤º", "permission": "developer"},
                    "proactive": {"script": "ai-elder-proactive-monitor", "desc": "äºˆé˜²çš„ç›£è¦–", "permission": "developer"}
                }
            },
            "integrate": {
                "name": "Integrations",
                "description": "å¤–éƒ¨é€£æº",
                "permission": "developer", 
                "commands": {
                    "slack": {"script": "ai-slack", "desc": "Slackçµ±åˆ", "permission": "developer"},
                    "mcp": {"script": "ai-mcp", "desc": "MCPçµ±åˆ", "permission": "developer"},
                    "send": {"script": "ai-send", "desc": "ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡", "permission": "developer"}
                }
            }
        }
        
        # Enhanced aliases with smart context detection
        self.smart_aliases = {
            "build": self.smart_build_command,
            "test": self.smart_test_command,
            "deploy": self.smart_deploy_command,
            "logs": self.smart_logs_command
        }
        
        # Basic aliases
        self.aliases = {
            "help": self.show_help,
            "h": self.show_help,
            "?": self.show_help,
            "version": self.show_version,
            "v": self.show_version,
            "find": self.find_command,
            "search": self.find_command,
            "config": self.manage_config,
            "permissions": self.show_permissions
        }
    
    def load_user_config(self) -> Dict:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã‚’ãƒ­ãƒ¼ãƒ‰"""
        config_file = self.config_dir / "config.json"
        default_config = {
            "aliases": {},
            "permission_level": "auto",
            "preferred_style": "standard",
            "enable_smart_aliases": True
        }
        
        if config_file.exists():
            try:
                with open(config_file, 'r', encoding='utf-8') as f:
                    return {**default_config, **json.load(f)}
            except:
                pass
        
        return default_config
    
    def save_user_config(self):
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã‚’ä¿å­˜"""
        config_file = self.config_dir / "config.json"
        with open(config_file, 'w', encoding='utf-8') as f:
            json.dump(self.user_config, f, ensure_ascii=False, indent=2)
    
    def detect_permission_level(self) -> str:
        """æ¨©é™ãƒ¬ãƒ™ãƒ«ã‚’è‡ªå‹•æ¤œå‡º"""
        if self.user_config.get("permission_level") != "auto":
            return self.user_config["permission_level"]
        
        current_user = getpass.getuser()
        
        # Admin detection
        if current_user == "root" or current_user == "aicompany":
            return "admin"
        
        # Elder detection (AI Company developers)
        elder_users = ["claude", "maru", "elder"]
        if current_user in elder_users:
            return "elder"
        
        # Developer detection (in development groups)
        try:
            user_groups = [g.gr_name for g in pwd.getpwnam(current_user).pw_gid]
            dev_groups = ["developers", "devs", "sudo", "wheel"]
            if any(group in dev_groups for group in user_groups):
                return "developer"
        except:
            pass
        
        return "user"
    
    def check_permission(self, required_level: str) -> bool:
        """æ¨©é™ãƒã‚§ãƒƒã‚¯"""
        levels = ["user", "developer", "elder", "admin"]
        user_level_idx = levels.index(self.permission_level)
        required_level_idx = levels.index(required_level)
        return user_level_idx >= required_level_idx
    
    def detect_project_context(self) -> Dict[str, str]:
        """ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æ¤œå‡º"""
        cwd = Path.cwd()
        context = {"type": "unknown", "build_tool": None, "test_tool": None}
        
        # Python project
        if (cwd / "requirements.txt").exists() or (cwd / "pyproject.toml").exists():
            context["type"] = "python"
            context["build_tool"] = "pip" if (cwd / "requirements.txt").exists() else "poetry"
            context["test_tool"] = "pytest"
        
        # Node.js project
        elif (cwd / "package.json").exists():
            context["type"] = "nodejs"
            context["build_tool"] = "npm"
            context["test_tool"] = "npm"
        
        # Go project
        elif (cwd / "go.mod").exists():
            context["type"] = "go"
            context["build_tool"] = "go"
            context["test_tool"] = "go"
        
        # Rust project
        elif (cwd / "Cargo.toml").exists():
            context["type"] = "rust"
            context["build_tool"] = "cargo"
            context["test_tool"] = "cargo"
        
        return context
    
    def smart_build_command(self, args: List[str]):
        """ã‚¹ãƒãƒ¼ãƒˆãƒ“ãƒ«ãƒ‰ã‚³ãƒãƒ³ãƒ‰"""
        context = self.detect_project_context()
        
        if context["type"] == "python":
            if context["build_tool"] == "poetry":
                return subprocess.call(["poetry", "install"] + args)
            else:
                return subprocess.call(["pip", "install", "-r", "requirements.txt"] + args)
        elif context["type"] == "nodejs":
            return subprocess.call(["npm", "install"] + args)
        elif context["type"] == "go":
            return subprocess.call(["go", "build"] + args)
        elif context["type"] == "rust":
            return subprocess.call(["cargo", "build"] + args)
        else:
            print("âŒ No build configuration detected in current directory")
            return 1
    
    def smart_test_command(self, args: List[str]):
        """ã‚¹ãƒãƒ¼ãƒˆãƒ†ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰"""
        context = self.detect_project_context()
        
        if context["type"] == "python":
            return subprocess.call(["pytest"] + args)
        elif context["type"] == "nodejs":
            return subprocess.call(["npm", "test"] + args)
        elif context["type"] == "go":
            return subprocess.call(["go", "test"] + args)
        elif context["type"] == "rust":
            return subprocess.call(["cargo", "test"] + args)
        else:
            print("âŒ No test configuration detected in current directory")
            return 1
    
    def smart_deploy_command(self, args: List[str]):
        """ã‚¹ãƒãƒ¼ãƒˆãƒ‡ãƒ—ãƒ­ã‚¤ã‚³ãƒãƒ³ãƒ‰"""
        if not self.check_permission("developer"):
            print("âŒ Deploy command requires developer permission")
            return 1
        
        context = self.detect_project_context()
        print(f"ğŸš€ Deploying {context['type']} project...")
        
        # This would integrate with actual deployment systems
        print("Deploy functionality coming soon...")
        return 0
    
    def smart_logs_command(self, args: List[str]):
        """ã‚¹ãƒãƒ¼ãƒˆãƒ­ã‚°ã‚³ãƒãƒ³ãƒ‰"""
        return self.execute_legacy_command("ai-logs", args)
    
    def show_permissions(self, args: List[str] = None):
        """æ¨©é™æƒ…å ±è¡¨ç¤º"""
        print(f"\nğŸ‘¤ Current User: {getpass.getuser()}")
        print(f"ğŸ”’ Permission Level: {self.permission_level}")
        print("\nğŸ“‹ Permission Levels:")
        print("  user      - Basic commands only")
        print("  developer - Development tools included")
        print("  elder     - Elder management included")
        print("  admin     - All commands available")
        
        print(f"\nâœ… Available Categories:")
        for cat_id, cat_info in self.categories.items():
            if self.check_permission(cat_info["permission"]):
                print(f"  {cat_id:<12} {cat_info['description']}")
            else:
                print(f"  {cat_id:<12} {cat_info['description']} (âŒ requires {cat_info['permission']})")
    
    def manage_config(self, args: List[str]):
        """è¨­å®šç®¡ç†"""
        if not args:
            print(f"\nâš™ï¸ AI Command System Configuration")
            print(f"Config location: {self.config_dir / 'config.json'}")
            print(f"\nCurrent settings:")
            for key, value in self.user_config.items():
                print(f"  {key}: {value}")
            print(f"\nUsage:")
            print(f"  ai config set <key> <value>")
            print(f"  ai config get <key>")
            print(f"  ai config reset")
            return 0
        
        if args[0] == "set" and len(args) >= 3:
            key, value = args[1], args[2]
            # Type conversion
            if value.lower() in ['true', 'false']:
                value = value.lower() == 'true'
            elif value.isdigit():
                value = int(value)
            
            self.user_config[key] = value
            self.save_user_config()
            print(f"âœ… Set {key} = {value}")
            
        elif args[0] == "get" and len(args) >= 2:
            key = args[1]
            print(f"{key}: {self.user_config.get(key, 'Not set')}")
            
        elif args[0] == "reset":
            self.user_config = {
                "aliases": {},
                "permission_level": "auto",
                "preferred_style": "standard",
                "enable_smart_aliases": True
            }
            self.save_user_config()
            print("âœ… Configuration reset to defaults")
        
        return 0
    
    def show_help(self, args: List[str] = None):
        """Enhanced help display"""
        if args and len(args) > 0:
            category = args[0]
            if category in self.categories:
                self.show_category_help(category)
            else:
                print(f"âŒ Unknown category: {category}")
                print(f"Available categories: {', '.join(self.categories.keys())}")
        else:
            print(f"""
ğŸ›ï¸ AI Command System v{self.version} - Enhanced Edition
ã‚¨ãƒ«ãƒ€ãƒ¼è©•è­°ä¼šæ‰¿èªæ¸ˆã¿çµ±ä¸€ã‚³ãƒãƒ³ãƒ‰ä½“ç³»

ğŸ‘¤ User: {getpass.getuser()} (Permission: {self.permission_level})

Usage: ai <command> [options]
       ai <category> <command> [options]

Special Commands:
  help, h, ?         Show this help
  version, v         Show version  
  find <query>       Find commands by keyword
  config             Manage configuration
  permissions        Show permission info

Smart Aliases (context-aware):
  build              Auto-detect and run build command
  test               Auto-detect and run test command
  deploy             Smart deployment
  logs               Show system logs

Categories:
""")
            for cat_id, cat_info in self.categories.items():
                if self.check_permission(cat_info["permission"]):
                    print(f"  {cat_id:<12} {cat_info['description']}")
                else:
                    print(f"  {cat_id:<12} {cat_info['description']} (âŒ requires {cat_info['permission']})")
            
            print("""
Examples:
  ai status              # ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ç¢ºèª
  ai elder settings      # ã‚¨ãƒ«ãƒ€ãƒ¼è¨­å®šè¡¨ç¤º
  ai build               # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ“ãƒ«ãƒ‰ï¼ˆè‡ªå‹•æ¤œå‡ºï¼‰
  ai test                # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œï¼ˆè‡ªå‹•æ¤œå‡ºï¼‰
  ai find "coverage"     # ã‚«ãƒãƒ¬ãƒƒã‚¸é–¢é€£ã‚³ãƒãƒ³ãƒ‰ã‚’æ¤œç´¢
  ai config set enable_smart_aliases true

For detailed help on a category:
  ai help <category>
""")
    
    def show_category_help(self, category: str):
        """Enhanced category help"""
        if not self.check_permission(self.categories[category]["permission"]):
            print(f"âŒ Category '{category}' requires {self.categories[category]['permission']} permission")
            return
        
        cat_info = self.categories[category]
        print(f"\nğŸ“ {cat_info['name']}")
        print(f"{cat_info['description']}\n")
        print("Commands:")
        
        for cmd_name, cmd_info in cat_info['commands'].items():
            if self.check_permission(cmd_info.get('permission', 'user')):
                if category == 'core':
                    usage = f"ai {cmd_name}"
                else:
                    usage = f"ai {category} {cmd_name}"
                print(f"  {usage:<30} {cmd_info['desc']}")
            else:
                if category == 'core':
                    usage = f"ai {cmd_name}"
                else:
                    usage = f"ai {category} {cmd_name}"
                print(f"  {usage:<30} {cmd_info['desc']} (âŒ requires {cmd_info.get('permission', 'user')})")
        print()
    
    def show_version(self, args: List[str] = None):
        """Enhanced version display"""
        print(f"AI Command System v{self.version} - Enhanced Edition")
        print("Elder Council Approved - 2025-07-09")
        print(f"Permission Level: {self.permission_level}")
        
        context = self.detect_project_context()
        if context["type"] != "unknown":
            print(f"Project Context: {context['type']} ({context['build_tool']})")
    
    def find_command(self, args: List[str]):
        """Enhanced command search"""
        if not args:
            print("Usage: ai find <query>")
            return
        
        query = ' '.join(args).lower()
        results = []
        
        # Search in all accessible categories
        for cat_id, cat_info in self.categories.items():
            if not self.check_permission(cat_info["permission"]):
                continue
                
            # Check category name/description
            if query in cat_info['name'].lower() or query in cat_info['description'].lower():
                results.append(f"Category: {cat_id} - {cat_info['description']}")
            
            # Check commands
            for cmd_name, cmd_info in cat_info['commands'].items():
                if not self.check_permission(cmd_info.get('permission', 'user')):
                    continue
                    
                if query in cmd_name.lower() or query in cmd_info['desc'].lower():
                    if cat_id == 'core':
                        usage = f"ai {cmd_name}"
                    else:
                        usage = f"ai {cat_id} {cmd_name}"
                    results.append(f"{usage:<30} {cmd_info['desc']}")
        
        # Search smart aliases
        for alias, _ in self.smart_aliases.items():
            if query in alias.lower():
                results.append(f"ai {alias:<27} Smart context-aware command")
        
        if results:
            print(f"\nğŸ” Found {len(results)} matches for '{query}':\n")
            for result in results:
                print(f"  {result}")
            print()
        else:
            print(f"âŒ No accessible commands found matching '{query}'")
    
    def execute_legacy_command(self, script_name: str, args: List[str]):
        """Enhanced legacy command execution with error handling"""
        script_path = self.scripts_dir / script_name
        
        if not script_path.exists():
            print(f"âŒ Command not found: {script_name}")
            print(f"ğŸ’¡ Try: ai find \"{script_name.replace('ai-', '')}\"")
            return 1
        
        try:
            cmd = [str(script_path)] + args
            return subprocess.call(cmd)
        except KeyboardInterrupt:
            print(f"\nâš ï¸ Command interrupted by user")
            return 130
        except PermissionError:
            print(f"âŒ Permission denied: {script_name}")
            print(f"ğŸ’¡ Current permission level: {self.permission_level}")
            return 1
        except Exception as e:
            print(f"âŒ Error executing command: {e}")
            print(f"ğŸ’¡ Try: ai help or ai find \"{script_name.replace('ai-', '')}\"")
            return 1
    
    def run(self, args: List[str]):
        """Enhanced main entry point"""
        if not args:
            self.show_help()
            return 0
        
        # Check for smart aliases first
        if self.user_config.get("enable_smart_aliases", True) and args[0] in self.smart_aliases:
            return self.smart_aliases[args[0]](args[1:])
        
        # Check for special commands
        if args[0] in self.aliases:
            self.aliases[args[0]](args[1:])
            return 0
        
        # Check for core commands
        if args[0] in self.categories['core']['commands']:
            cmd_info = self.categories['core']['commands'][args[0]]
            
            if not self.check_permission(cmd_info.get('permission', 'user')):
                print(f"âŒ Command '{args[0]}' requires {cmd_info.get('permission', 'user')} permission")
                print(f"ğŸ’¡ Current level: {self.permission_level}")
                return 1
            
            if cmd_info['script']:
                return self.execute_legacy_command(cmd_info['script'], args[1:])
            else:
                # Built-in command
                return self.aliases.get(args[0], lambda x: 1)(args[1:])
        
        # Check for category commands
        if args[0] in self.categories:
            if len(args) < 2:
                self.show_category_help(args[0])
                return 0
            
            category = args[0]
            command = args[1]
            
            if not self.check_permission(self.categories[category]["permission"]):
                print(f"âŒ Category '{category}' requires {self.categories[category]['permission']} permission")
                return 1
            
            if command in self.categories[category]['commands']:
                cmd_info = self.categories[category]['commands'][command]
                
                if not self.check_permission(cmd_info.get('permission', 'user')):
                    print(f"âŒ Command '{category} {command}' requires {cmd_info.get('permission', 'user')} permission")
                    return 1
                
                return self.execute_legacy_command(cmd_info['script'], args[2:])
            else:
                print(f"âŒ Unknown command in {category}: {command}")
                self.show_category_help(category)
                return 1
        
        # Legacy fallback with helpful suggestions
        legacy_name = f"ai-{args[0]}"
        legacy_path = self.scripts_dir / legacy_name
        if legacy_path.exists():
            print(f"âš ï¸ Legacy command detected. Please use new syntax.")
            print(f"  Old: {legacy_name}")
            
            # Try to suggest new syntax
            for cat_id, cat_info in self.categories.items():
                for cmd_name, cmd_info in cat_info['commands'].items():
                    if cmd_info.get('script') == legacy_name:
                        if cat_id == 'core':
                            print(f"  New: ai {cmd_name}")
                        else:
                            print(f"  New: ai {cat_id} {cmd_name}")
                        break
            print()
            return self.execute_legacy_command(legacy_name, args[1:])
        
        # Unknown command with suggestions
        print(f"âŒ Unknown command: {args[0]}")
        print(f"ğŸ’¡ Try: ai find \"{args[0]}\" or ai help")
        
        # Suggest similar commands
        similar = []
        for cat_id, cat_info in self.categories.items():
            if args[0] in cat_id:
                similar.append(f"ai help {cat_id}")
            for cmd_name in cat_info['commands']:
                if args[0] in cmd_name:
                    if cat_id == 'core':
                        similar.append(f"ai {cmd_name}")
                    else:
                        similar.append(f"ai {cat_id} {cmd_name}")
        
        if similar:
            print(f"ğŸ” Did you mean: {', '.join(similar[:3])}")
        
        return 1

def main():
    """ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œ"""
    system = AICommandSystemV2()
    sys.exit(system.run(sys.argv[1:]))

if __name__ == "__main__":
    main()