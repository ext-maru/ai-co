#!/usr/bin/env python3
"""
üåü Soul Process Manager - È≠Ç„Éó„É≠„Çª„ÇπÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†
================================================

Ë§áÊï∞„ÅÆÈ≠Ç„Éó„É≠„Çª„Çπ„ÅÆÁîüÊàê„ÄÅÁõ£Ë¶ñ„ÄÅÁÆ°ÁêÜ„ÇíË°å„ÅÜ‰∏≠Â§ÆÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†„ÄÇ
Elder TreeÈöéÂ±§„Å´Âü∫„Å•„ÅèÈ≠Ç„ÅÆËµ∑Âãï„ÉªÂÅúÊ≠¢„ÉªÂÅ•ÂÖ®ÊÄßÁõ£Ë¶ñ„ÇíÊèê‰æõ„ÄÇ

Author: Claude Elder
Created: 2025-01-19
"""

import asyncio
import json
import logging
import multiprocessing as mp
import os
import signal
import sys
import threading
import time
import uuid
from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor
from dataclasses import asdict, dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple, Union

import psutil

# „Éó„É≠„Ç∏„Çß„ÇØ„Éà„É´„Éº„Éà„Çí„Éë„Çπ„Å´ËøΩÂä†
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

from core.lightweight_logger import get_logger
from souls.a2a_communication_protocol import (
    A2ACommunicationProtocol,
    A2AMessage,
    MessageType,
    create_a2a_protocol,
)
from souls.base_soul import (
    BaseSoul,
    ElderType,
    SoulCapability,
    SoulIdentity,
    SoulState,
    create_soul_identity,
)

logger = get_logger("soul_process_manager")


class SoulProcessState(Enum):
    """È≠Ç„Éó„É≠„Çª„ÇπÁä∂ÊÖã"""

    CREATED = "created"  # ‰ΩúÊàêÊ∏à„Åø
    STARTING = "starting"  # Ëµ∑Âãï‰∏≠
    RUNNING = "running"  # ÂÆüË°å‰∏≠
    STOPPING = "stopping"  # ÂÅúÊ≠¢‰∏≠
    STOPPED = "stopped"  # ÂÅúÊ≠¢Ê∏à„Åø
    CRASHED = "crashed"  # „ÇØ„É©„ÉÉ„Ç∑„É•
    UNRESPONSIVE = "unresponsive"  # ÂøúÁ≠î„Å™„Åó


class ManagementAction(Enum):
    """ÁÆ°ÁêÜ„Ç¢„ÇØ„Ç∑„Éß„É≥"""

    START = "start"
    STOP = "stop"
    RESTART = "restart"
    HEALTH_CHECK = "health_check"
    KILL = "kill"
    PAUSE = "pause"
    RESUME = "resume"


@dataclass
class SoulProcessInfo:
    """È≠Ç„Éó„É≠„Çª„ÇπÊÉÖÂ†±"""

    soul_id: str
    soul_name: str
    elder_type: ElderType
    process_id: Optional[int] = None
    state: SoulProcessState = SoulProcessState.CREATED
    created_at: datetime = field(default_factory=datetime.now)
    started_at: Optional[datetime] = None
    stopped_at: Optional[datetime] = None
    last_heartbeat: Optional[datetime] = None
    restart_count: int = 0
    crash_count: int = 0
    cpu_usage: float = 0.0
    memory_usage: float = 0.0
    error_message: Optional[str] = None
    auto_restart: bool = True
    max_restarts: int = 3
    health_check_interval: int = 30
    a2a_port: Optional[int] = None
    capabilities: List[str] = field(default_factory=list)
    configuration: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """ËæûÊõ∏ÂΩ¢Âºè„Å´Â§âÊèõ"""
        data = asdict(self)
        data["elder_type"] = self.elder_type.value
        data["state"] = self.state.value
        data["created_at"] = self.created_at.isoformat() if self.created_at else None
        data["started_at"] = self.started_at.isoformat() if self.started_at else None
        data["stopped_at"] = self.stopped_at.isoformat() if self.stopped_at else None
        data["last_heartbeat"] = (
            self.last_heartbeat.isoformat() if self.last_heartbeat else None
        )
        return data

    def get_uptime(self) -> Optional[timedelta]:
        """Á®ºÂÉçÊôÇÈñì„ÇíÂèñÂæó"""
        if self.started_at and self.state == SoulProcessState.RUNNING:
            return datetime.now() - self.started_at
        return None

    def is_healthy(self) -> bool:
        """ÂÅ•ÂÖ®ÊÄß„ÉÅ„Çß„ÉÉ„ÇØ"""
        if self.state != SoulProcessState.RUNNING:
            return False

        if not self.last_heartbeat:
            return False

        # „Éè„Éº„Éà„Éì„Éº„Éà„Åå5ÂàÜ‰ª•ÂÜÖ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        heartbeat_threshold = datetime.now() - timedelta(minutes=5)
        return self.last_heartbeat > heartbeat_threshold


class SoulProcessManager:
    """È≠Ç„Éó„É≠„Çª„ÇπÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†"""

    def __init__(self, max_processes: int = None):
        self.max_processes = max_processes or mp.cpu_count() * 2
        self.processes: Dict[str, SoulProcessInfo] = {}
        self.running_processes: Dict[str, mp.Process] = {}
        self.a2a_protocols: Dict[str, A2ACommunicationProtocol] = {}

        self.manager_lock = threading.RLock()
        self.is_running = mp.Value("b", False)

        # ÁÆ°ÁêÜÁî®„Çπ„É¨„ÉÉ„Éâ„Éó„Éº„É´
        self.executor = ThreadPoolExecutor(max_workers=4)
        self.process_executor = ProcessPoolExecutor(max_workers=self.max_processes)

        # Áõ£Ë¶ñË®≠ÂÆö
        self.monitoring_interval = 10  # 10ÁßíÈñìÈöî
        self.health_check_timeout = 30  # 30Áßí„Çø„Ç§„É†„Ç¢„Ç¶„Éà

        # Áµ±Ë®àÊÉÖÂ†±
        self.stats = {
            "total_souls_created": 0,
            "total_souls_started": 0,
            "total_souls_stopped": 0,
            "total_crashes": 0,
            "total_restarts": 0,
            "start_time": datetime.now(),
        }

        self.logger = get_logger("soul_process_manager")

        # Elder TreeÈöéÂ±§ÂÆöÁæ©
        self.elder_hierarchy = {
            ElderType.GRAND_ELDER: {"level": 1, "max_instances": 1},
            ElderType.CLAUDE_ELDER: {"level": 2, "max_instances": 1},
            ElderType.ANCIENT_ELDER: {"level": 3, "max_instances": 1},
            ElderType.SAGE: {"level": 4, "max_instances": 4},  # 4Ë≥¢ËÄÖ
            ElderType.KNIGHT: {"level": 5, "max_instances": 8},
            ElderType.SERVANT: {"level": 6, "max_instances": 32},  # 32„Ç®„É´„ÉÄ„Éº„Çµ„Éº„Éê„É≥„Éà
        }

    async def start_manager(self) -> bool:
        """„Éó„É≠„Çª„ÇπÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†ÈñãÂßã"""
        try:
            self.is_running.value = True

            # Áõ£Ë¶ñ„É´„Éº„ÉóÈñãÂßã
            asyncio.create_task(self._monitoring_loop())

            # „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ„É´„Éº„ÉóÈñãÂßã
            asyncio.create_task(self._health_check_loop())

            # Áµ±Ë®àÂèéÈõÜ„É´„Éº„ÉóÈñãÂßã
            asyncio.create_task(self._statistics_loop())

            self.logger.info(
                f"üèõÔ∏è Soul Process Manager started (max_processes: {self.max_processes})"
            )
            return True

        except Exception as e:
            self.logger.error(f"‚ùå Failed to start Soul Process Manager: {e}")
            return False

    async def stop_manager(self):
        """„Éó„É≠„Çª„ÇπÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†ÂÅúÊ≠¢"""
        self.is_running.value = False

        # ÂÖ®È≠Ç„Éó„É≠„Çª„Çπ„ÇíÂÅúÊ≠¢
        await self.stop_all_souls()

        # „Çπ„É¨„ÉÉ„Éâ„Éó„Éº„É´ÂÅúÊ≠¢
        self.executor.shutdown(wait=True)
        self.process_executor.shutdown(wait=True)

        self.logger.info("üåÖ Soul Process Manager stopped")

    def register_soul(
        self,
        soul_identity: SoulIdentity,
        auto_restart: bool = True,
        max_restarts: int = 3,
        configuration: Dict[str, Any] = None,
    ) -> str:
        """È≠Ç„ÇíÁôªÈå≤"""
        with self.manager_lock:
            # Êó¢„Å´ÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            if soul_identity.soul_id in self.processes:
                raise ValueError(f"Soul {soul_identity.soul_id} is already registered")

            # Elder TreeÈöéÂ±§Âà∂Èôê„ÉÅ„Çß„ÉÉ„ÇØ
            if not self._can_create_soul(soul_identity.elder_type):
                raise ValueError(
                    f"Cannot create more souls of type {soul_identity.elder_type.value}"
                )

            # A2A„Éù„Éº„ÉàÂâ≤„ÇäÂΩì„Å¶
            a2a_port = self._allocate_a2a_port()

            # „Éó„É≠„Çª„ÇπÊÉÖÂ†±‰ΩúÊàê
            process_info = SoulProcessInfo(
                soul_id=soul_identity.soul_id,
                soul_name=soul_identity.soul_name,
                elder_type=soul_identity.elder_type,
                auto_restart=auto_restart,
                max_restarts=max_restarts,
                a2a_port=a2a_port,
                capabilities=[cap.value for cap in soul_identity.capabilities],
                configuration=configuration or {},
            )

            self.processes[soul_identity.soul_id] = process_info
            self.stats["total_souls_created"] += 1

            self.logger.info(
                f"üåü Soul registered: {soul_identity.soul_name} ({soul_identity.soul_id})"
            )
            return soul_identity.soul_id

    def unregister_soul(self, soul_id: str) -> bool:
        """È≠Ç„ÅÆÁôªÈå≤Ëß£Èô§"""
        with self.manager_lock:
            if soul_id not in self.processes:
                return False

            # ÂÆüË°å‰∏≠„ÅÆÂ†¥Âêà„ÅØÂÅúÊ≠¢
            if soul_id in self.running_processes:
                asyncio.create_task(self.stop_soul(soul_id))

            del self.processes[soul_id]

            self.logger.info(f"üóëÔ∏è Soul unregistered: {soul_id}")
            return True

    async def start_soul(self, soul_id: str) -> bool:
        """È≠Ç„Éó„É≠„Çª„ÇπÈñãÂßã"""
        with self.manager_lock:
            if soul_id not in self.processes:
                self.logger.error(f"‚ùå Soul not registered: {soul_id}")
                return False

            process_info = self.processes[soul_id]

            if process_info.state == SoulProcessState.RUNNING:
                self.logger.warning(f"‚ö†Ô∏è Soul {soul_id} is already running")
                return True

            try:
                process_info.state = SoulProcessState.STARTING
                process_info.error_message = None

                # A2AÈÄö‰ø°„Éó„É≠„Éà„Ç≥„É´‰ΩúÊàê
                soul_identity = self._create_soul_identity_from_info(process_info)
                a2a_protocol = await create_a2a_protocol(
                    soul_identity, process_info.a2a_port
                )
                self.a2a_protocols[soul_id] = a2a_protocol

                # È≠Ç„Éó„É≠„Çª„ÇπËµ∑Âãï
                process = mp.Process(
                    target=self._soul_process_wrapper,
                    args=(
                        soul_identity,
                        process_info.configuration,
                        process_info.a2a_port,
                    ),
                    name=f"Soul_{process_info.soul_name}",
                )

                process.start()

                self.running_processes[soul_id] = process
                process_info.process_id = process.pid
                process_info.state = SoulProcessState.RUNNING
                process_info.started_at = datetime.now()
                process_info.last_heartbeat = datetime.now()

                self.stats["total_souls_started"] += 1

                self.logger.info(
                    f"‚ú® Soul started: {process_info.soul_name} (PID: {process.pid})"
                )
                return True

            except Exception as e:
                process_info.state = SoulProcessState.CRASHED
                process_info.error_message = str(e)
                process_info.crash_count += 1
                self.stats["total_crashes"] += 1

                self.logger.error(f"‚ùå Failed to start soul {soul_id}: {e}")
                return False

    async def stop_soul(self, soul_id: str, force: bool = False) -> bool:
        """È≠Ç„Éó„É≠„Çª„ÇπÂÅúÊ≠¢"""
        with self.manager_lock:
            if soul_id not in self.processes:
                return False

            process_info = self.processes[soul_id]

            if process_info.state != SoulProcessState.RUNNING:
                return True

            try:
                process_info.state = SoulProcessState.STOPPING

                # A2AÈÄö‰ø°„Éó„É≠„Éà„Ç≥„É´ÂÅúÊ≠¢
                if soul_id in self.a2a_protocols:
                    await self.a2a_protocols[soul_id].stop_protocol()
                    del self.a2a_protocols[soul_id]

                # „Éó„É≠„Çª„ÇπÂÅúÊ≠¢
                if soul_id in self.running_processes:
                    process = self.running_processes[soul_id]

                    if force:
                        # Âº∑Âà∂ÁµÇ‰∫Ü
                        process.terminate()
                        process.join(timeout=5.0)

                        if process.is_alive():
                            process.kill()
                    else:
                        # ÂÑ™ÈõÖ„Å™ÂÅúÊ≠¢
                        process.terminate()
                        process.join(timeout=10.0)

                        if process.is_alive():
                            process.kill()

                    del self.running_processes[soul_id]

                process_info.state = SoulProcessState.STOPPED
                process_info.stopped_at = datetime.now()
                process_info.process_id = None

                self.stats["total_souls_stopped"] += 1

                self.logger.info(f"üåÖ Soul stopped: {process_info.soul_name}")
                return True

            except Exception as e:
                self.logger.error(f"‚ùå Failed to stop soul {soul_id}: {e}")
                return False

    async def restart_soul(self, soul_id: str) -> bool:
        """È≠Ç„Éó„É≠„Çª„ÇπÂÜçËµ∑Âãï"""
        with self.manager_lock:
            if soul_id not in self.processes:
                return False

            process_info = self.processes[soul_id]

            # ÂÜçËµ∑ÂãïÂõûÊï∞„ÉÅ„Çß„ÉÉ„ÇØ
            if process_info.restart_count >= process_info.max_restarts:
                self.logger.error(f"‚ùå Max restart count reached for soul {soul_id}")
                return False

            # ÂÅúÊ≠¢‚ÜíÈñãÂßã
            await self.stop_soul(soul_id)
            await asyncio.sleep(1.0)  # Â∞ë„ÅóÂæÖÊ©ü

            success = await self.start_soul(soul_id)

            if success:
                process_info.restart_count += 1
                self.stats["total_restarts"] += 1
                self.logger.info(
                    f"üîÑ Soul restarted: {process_info.soul_name} (restart #{process_info.restart_count})"
                )

            return success

    async def start_all_souls(self) -> Dict[str, bool]:
        """ÂÖ®È≠Ç„Éó„É≠„Çª„ÇπÈñãÂßã"""
        results = {}

        # Elder TreeÈöéÂ±§È†Ü„ÅßËµ∑Âãï
        for elder_type in [
            ElderType.GRAND_ELDER,
            ElderType.CLAUDE_ELDER,
            ElderType.ANCIENT_ELDER,
            ElderType.SAGE,
            ElderType.KNIGHT,
            ElderType.SERVANT,
        ]:
            souls_to_start = [
                soul_id
                for soul_id, info in self.processes.items()
                if info.elder_type == elder_type
                and info.state != SoulProcessState.RUNNING
            ]

            for soul_id in souls_to_start:
                results[soul_id] = await self.start_soul(soul_id)
                await asyncio.sleep(0.5)  # Ëµ∑ÂãïÈñìÈöî

        successful = sum(1 for success in results.values() if success)
        self.logger.info(f"üöÄ Started {successful}/{len(results)} souls")

        return results

    async def stop_all_souls(self) -> Dict[str, bool]:
        """ÂÖ®È≠Ç„Éó„É≠„Çª„ÇπÂÅúÊ≠¢"""
        results = {}

        # ÈÄÜÈöéÂ±§È†Ü„ÅßÂÅúÊ≠¢Ôºà‰∏ã‰Ωç„Åã„ÇâÂÅúÊ≠¢Ôºâ
        for elder_type in [
            ElderType.SERVANT,
            ElderType.KNIGHT,
            ElderType.SAGE,
            ElderType.ANCIENT_ELDER,
            ElderType.CLAUDE_ELDER,
            ElderType.GRAND_ELDER,
        ]:
            souls_to_stop = [
                soul_id
                for soul_id, info in self.processes.items()
                if info.elder_type == elder_type
                and info.state == SoulProcessState.RUNNING
            ]

            for soul_id in souls_to_stop:
                results[soul_id] = await self.stop_soul(soul_id)
                await asyncio.sleep(0.2)  # ÂÅúÊ≠¢ÈñìÈöî

        successful = sum(1 for success in results.values() if success)
        self.logger.info(f"üåÖ Stopped {successful}/{len(results)} souls")

        return results

    def get_soul_status(self, soul_id: str) -> Optional[Dict[str, Any]]:
        """È≠Ç„Çπ„ÉÜ„Éº„Çø„ÇπÂèñÂæó"""
        with self.manager_lock:
            if soul_id not in self.processes:
                return None

            process_info = self.processes[soul_id]
            status = process_info.to_dict()

            # „Ç∑„Çπ„ÉÜ„É†„É™„ÇΩ„Éº„ÇπÊÉÖÂ†±ËøΩÂä†
            if process_info.process_id:
                try:
                    psutil_process = psutil.Process(process_info.process_id)
                    status.update(
                        {
                            "cpu_percent": psutil_process.cpu_percent(),
                            "memory_info": psutil_process.memory_info()._asdict(),
                            "memory_percent": psutil_process.memory_percent(),
                            "num_threads": psutil_process.num_threads(),
                            "status": psutil_process.status(),
                        }
                    )
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    status["system_process_error"] = "Process not accessible"

            # Á®ºÂÉçÊôÇÈñì
            uptime = process_info.get_uptime()
            if uptime:
                status["uptime_seconds"] = uptime.total_seconds()

            # ÂÅ•ÂÖ®ÊÄß
            status["is_healthy"] = process_info.is_healthy()

            return status

    def get_all_souls_status(self) -> Dict[str, Dict[str, Any]]:
        """ÂÖ®È≠Ç„Çπ„ÉÜ„Éº„Çø„ÇπÂèñÂæó"""
        return {
            soul_id: self.get_soul_status(soul_id) for soul_id in self.processes.keys()
        }

    def get_manager_statistics(self) -> Dict[str, Any]:
        """ÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†Áµ±Ë®àÂèñÂæó"""
        with self.manager_lock:
            running_count = len(
                [
                    p
                    for p in self.processes.values()
                    if p.state == SoulProcessState.RUNNING
                ]
            )
            crashed_count = len(
                [
                    p
                    for p in self.processes.values()
                    if p.state == SoulProcessState.CRASHED
                ]
            )

            elder_type_counts = {}
            for elder_type in ElderType:
                count = len(
                    [p for p in self.processes.values() if p.elder_type == elder_type]
                )
                elder_type_counts[elder_type.value] = count

            uptime = (datetime.now() - self.stats["start_time"]).total_seconds()

            return {
                "manager_uptime_seconds": uptime,
                "total_souls": len(self.processes),
                "running_souls": running_count,
                "crashed_souls": crashed_count,
                "elder_type_distribution": elder_type_counts,
                "max_processes": self.max_processes,
                "statistics": self.stats.copy(),
                "a2a_protocols_active": len(self.a2a_protocols),
            }

    async def _monitoring_loop(self):
        """Áõ£Ë¶ñ„É´„Éº„Éó"""
        while self.is_running.value:
            try:
                with self.manager_lock:
                    for soul_id, process_info in self.processes.items():
                        if process_info.state == SoulProcessState.RUNNING:
                            # „Éó„É≠„Çª„ÇπÁîüÂ≠òÁ¢∫Ë™ç
                            if soul_id in self.running_processes:
                                process = self.running_processes[soul_id]

                                if not process.is_alive():
                                    # „Éó„É≠„Çª„ÇπÊ≠ª‰∫°Ê§úÂá∫
                                    self.logger.warning(
                                        f"üíÄ Process death detected: {soul_id}"
                                    )
                                    process_info.state = SoulProcessState.CRASHED
                                    process_info.crash_count += 1
                                    self.stats["total_crashes"] += 1

                                    del self.running_processes[soul_id]

                                    # Ëá™ÂãïÂÜçËµ∑Âãï
                                    if (
                                        process_info.auto_restart
                                        and process_info.restart_count
                                        < process_info.max_restarts
                                    ):
                                        asyncio.create_task(self.restart_soul(soul_id))

                await asyncio.sleep(self.monitoring_interval)

            except Exception as e:
                self.logger.error(f"‚ùå Monitoring loop error: {e}")
                await asyncio.sleep(self.monitoring_interval)

    async def _health_check_loop(self):
        """„Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ„É´„Éº„Éó"""
        while self.is_running.value:
            try:
                for soul_id, protocol in self.a2a_protocols.items():
                    # A2A„Éó„É≠„Éà„Ç≥„É´ÁµåÁî±„Åß„Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ
                    try:
                        health_response = await protocol.send_request(
                            soul_id,
                            "health_check",
                            {"timestamp": datetime.now().isoformat()},
                            requires_response=True,
                        )

                        if health_response:
                            # „Éè„Éº„Éà„Éì„Éº„ÉàÊõ¥Êñ∞
                            if soul_id in self.processes:
                                self.processes[soul_id].last_heartbeat = datetime.now()
                        else:
                            # ÂøúÁ≠î„Å™„Åó
                            if soul_id in self.processes:
                                process_info = self.processes[soul_id]
                                if process_info.state == SoulProcessState.RUNNING:
                                    process_info.state = SoulProcessState.UNRESPONSIVE
                                    self.logger.warning(
                                        f"‚ö†Ô∏è Soul unresponsive: {soul_id}"
                                    )

                    except Exception as e:
                        self.logger.warning(
                            f"‚ö†Ô∏è Health check failed for {soul_id}: {e}"
                        )

                await asyncio.sleep(self.health_check_timeout)

            except Exception as e:
                self.logger.error(f"‚ùå Health check loop error: {e}")
                await asyncio.sleep(self.health_check_timeout)

    async def _statistics_loop(self):
        """Áµ±Ë®àÂèéÈõÜ„É´„Éº„Éó"""
        while self.is_running.value:
            try:
                # „Ç∑„Çπ„ÉÜ„É†„É™„ÇΩ„Éº„ÇπÁµ±Ë®àÊõ¥Êñ∞
                for soul_id, process_info in self.processes.items():
                    if (
                        process_info.process_id
                        and process_info.state == SoulProcessState.RUNNING
                    ):
                        try:
                            psutil_process = psutil.Process(process_info.process_id)
                            process_info.cpu_usage = psutil_process.cpu_percent()
                            process_info.memory_usage = psutil_process.memory_percent()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass

                await asyncio.sleep(60)  # 1ÂàÜÈñìÈöî

            except Exception as e:
                self.logger.error(f"‚ùå Statistics loop error: {e}")
                await asyncio.sleep(60)

    def _can_create_soul(self, elder_type: ElderType) -> bool:
        """È≠Ç‰ΩúÊàêÂèØËÉΩ„ÉÅ„Çß„ÉÉ„ÇØ"""
        hierarchy_info = self.elder_hierarchy.get(elder_type)
        if not hierarchy_info:
            return False

        current_count = len(
            [p for p in self.processes.values() if p.elder_type == elder_type]
        )
        return current_count < hierarchy_info["max_instances"]

    def _allocate_a2a_port(self) -> int:
        """A2A„Éù„Éº„ÉàÂâ≤„ÇäÂΩì„Å¶"""
        # Á∞°Âçò„Å™ÂÆüË£ÖÔºö9000Áï™Âè∞„Åã„ÇâÈ†ÜÊ¨°Ââ≤„ÇäÂΩì„Å¶
        used_ports = {
            info.a2a_port for info in self.processes.values() if info.a2a_port
        }

        for port in range(9000, 9100):
            if port not in used_ports:
                return port

        raise RuntimeError("No available A2A ports")

    def _create_soul_identity_from_info(
        self, process_info: SoulProcessInfo
    ) -> SoulIdentity:
        """„Éó„É≠„Çª„ÇπÊÉÖÂ†±„Åã„ÇâÈ≠Ç„Ç¢„Ç§„Éá„É≥„ÉÜ„Ç£„ÉÜ„Ç£„Çí‰ΩúÊàê"""
        capabilities = [
            SoulCapability(cap)
            for cap in process_info.capabilities
            if cap in [c.value for c in SoulCapability]
        ]

        return SoulIdentity(
            soul_id=process_info.soul_id,
            soul_name=process_info.soul_name,
            elder_type=process_info.elder_type,
            hierarchy_level=self.elder_hierarchy[process_info.elder_type]["level"],
            capabilities=capabilities,
        )

    @staticmethod
    def _soul_process_wrapper(
        soul_identity: SoulIdentity, configuration: Dict[str, Any], a2a_port: int
    ):
        """È≠Ç„Éó„É≠„Çª„Çπ„É©„ÉÉ„Éë„ÉºÔºà„Éó„É≠„Çª„ÇπÂÜÖÂÆüË°åÔºâ"""
        try:
            # Êñ∞„Åó„ÅÑ„Éó„É≠„Çª„Çπ„Åß„ÅÆ„É≠„Ç¨„ÉºË®≠ÂÆö
            process_logger = get_logger(f"soul_wrapper_{soul_identity.soul_id}")

            process_logger.info(
                f"üëë Soul process starting: {soul_identity.soul_name} (PID: {os.getpid()})"
            )

            # TODO: ÂÆüÈöõ„ÅÆÈ≠ÇÂÆüË£Ö„Çí„Åì„Åì„ÅßÂÆüË°å
            # ÁèæÂú®„ÅØÂü∫Êú¨ÁöÑ„Å™„É´„Éº„Éó„ÅÆ„Åø

            # A2AÈÄö‰ø°„Éó„É≠„Éà„Ç≥„É´ÔºàÁ∞°Áï•ÁâàÔºâ
            async def run_soul():
                protocol = await create_a2a_protocol(soul_identity, a2a_port)

                # „Ç∑„É≥„Éó„É´„Å™„É°„ÉÉ„Çª„Éº„Ç∏„É´„Éº„Éó
                while True:
                    await asyncio.sleep(1.0)

            asyncio.run(run_soul())

        except Exception as e:
            process_logger.error(f"üí• Soul process error: {e}")
            raise


# === ‰æøÂà©„Å™Èñ¢Êï∞ ===


async def create_soul_process_manager(max_processes: int = None) -> SoulProcessManager:
    """È≠Ç„Éó„É≠„Çª„ÇπÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†„ÅÆ‰ΩúÊàê"""
    manager = SoulProcessManager(max_processes)

    if await manager.start_manager():
        return manager
    else:
        raise RuntimeError("Failed to start Soul Process Manager")


def create_standard_elder_tree() -> List[SoulIdentity]:
    """Ê®ôÊ∫ñElder TreeÊßãÊàê„ÅÆ‰ΩúÊàê"""
    souls = []

    # Grand Elder Maru
    souls.append(
        create_soul_identity(
            "Grand Elder Maru",
            ElderType.GRAND_ELDER,
            [
                SoulCapability.LEADERSHIP,
                SoulCapability.WISDOM,
                SoulCapability.PROBLEM_SOLVING,
            ],
        )
    )

    # Claude Elder
    souls.append(
        create_soul_identity(
            "Claude Elder",
            ElderType.CLAUDE_ELDER,
            [
                SoulCapability.LEADERSHIP,
                SoulCapability.COMMUNICATION,
                SoulCapability.ANALYSIS,
            ],
        )
    )

    # Ancient Elder
    souls.append(
        create_soul_identity(
            "Ancient Elder",
            ElderType.ANCIENT_ELDER,
            [SoulCapability.QUALITY_ASSURANCE, SoulCapability.WISDOM],
        )
    )

    # 4Ë≥¢ËÄÖ
    sage_configs = [
        ("Knowledge Sage", [SoulCapability.WISDOM, SoulCapability.LEARNING]),
        ("Task Sage", [SoulCapability.EXECUTION, SoulCapability.PROBLEM_SOLVING]),
        ("Incident Sage", [SoulCapability.QUALITY_ASSURANCE, SoulCapability.ANALYSIS]),
        ("RAG Sage", [SoulCapability.ANALYSIS, SoulCapability.SYNTHESIS]),
    ]

    for name, capabilities in sage_configs:
        souls.append(create_soul_identity(name, ElderType.SAGE, capabilities))

    # È®éÂ£´Âõ£Ôºà‰æãÔºö8ÂêçÔºâ
    knight_configs = [
        ("Security Knight", [SoulCapability.QUALITY_ASSURANCE]),
        ("Performance Knight", [SoulCapability.ANALYSIS]),
        ("Documentation Knight", [SoulCapability.COMMUNICATION]),
        ("Testing Knight", [SoulCapability.QUALITY_ASSURANCE]),
        ("DevOps Knight", [SoulCapability.EXECUTION]),
        ("Architecture Knight", [SoulCapability.SYNTHESIS]),
        ("Integration Knight", [SoulCapability.COMMUNICATION]),
        ("Monitoring Knight", [SoulCapability.ANALYSIS]),
    ]

    for name, capabilities in knight_configs:
        souls.append(create_soul_identity(name, ElderType.KNIGHT, capabilities))

    # „Ç®„É´„ÉÄ„Éº„Çµ„Éº„Éê„É≥„ÉàÔºà‰æãÔºö8Âêç„ÄÅÂÆüÈöõ„ÅØ32Âêç„Åæ„ÅßÂèØËÉΩÔºâ
    servant_configs = [
        ("Code Servant", [SoulCapability.EXECUTION, SoulCapability.CREATIVITY]),
        ("Test Guardian", [SoulCapability.QUALITY_ASSURANCE]),
        (
            "Quality Inspector",
            [SoulCapability.QUALITY_ASSURANCE, SoulCapability.ANALYSIS],
        ),
        ("Security Auditor", [SoulCapability.QUALITY_ASSURANCE]),
        ("Performance Monitor", [SoulCapability.ANALYSIS]),
        ("Documentation Keeper", [SoulCapability.COMMUNICATION]),
        ("Git Master", [SoulCapability.EXECUTION]),
        ("Deploy Manager", [SoulCapability.EXECUTION]),
    ]

    for name, capabilities in servant_configs:
        souls.append(create_soul_identity(name, ElderType.SERVANT, capabilities))

    return souls


async def test_soul_process_manager():
    """È≠Ç„Éó„É≠„Çª„ÇπÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†„ÅÆ„ÉÜ„Çπ„Éà"""
    print("üèõÔ∏è Testing Soul Process Manager...")

    # ÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†‰ΩúÊàê
    manager = await create_soul_process_manager(max_processes=8)

    try:
        # Ê®ôÊ∫ñElder Tree‰ΩúÊàê
        elder_tree = create_standard_elder_tree()

        # È≠Ç„ÇíÁôªÈå≤
        for soul_identity in elder_tree[:5]:  # ÊúÄÂàù„ÅÆ5„Å§„ÅÆ„Åø„ÉÜ„Çπ„Éà
            manager.register_soul(soul_identity)

        # ÂÖ®È≠ÇËµ∑Âãï
        print("üöÄ Starting all souls...")
        start_results = await manager.start_all_souls()
        print(f"Started: {sum(start_results.values())}/{len(start_results)} souls")

        # Áµ±Ë®àË°®Á§∫
        await asyncio.sleep(5)
        stats = manager.get_manager_statistics()
        print(f"üìä Manager statistics: {json.dumps(stats, indent=2, default=str)}")

        # È≠Ç„Çπ„ÉÜ„Éº„Çø„ÇπË°®Á§∫
        for soul_id in list(manager.processes.keys())[:3]:
            status = manager.get_soul_status(soul_id)
            print(f"üë§ {soul_id}: {status['state']} (healthy: {status['is_healthy']})")

        # ‰∏Ä„Å§„ÅÆÈ≠Ç„ÇíÂÜçËµ∑Âãï„ÉÜ„Çπ„Éà
        if manager.processes:
            test_soul_id = list(manager.processes.keys())[0]
            print(f"üîÑ Testing restart for {test_soul_id}...")
            restart_success = await manager.restart_soul(test_soul_id)
            print(f"Restart result: {restart_success}")

        # ÂÖ®ÂÅúÊ≠¢
        print("üåÖ Stopping all souls...")
        stop_results = await manager.stop_all_souls()
        print(f"Stopped: {sum(stop_results.values())}/{len(stop_results)} souls")

    finally:
        await manager.stop_manager()

    print("‚úÖ Soul Process Manager test completed!")


if __name__ == "__main__":
    print("üåü Soul Process Manager - È≠Ç„Éó„É≠„Çª„ÇπÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†")
    print("Test mode:")
    asyncio.run(test_soul_process_manager())
