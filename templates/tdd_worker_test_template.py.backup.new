#!/usr/bin/env python3
"""
{WorkerName} TDDテストテンプレート
AI Company - Test Driven Development

このテンプレートを使用してワーカーのテストを作成してください。
1. Red: このテストを実装（最初は失敗）
2. Green: ワーカーを実装してテストを通す
3. Refactor: コードを改善
"""

import pytest
import json
from unittest.mock import Mock, patch, MagicMock, call
from datetime import datetime
from pathlib import Path
import sys

# プロジェクトルートをPythonパスに追加
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from workers.{worker_module} import {WorkerName}


class Test{WorkerName}Initialization:
    """{WorkerName}の初期化テスト"""

    @patch('workers.{worker_module}.SlackNotifier')
    def test_should_initialize_with_default_settings(self, mock_slack):
        """デフォルト設定で初期化できることを確認"""
        # Arrange
        mock_slack_instance = Mock()
        mock_slack.return_value = mock_slack_instance

        # Act
        with patch.object({WorkerName}, 'connect'):
            worker = {WorkerName}()

        # Assert
        assert worker.worker_type == '{worker_type}'
        assert worker.worker_id.startswith('{worker_type}-')
        assert worker.slack_notifier == mock_slack_instance

    @patch('workers.{worker_module}.SlackNotifier')
    def test_should_initialize_with_custom_worker_id(self, mock_slack):
        """カスタムワーカーIDで初期化できることを確認"""
        # Arrange
        custom_id = 'custom-worker-123'

        # Act
        with patch.object({WorkerName}, 'connect'):
            worker = {WorkerName}(worker_id=custom_id)

        # Assert
        assert worker.worker_id == custom_id

    def test_should_call_worker_specific_initialization(self):
        """ワーカー固有の初期化が呼ばれることを確認"""
        # Arrange & Act
        with patch.object({WorkerName}, 'connect'):
            with patch.object({WorkerName}, '_init_worker_specific_settings') as mock_init:
                worker = {WorkerName}()

        # Assert
        mock_init.assert_called_once()


class Test{WorkerName}MessageProcessing:
    """{WorkerName}のメッセージ処理テスト"""

    @pytest.fixture
    def worker(self):
        """テスト用ワーカーインスタンス"""
        with patch.object({WorkerName}, '__init__', lambda x, y=None: None):
            worker = {WorkerName}()
            worker.worker_id = 'test-worker'
            worker.logger = Mock()
            worker.current_task = None
            worker._stats = {{'processed_count': 0, 'error_count': 0}}
            worker.slack_notifier = Mock()
            return worker

    @pytest.fixture
    def mock_channel(self):
        """モックRabbitMQチャンネル"""
        channel = Mock()
        return channel

    @pytest.fixture
    def mock_method(self):
        """モックメソッド"""
        method = Mock()
        method.delivery_tag = 'test-delivery-tag'
        return method

    def test_should_process_valid_message_successfully(self, worker, mock_channel, mock_method):
        """正常なメッセージを処理できることを確認"""
        # Arrange
        message = {{
            'task_id': 'task-123',
            'action': 'example_action',
            'data': {{'key': 'value'}}
        }}
        body = json.dumps(message).encode()

        worker._validate_message = Mock(return_value=True)
        worker._process_task = Mock(return_value={{'result': 'success'}})
        worker._send_success_result = Mock()
        worker._increment_stats = Mock()
        worker._update_stats = Mock()

        # Act
        worker.process_message(mock_channel, mock_method, None, body)

        # Assert
        worker._validate_message.assert_called_once_with(message)
        worker._process_task.assert_called_once_with(message)
        worker._send_success_result.assert_called_once()
        worker._increment_stats.assert_called_with('processed_count')
        worker._update_stats.assert_called_with('last_task_id', 'task-123')
        mock_channel.basic_ack.assert_called_once_with(delivery_tag='test-delivery-tag')

    def test_should_handle_invalid_message_format(self, worker, mock_channel, mock_method):
        """無効なメッセージフォーマットを適切に処理することを確認"""
        # Arrange
        message = {{'task_id': 'task-123'}}  # actionフィールドが不足
        body = json.dumps(message).encode()

        worker._validate_message = Mock(return_value=False)
        worker.handle_error = Mock()
        worker._send_error_result = Mock()

        # Act
        worker.process_message(mock_channel, mock_method, None, body)

        # Assert
        worker.handle_error.assert_called_once()
        error_call = worker.handle_error.call_args[0]
        assert isinstance(error_call[0], ValueError)
        assert "Invalid message format" in str(error_call[0])
        worker._send_error_result.assert_called_once()
        mock_channel.basic_ack.assert_called_once()

    def test_should_handle_processing_error(self, worker, mock_channel, mock_method):
        """処理中のエラーを適切に処理することを確認"""
        # Arrange
        message = {{
            'task_id': 'task-123',
            'action': 'example_action'
        }}
        body = json.dumps(message).encode()

        error = RuntimeError("Processing failed")
        worker._validate_message = Mock(return_value=True)
        worker._process_task = Mock(side_effect=error)
        worker.handle_error = Mock()
        worker._send_error_result = Mock()

        # Act
        worker.process_message(mock_channel, mock_method, None, body)

        # Assert
        worker.handle_error.assert_called_once_with(error, "process_message(task-123)")
        worker._send_error_result.assert_called_once_with("Processing failed", "task-123")
        mock_channel.basic_ack.assert_called_once()

    def test_should_update_current_task_during_processing(self, worker, mock_channel, mock_method):
        """処理中にcurrent_taskが更新されることを確認"""
        # Arrange
        message = {{'task_id': 'task-123', 'action': 'example_action'}}
        body = json.dumps(message).encode()

        task_states = []

        def capture_task_state(*args):
            task_states.append(worker.current_task)
            return {{'result': 'success'}}

        worker._validate_message = Mock(return_value=True)
        worker._process_task = Mock(side_effect=capture_task_state)
        worker._send_success_result = Mock()

        # Act
        worker.process_message(mock_channel, mock_method, None, body)

        # Assert
        assert 'task-123' in task_states  # 処理中はtask_idが設定される
        assert worker.current_task is None  # 処理後はクリアされる


class Test{WorkerName}Validation:
    """{WorkerName}の検証機能テスト"""

    @pytest.fixture
    def worker(self):
        with patch.object({WorkerName}, '__init__', lambda x, y=None: None):
            worker = {WorkerName}()
            worker.logger = Mock()
            return worker

    def test_should_validate_message_with_all_required_fields(self, worker):
        """必須フィールドがすべて存在する場合は検証成功"""
        # Arrange
        message = {{
            'task_id': 'task-123',
            'action': 'example_action',
            'data': {{'optional': 'field'}}
        }}

        # Act
        result = worker._validate_message(message)

        # Assert
        assert result is True

    def test_should_fail_validation_when_required_field_missing(self, worker):
        """必須フィールドが不足している場合は検証失敗"""
        # Arrange
        message = {{'task_id': 'task-123'}}  # actionが不足

        # Act
        result = worker._validate_message(message)

        # Assert
        assert result is False
        worker.logger.error.assert_called_once()
        error_msg = worker.logger.error.call_args[0][0]
        assert "action" in error_msg

    @pytest.mark.parametrize("message,expected", [
        ({{}}, False),  # 空のメッセージ
        ({{'task_id': None, 'action': 'test'}}, True),  # Noneでも存在すればOK
        ({{'task_id': '', 'action': ''}}, True),  # 空文字でも存在すればOK
        ({{'action': 'test'}}, False),  # task_idが不足
    ])
    def test_should_validate_various_message_formats(self, worker, message, expected):
        """様々なメッセージフォーマットの検証"""
        # Act
        result = worker._validate_message(message)

        # Assert
        assert result == expected


class Test{WorkerName}TaskProcessing:
    """{WorkerName}のタスク処理テスト"""

    @pytest.fixture
    def worker(self):
        with patch.object({WorkerName}, '__init__', lambda x, y=None: None):
            worker = {WorkerName}()
            worker.logger = Mock()
            return worker

    def test_should_process_example_action(self, worker):
        """example_actionを正常に処理できることを確認"""
        # Arrange
        message = {{
            'task_id': 'task-123',
            'action': 'example_action',
            'data': {{'input': 'test_data'}}
        }}

        # Act
        result = worker._process_task(message)

        # Assert
        assert result['status'] == 'completed'
        assert 'result' in result
        assert result['processed_data'] == {{'input': 'test_data'}}

    def test_should_raise_error_for_unknown_action(self, worker):
        """未知のアクションでエラーが発生することを確認"""
        # Arrange
        message = {{
            'task_id': 'task-123',
            'action': 'unknown_action'
        }}

        # Act & Assert
        with pytest.raises(ValueError) as exc_info:
            worker._process_task(message)

        assert "Unknown action: unknown_action" in str(exc_info.value)


class Test{WorkerName}ResultHandling:
    """{WorkerName}の結果送信テスト"""

    @pytest.fixture
    def worker(self):
        with patch.object({WorkerName}, '__init__', lambda x, y=None: None):
            worker = {WorkerName}()
            worker.worker_id = 'test-worker'
            worker.send_result = Mock()
            worker.slack_notifier = Mock()
            worker._get_timestamp = Mock(return_value='2024-01-01T00:00:00')
            return worker

    def test_should_send_success_result(self, worker):
        """成功結果を正しく送信することを確認"""
        # Arrange
        result = {{'status': 'completed', 'data': 'test'}}
        task_id = 'task-123'
        worker._should_notify_slack = Mock(return_value=False)

        # Act
        worker._send_success_result(result, task_id)

        # Assert
        worker.send_result.assert_called_once()
        sent_data = worker.send_result.call_args[0][0]
        assert sent_data['task_id'] == task_id
        assert sent_data['worker_id'] == 'test-worker'
        assert sent_data['status'] == 'completed'
        assert sent_data['result'] == result
        assert sent_data['timestamp'] == '2024-01-01T00:00:00'

    def test_should_send_slack_notification_when_required(self, worker):
        """必要時にSlack通知を送信することを確認"""
        # Arrange
        result = {{'status': 'completed', 'notify_slack': True}}
        task_id = 'task-123'
        worker._should_notify_slack = Mock(return_value=True)

        # Act
        worker._send_success_result(result, task_id)

        # Assert
        worker.slack_notifier.send_task_completion_simple.assert_called_once()

    def test_should_send_error_result(self, worker):
        """エラー結果を正しく送信することを確認"""
        # Arrange
        error_message = "Processing failed"
        task_id = 'task-123'

        # Act
        worker._send_error_result(error_message, task_id)

        # Assert
        worker.send_result.assert_called_once()
        sent_data = worker.send_result.call_args[0][0]
        assert sent_data['task_id'] == task_id
        assert sent_data['status'] == 'failed'
        assert sent_data['error'] == error_message


class Test{WorkerName}Integration:
    """{WorkerName}の統合テスト"""

    @patch('pika.BlockingConnection')
    @patch('workers.{worker_module}.SlackNotifier')
    def test_should_complete_full_message_processing_cycle(self, mock_slack, mock_pika):
        """完全なメッセージ処理サイクルをテスト"""
        # Arrange
        mock_connection = Mock()
        mock_channel = Mock()
        mock_connection.channel.return_value = mock_channel
        mock_pika.return_value = mock_connection

        worker = {WorkerName}()

        message = {{
            'task_id': 'integration-test-123',
            'action': 'example_action',
            'data': {{'test': 'integration'}}
        }}
        body = json.dumps(message).encode()

        mock_method = Mock()
        mock_method.delivery_tag = 'test-tag'

        # Act
        worker.process_message(mock_channel, mock_method, None, body)

        # Assert
        # メッセージが確認されたことを確認
        mock_channel.basic_ack.assert_called_once_with(delivery_tag='test-tag')

        # 結果が送信されたことを確認
        result_calls = mock_channel.basic_publish.call_args_list
        assert len(result_calls) > 0

        # 送信された結果を検証
        result_body = json.loads(result_calls[0][1]['body'])
        assert result_body['task_id'] == 'integration-test-123'
        assert result_body['status'] == 'completed'


if __name__ == "__main__":
    pytest.main([__file__, "-vv", "--cov=workers.{worker_module}", "--cov-report=term-missing"])
