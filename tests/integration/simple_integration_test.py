#!/usr/bin/env python3
"""
ã‚·ãƒ³ãƒ—ãƒ«ãªçµ±åˆãƒ†ã‚¹ãƒˆ
å¤–éƒ¨ä¾å­˜é–¢ä¿‚ã‚’æœ€å°é™ã«ã—ãŸå‹•ä½œç¢ºèª
"""

import asyncio
import json
import tempfile
import time
from pathlib import Path
import os
import sys

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã‚’Pythonãƒ‘ã‚¹ã«è¿½åŠ 
PROJECT_ROOT = Path(__file__).parent
sys.path.insert(0, str(PROJECT_ROOT))

import pytest
from unittest.mock import Mock, MagicMock, patch
import unittest
def test_security_module_basic():
    """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åŸºæœ¬ãƒ†ã‚¹ãƒˆ"""
    print("ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŸºæœ¬ãƒ†ã‚¹ãƒˆ...")
    
    try:
        from core.security_module import InputSanitizer
        
        sanitizer = InputSanitizer()
        
        # ãƒ•ã‚¡ã‚¤ãƒ«åã‚µãƒ‹ã‚¿ã‚¤ã‚ºãƒ†ã‚¹ãƒˆ
        dangerous_filename = "../../../etc/passwd"
        safe_filename = sanitizer.sanitize_filename(dangerous_filename)
        
        assert "../" not in safe_filename
        assert "passwd" in safe_filename  # å±é™ºéƒ¨åˆ†ã¯é™¤å»ã€ãƒ•ã‚¡ã‚¤ãƒ«åã¯æ®‹å­˜
        print(f"  âœ… ãƒ•ã‚¡ã‚¤ãƒ«åã‚µãƒ‹ã‚¿ã‚¤ã‚º: '{dangerous_filename}' â†’ '{safe_filename}'")
        
        # ãƒ‘ã‚¹ã‚µãƒ‹ã‚¿ã‚¤ã‚ºãƒ†ã‚¹ãƒˆ
        base_path = "/tmp/safe_area"
        dangerous_path = "../../../etc/passwd"
        safe_path = sanitizer.sanitize_path(dangerous_path, base_path)
        
        if safe_path:
            assert base_path in safe_path
        print(f"  âœ… ãƒ‘ã‚¹ã‚µãƒ‹ã‚¿ã‚¤ã‚º: å®‰å…¨æ€§ç¢ºèª")
        
        # JSONå…¥åŠ›ã‚µãƒ‹ã‚¿ã‚¤ã‚ºãƒ†ã‚¹ãƒˆ
        dangerous_json = {
            "command": "rm -rf /",
            "nested": {
                "control_chars": "\x00\x01\x02test",
                "long_string": "A" * 20000
            }
        }
        
        safe_json = sanitizer.sanitize_json_input(dangerous_json)
        assert len(safe_json["nested"]["long_string"]) <= 10000
        assert "\x00" not in safe_json["nested"]["control_chars"]
        print(f"  âœ… JSONå…¥åŠ›ã‚µãƒ‹ã‚¿ã‚¤ã‚º: åˆ¶å¾¡æ–‡å­—ãƒ»é•·ã•åˆ¶é™é©ç”¨")
        
        return True
        
    except Exception as e:
        print(f"  âŒ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ†ã‚¹ãƒˆå¤±æ•—: {e}")
        return False

async def test_async_execution_basic():
    """éåŒæœŸå®Ÿè¡Œã®åŸºæœ¬ãƒ†ã‚¹ãƒˆ"""
    print("âš¡ éåŒæœŸå®Ÿè¡ŒåŸºæœ¬ãƒ†ã‚¹ãƒˆ...")
    
    try:
        # ç°¡å˜ãªéåŒæœŸã‚¿ã‚¹ã‚¯ã®å®Ÿè¡Œ
        async def simple_task(task_id, duration):
            await asyncio.sleep(duration)
            return f"Task {task_id} completed after {duration}s"
        
        # ä¸¦åˆ—å®Ÿè¡Œãƒ†ã‚¹ãƒˆ
        start_time = time.time()
        tasks = [
            simple_task(i, 0.1) for i in range(5)
        ]
        
        results = await asyncio.gather(*tasks)
        end_time = time.time()
        
        # ä¸¦åˆ—å®Ÿè¡Œã«ã‚ˆã‚Šã€5 Ã— 0.1s = 0.5s ã‚ˆã‚Šã‚‚å¤§å¹…ã«çŸ­ã„æ™‚é–“ã§å®Œäº†ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
        total_time = end_time - start_time
        assert total_time < 0.3, f"ä¸¦åˆ—å®Ÿè¡ŒãŒåŠ¹ã„ã¦ã„ãªã„: {total_time}s"
        assert len(results) == 5, "å…¨ã¦ã®ã‚¿ã‚¹ã‚¯ãŒå®Œäº†ã—ã¦ã„ãªã„"
        
        print(f"  âœ… ä¸¦åˆ—å®Ÿè¡Œ: 5ã‚¿ã‚¹ã‚¯ã‚’{total_time:.3f}ç§’ã§å®Œäº†")
        
        return True
        
    except Exception as e:
        print(f"  âŒ éåŒæœŸå®Ÿè¡Œãƒ†ã‚¹ãƒˆå¤±æ•—: {e}")
        return False

def test_file_operations():
    """ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œãƒ†ã‚¹ãƒˆ"""
    print("ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œãƒ†ã‚¹ãƒˆ...")
    
    try:
        # ä¸€æ™‚ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã®ãƒ†ã‚¹ãƒˆ
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            
            # ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
            test_file = temp_path / "test_output.txt"
            test_content = "# Elders Guild Test Output\nGenerated by async worker integration test\n"
            
            test_file.write_text(test_content, encoding='utf-8')
            assert test_file.exists()
            print(f"  âœ… ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ: {test_file.name}")
            
            # ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
            read_content = test_file.read_text(encoding='utf-8')
            assert read_content == test_content
            print(f"  âœ… ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿: {len(read_content)} æ–‡å­—")
            
            # è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ
            files_created = []
            for i in range(3):
                file_path = temp_path / f"output_{i}.txt"
                file_path.write_text(f"Output file {i}\nTimestamp: {time.time()}\n")
                files_created.append(file_path)
            
            assert len(files_created) == 3
            assert all(f.exists() for f in files_created)
            print(f"  âœ… è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ: {len(files_created)} ãƒ•ã‚¡ã‚¤ãƒ«")
            
        return True
        
    except Exception as e:
        print(f"  âŒ ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œãƒ†ã‚¹ãƒˆå¤±æ•—: {e}")
        return False

def test_local_rate_limiting():
    """ãƒ­ãƒ¼ã‚«ãƒ«ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒ†ã‚¹ãƒˆ"""
    print("â±ï¸ ãƒ­ãƒ¼ã‚«ãƒ«ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒ†ã‚¹ãƒˆ...")
    
    try:
        # ç°¡å˜ãªãƒ¬ãƒ¼ãƒˆåˆ¶é™å®Ÿè£…
        class SimpleRateLimiter:
            def __init__(self, rate, period):
                self.rate = rate
                self.period = period
                self.calls = []
            
            def check_rate_limit(self):
                now = time.time()
                # å¤ã„å‘¼ã³å‡ºã—ã‚’å‰Šé™¤
                self.calls = [call for call in self.calls if call > now - self.period]
                
                if len(self.calls) >= self.rate:
                    return False
                
                self.calls.append(now)
                return True
        
        limiter = SimpleRateLimiter(rate=3, period=1)  # 1ç§’ã«3å›
        
        # åˆ¶é™å†…ã§ã®ãƒ†ã‚¹ãƒˆ
        for i in range(3):
            allowed = limiter.check_rate_limit()
            assert allowed, f"åˆ¶é™å†…ã®å‘¼ã³å‡ºã—{i+1}ãŒæ‹’å¦ã•ã‚ŒãŸ"
        
        # åˆ¶é™è¶…éãƒ†ã‚¹ãƒˆ
        exceeded = limiter.check_rate_limit()
        assert not exceeded, "åˆ¶é™è¶…éãŒæ¤œå‡ºã•ã‚Œãªã‹ã£ãŸ"
        
        print(f"  âœ… ãƒ¬ãƒ¼ãƒˆåˆ¶é™: 3å›è¨±å¯ã€4å›ç›®æ‹’å¦")
        
        return True
        
    except Exception as e:
        print(f"  âŒ ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒ†ã‚¹ãƒˆå¤±æ•—: {e}")
        return False

def test_basic_caching():
    """åŸºæœ¬ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ†ã‚¹ãƒˆ"""
    print("ğŸ—„ï¸ åŸºæœ¬ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ†ã‚¹ãƒˆ...")
    
    try:
        # ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ¡ãƒ¢ãƒªã‚­ãƒ£ãƒƒã‚·ãƒ¥å®Ÿè£…
        class SimpleCache:
            def __init__(self, ttl=60):
                self.cache = {}
                self.ttl = ttl
            
            def set(self, key, value):
                self.cache[key] = {
                    'value': value,
                    'expires_at': time.time() + self.ttl
                }
            
            def get(self, key, default=None):
                if key not in self.cache:
                    return default
                
                entry = self.cache[key]
                if time.time() > entry['expires_at']:
                    del self.cache[key]
                    return default
                
                return entry['value']
        
        cache = SimpleCache(ttl=5)  # 5ç§’TTL
        
        # åŸºæœ¬æ“ä½œãƒ†ã‚¹ãƒˆ
        test_key = "test_data"
        test_value = {"message": "Hello Cache", "number": 42}
        
        cache.set(test_key, test_value)
        retrieved = cache.get(test_key)
        
        assert retrieved == test_value
        print(f"  âœ… ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜ãƒ»å–å¾—")
        
        # å­˜åœ¨ã—ãªã„ã‚­ãƒ¼
        missing = cache.get("non_existent", "default")
        assert missing == "default"
        print(f"  âœ… ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤å–å¾—")
        
        return True
        
    except Exception as e:
        print(f"  âŒ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ†ã‚¹ãƒˆå¤±æ•—: {e}")
        return False

def test_basic_metrics():
    """åŸºæœ¬ãƒ¡ãƒˆãƒªã‚¯ã‚¹ãƒ†ã‚¹ãƒˆ"""
    print("ğŸ“Š åŸºæœ¬ãƒ¡ãƒˆãƒªã‚¯ã‚¹ãƒ†ã‚¹ãƒˆ...")
    
    try:
        # ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†
        class SimpleMetrics:
            def __init__(self):
                self.counters = {}
                self.timings = {}
            
            def increment(self, name):
                self.counters[name] = self.counters.get(name, 0) + 1
            
            def timing(self, name, duration):
                if name not in self.timings:
                    self.timings[name] = []
                self.timings[name].append(duration)
            
            def get_stats(self):
                stats = {'counters': self.counters}
                
                for name, timings in self.timings.items():
                    stats[f'{name}_avg'] = sum(timings) / len(timings)
                    stats[f'{name}_count'] = len(timings)
                
                return stats
        
        metrics = SimpleMetrics()
        
        # ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãƒ†ã‚¹ãƒˆ
        metrics.increment('tasks_processed')
        metrics.increment('tasks_processed')
        metrics.increment('errors')
        
        # ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãƒ†ã‚¹ãƒˆ
        metrics.timing('task_duration', 1.5)
        metrics.timing('task_duration', 2.0)
        metrics.timing('task_duration', 1.2)
        
        stats = metrics.get_stats()
        
        assert stats['counters']['tasks_processed'] == 2
        assert stats['counters']['errors'] == 1
        assert abs(stats['task_duration_avg'] - 1.567) < 0.1  # ç´„1.567ç§’
        
        print(f"  âœ… ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†: {stats}")
        
        return True
        
    except Exception as e:
        print(f"  âŒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—: {e}")
        return False

async def test_system_workflow():
    """ã‚·ã‚¹ãƒ†ãƒ ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆ"""
    print("ğŸ”„ ã‚·ã‚¹ãƒ†ãƒ ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆ...")
    
    try:
        # ç°¡å˜ãªã‚¿ã‚¹ã‚¯å‡¦ç†ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        
        # 1. ã‚¿ã‚¹ã‚¯ãƒ‡ãƒ¼ã‚¿
        task = {
            'id': 'workflow_test_001',
            'type': 'code_generation',
            'prompt': 'Create a simple Python function',
            'priority': 5,
            'timestamp': time.time()
        }
        
        # 2. å…¥åŠ›æ¤œè¨¼
        from core.security_module import InputSanitizer
        sanitizer = InputSanitizer()
        clean_task = sanitizer.sanitize_json_input(task)
        
        assert clean_task['id'] == task['id']
        print(f"  âœ… å…¥åŠ›æ¤œè¨¼: ã‚¿ã‚¹ã‚¯ID {clean_task['id']}")
        
        # 3. éåŒæœŸå‡¦ç†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        async def process_task(task_data):
            # å‡¦ç†æ™‚é–“ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            await asyncio.sleep(0.1)
            
            return {
                'task_id': task_data['id'],
                'status': 'completed',
                'result': f"Processed: {task_data['prompt']}",
                'duration': 0.1,
                'files_created': ['output.py', 'test_output.py']
            }
        
        start_time = time.time()
        result = await process_task(clean_task)
        processing_time = time.time() - start_time
        
        assert result['status'] == 'completed'
        assert result['task_id'] == task['id']
        print(f"  âœ… ã‚¿ã‚¹ã‚¯å‡¦ç†: {processing_time:.3f}ç§’ã§å®Œäº†")
        
        # 4. çµæœæ¤œè¨¼
        assert 'files_created' in result
        assert len(result['files_created']) == 2
        print(f"  âœ… çµæœç”Ÿæˆ: {len(result['files_created'])} ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ")
        
        # 5. çµ±è¨ˆæ›´æ–°
        metrics = {
            'tasks_completed': 1,
            'total_processing_time': processing_time,
            'files_generated': len(result['files_created'])
        }
        
        print(f"  âœ… çµ±è¨ˆæ›´æ–°: {metrics}")
        
        return True
        
    except Exception as e:
        print(f"  âŒ ã‚·ã‚¹ãƒ†ãƒ ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆå¤±æ•—: {e}")
        return False

async def main():
    """çµ±åˆãƒ†ã‚¹ãƒˆã®ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œ"""
    print("ğŸš€ Elders Guild ã‚·ãƒ³ãƒ—ãƒ«çµ±åˆãƒ†ã‚¹ãƒˆé–‹å§‹")
    print("=" * 60)
    
    test_results = []
    
    # å„ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ
    tests = [
        ("ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŸºæœ¬æ©Ÿèƒ½", test_security_module_basic),
        ("éåŒæœŸå®Ÿè¡ŒåŸºæœ¬æ©Ÿèƒ½", test_async_execution_basic),
        ("ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ", test_file_operations),
        ("ãƒ­ãƒ¼ã‚«ãƒ«ãƒ¬ãƒ¼ãƒˆåˆ¶é™", test_local_rate_limiting),
        ("åŸºæœ¬ã‚­ãƒ£ãƒƒã‚·ãƒ¥", test_basic_caching),
        ("åŸºæœ¬ãƒ¡ãƒˆãƒªã‚¯ã‚¹", test_basic_metrics),
        ("ã‚·ã‚¹ãƒ†ãƒ ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼", test_system_workflow)
    ]
    
    for test_name, test_func in tests:
        print(f"\nğŸ“‹ {test_name}ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...")
        try:
            if asyncio.iscoroutinefunction(test_func):
                result = await test_func()
            else:
                result = test_func()
            test_results.append((test_name, result))
        except Exception as e:
            print(f"  âŒ {test_name}ãƒ†ã‚¹ãƒˆä¾‹å¤–: {e}")
            test_results.append((test_name, False))
    
    # çµæœã‚µãƒãƒªãƒ¼
    print("\n" + "=" * 60)
    print("ğŸ“Š ãƒ†ã‚¹ãƒˆçµæœã‚µãƒãƒªãƒ¼")
    print("=" * 60)
    
    passed = 0
    failed = 0
    
    for test_name, result in test_results:
        status = "âœ… PASS" if result else "âŒ FAIL"
        print(f"{status} {test_name}")
        if result:
            passed += 1
        else:
            failed += 1
    
    print(f"\nğŸ“ˆ ãƒ†ã‚¹ãƒˆçµ±è¨ˆ:")
    print(f"  æˆåŠŸ: {passed}ä»¶")
    print(f"  å¤±æ•—: {failed}ä»¶")
    print(f"  æˆåŠŸç‡: {passed / len(test_results) * 100:.1f}%")
    
    if failed == 0:
        print("\nğŸ‰ å…¨ã¦ã®ãƒ†ã‚¹ãƒˆãŒæˆåŠŸã—ã¾ã—ãŸï¼")
        print("ğŸš€ Elders Guild ã‚·ã‚¹ãƒ†ãƒ ã®åŸºæœ¬æ©Ÿèƒ½ã¯æ­£å¸¸ã«å‹•ä½œã—ã¦ã„ã¾ã™ã€‚")
        print("\nğŸ“‹ å‹•ä½œç¢ºèªæ¸ˆã¿æ©Ÿèƒ½:")
        print("  â€¢ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ¤œè¨¼ï¼ˆå…¥åŠ›ã‚µãƒ‹ã‚¿ã‚¤ã‚ºã€ãƒ‘ã‚¹æ¤œè¨¼ï¼‰")
        print("  â€¢ éåŒæœŸå‡¦ç†ï¼ˆä¸¦åˆ—å®Ÿè¡Œã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šï¼‰")
        print("  â€¢ ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œï¼ˆå®‰å…¨ãªä½œæˆãƒ»èª­ã¿è¾¼ã¿ï¼‰")
        print("  â€¢ ãƒ¬ãƒ¼ãƒˆåˆ¶é™ï¼ˆAPIä¿è­·ï¼‰")
        print("  â€¢ ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šï¼‰")
        print("  â€¢ ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ï¼ˆç›£è¦–ãƒ»åˆ†æï¼‰")
        print("  â€¢ çµ±åˆãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ï¼ˆã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰å‡¦ç†ï¼‰")
    else:
        print(f"\nâš ï¸ {failed}ä»¶ã®ãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã—ã¾ã—ãŸã€‚")
        print("ğŸ”§ ã‚·ã‚¹ãƒ†ãƒ ã®ä¿®æ­£ãŒå¿…è¦ã§ã™ã€‚")
    
    return failed == 0

if __name__ == "__main__":
    success = asyncio.run(main())
    exit(0 if success else 1)