#!/usr/bin/env python3
"""
Email Notification Worker - BaseWorkerç¶™æ‰¿ç‰ˆ
Gmail APIã‚’ä½¿ç”¨ã—ã¦ãƒ¡ãƒ¼ãƒ«é€šçŸ¥ã‚’é€ä¿¡
"""
import os
import sys
import json
import base64
import email
import pika
import traceback
import logging
from datetime import datetime
from pathlib import Path
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã‚’Pythonãƒ‘ã‚¹ã«è¿½åŠ 
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

from core.base_worker import BaseWorker
from core import ErrorSeverity

try:
    from google.auth.transport.requests import Request
    from google.oauth2.credentials import Credentials
    from google_auth_oauthlib.flow import InstalledAppFlow
    from googleapiclient.discovery import build
    from googleapiclient.errors import HttpError
    GMAIL_AVAILABLE = True
except ImportError:
    GMAIL_AVAILABLE = False


class EmailNotificationWorker(BaseWorker):
    """Gmail APIã‚’ä½¿ç”¨ã—ã¦ãƒ¡ãƒ¼ãƒ«é€šçŸ¥ã‚’é€ä¿¡ã™ã‚‹ãƒ¯ãƒ¼ã‚«ãƒ¼"""
    
    SCOPES = ['https://www.googleapis.com/auth/gmail.send']
    
    def __init__(self, worker_id="email-worker-1"):
        super().__init__(worker_type='email_notification', worker_id=worker_id)
        
        self.gmail_service = None
        self.credentials = None
        self.credentials_dir = PROJECT_ROOT / "credentials"
        self.credentials_dir.mkdir(exist_ok=True)
        
        if GMAIL_AVAILABLE:
            self._setup_gmail_service()
        else:
            self.logger.warning("Gmail API not available. Install with: pip install google-api-python-client google-auth-httplib2 google-auth-oauthlib")
    
    def setup_queues(self):
        """ãƒ¡ãƒ¼ãƒ«é€šçŸ¥ç”¨ã‚­ãƒ¥ãƒ¼ã®è¨­å®š"""
        self.input_queue = 'ai_email'
        self.output_queue = 'ai_results'
    
    def process_message(self, ch, method, properties, body):
        """ãƒ¡ãƒ¼ãƒ«é€ä¿¡ã‚¿ã‚¹ã‚¯å‡¦ç†"""
        try:
            task_data = json.loads(body)
            email_id = task_data.get('email_id', f"email_{datetime.now().strftime('%Y%m%d_%H%M%S')}")
            to_email = task_data.get('to', '')
            subject = task_data.get('subject', 'AI Companyé€šçŸ¥')
            message_text = task_data.get('message', '')
            attachments = task_data.get('attachments', [])
            
            self.logger.info(f"ğŸ“§ ãƒ¡ãƒ¼ãƒ«é€ä¿¡è¦æ±‚å—ä¿¡: {email_id}")
            self.logger.info(f"å®›å…ˆ: {to_email}")
            self.logger.info(f"ä»¶å: {subject}")
            
            if not GMAIL_AVAILABLE:
                # Gmail APIæœªä½¿ç”¨æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                result = self._send_email_fallback(email_id, to_email, subject, message_text)
            else:
                # Gmail APIã‚’ä½¿ç”¨
                result = self._send_email_gmail(email_id, to_email, subject, message_text, attachments)
            
            # çµæœã‚’è¿”é€
            response = {
                'email_id': email_id,
                'to': to_email,
                'subject': subject,
                'status': result['status'],
                'message': result['message'],
                'error': result.get('error'),
                'worker_id': self.worker_id
            }
            
            self._send_result(response)
            
            ch.basic_ack(delivery_tag=method.delivery_tag)
            self.logger.info(f"âœ… ãƒ¡ãƒ¼ãƒ«é€ä¿¡å®Œäº†: {email_id}")
            
        except Exception as e:
            # ãƒ¡ãƒ¼ãƒ«é€ä¿¡ã‚¨ãƒ©ãƒ¼
            context = {
                'operation': 'email_process_message',
                'email_id': task_data.get('email_id', 'unknown') if 'task_data' in locals() else 'unknown',
                'to': task_data.get('to', '') if 'task_data' in locals() else '',
                'subject': task_data.get('subject', '') if 'task_data' in locals() else ''
            }
            # ãƒ¡ãƒ¼ãƒ«ã¯é‡è¦åº¦ä¸­ç¨‹åº¦
            self.handle_error(e, context, severity=ErrorSeverity.MEDIUM)
            ch.basic_nack(delivery_tag=method.delivery_tag, requeue=True)
    
    def _setup_gmail_service(self):
        """Gmail APIã‚µãƒ¼ãƒ“ã‚¹ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—"""
        try:
            token_file = self.credentials_dir / "token.json"
            credentials_file = self.credentials_dir / "credentials.json"
            
            creds = None
            
            # ãƒˆãƒ¼ã‚¯ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€è³‡æ ¼æƒ…å ±ã‚’èª­ã¿è¾¼ã¿
            if token_file.exists():
                creds = Credentials.from_authorized_user_file(str(token_file), self.SCOPES)
            
            # æœ‰åŠ¹ãªè³‡æ ¼æƒ…å ±ãŒãªã„å ´åˆ
            if not creds or not creds.valid:
                if creds and creds.expired and creds.refresh_token:
                    creds.refresh(Request())
                else:
                    if not credentials_file.exists():
                        self.logger.error("Gmail credentials.json not found. OAuth setup required.")
                        return False
                    
                    flow = InstalledAppFlow.from_client_secrets_file(
                        str(credentials_file), self.SCOPES)
                    creds = flow.run_local_server(port=0)
                
                # è³‡æ ¼æƒ…å ±ã‚’ä¿å­˜
                with open(token_file, 'w') as token:
                    token.write(creds.to_json())
            
            self.credentials = creds
            self.gmail_service = build('gmail', 'v1', credentials=creds)
            self.logger.info("Gmail APIã‚µãƒ¼ãƒ“ã‚¹åˆæœŸåŒ–å®Œäº†")
            return True
            
        except Exception as e:
            self.logger.error(f"Gmail APIã‚µãƒ¼ãƒ“ã‚¹åˆæœŸåŒ–å¤±æ•—: {e}")
            return False
    
    def _send_email_gmail(self, email_id: str, to_email: str, subject: str, message_text: str, attachments: list = None) -> dict:
        """Gmail APIã‚’ä½¿ç”¨ã—ã¦ãƒ¡ãƒ¼ãƒ«é€ä¿¡"""
        try:
            if not self.gmail_service:
                return {
                    'status': 'failed',
                    'message': 'Gmail service not initialized',
                    'error': 'Gmail API not available'
                }
            
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä½œæˆ
            message = MIMEMultipart()
            message['to'] = to_email
            message['subject'] = subject
            
            # ãƒ¡ãƒ¼ãƒ«æœ¬æ–‡
            msg_body = MIMEText(message_text, 'plain', 'utf-8')
            message.attach(msg_body)
            
            # æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«
            if attachments:
                for attachment_path in attachments:
                    self._attach_file(message, attachment_path)
            
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
            raw_message = base64.urlsafe_b64encode(message.as_bytes()).decode('utf-8')
            
            # Gmail APIã§ãƒ¡ãƒ¼ãƒ«é€ä¿¡
            send_message = self.gmail_service.users().messages().send(
                userId='me',
                body={'raw': raw_message}
            ).execute()
            
            self.logger.info(f"âœ… Gmailé€ä¿¡æˆåŠŸ: {email_id} (Message ID: {send_message['id']})")
            
            return {
                'status': 'success',
                'message': f'Email sent successfully. Message ID: {send_message["id"]}',
                'gmail_message_id': send_message['id']
            }
            
        except HttpError as error:
            self.logger.error(f"Gmail API ã‚¨ãƒ©ãƒ¼: {error}")
            return {
                'status': 'failed',
                'message': 'Gmail API error occurred',
                'error': str(error)
            }
        except Exception as e:
            self.logger.error(f"ãƒ¡ãƒ¼ãƒ«é€ä¿¡ä¾‹å¤–: {e}")
            return {
                'status': 'failed',
                'message': 'Email sending failed',
                'error': str(e)
            }
    
    def _send_email_fallback(self, email_id: str, to_email: str, subject: str, message_text: str) -> dict:
        """Gmail APIæœªä½¿ç”¨æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†"""
        try:
            # ãƒ­ãƒ¼ã‚«ãƒ«ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
            email_log = {
                'email_id': email_id,
                'to': to_email,
                'subject': subject,
                'message': message_text,
                'timestamp': datetime.now().isoformat(),
                'status': 'logged_only'
            }
            
            log_file = PROJECT_ROOT / "logs" / "email_fallback.log"
            with open(log_file, 'a', encoding='utf-8') as f:
                f.write(json.dumps(email_log, ensure_ascii=False) + '\n')
            
            self.logger.info(f"ğŸ“ ãƒ¡ãƒ¼ãƒ«å†…å®¹ã‚’ãƒ­ã‚°ã«ä¿å­˜: {email_id}")
            
            return {
                'status': 'logged',
                'message': 'Email content saved to log file (Gmail API not available)',
                'log_file': str(log_file)
            }
            
        except Exception as e:
            return {
                'status': 'failed',
                'message': 'Fallback email logging failed',
                'error': str(e)
            }
    
    def _attach_file(self, message: MIMEMultipart, file_path: str):
        """ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«æ·»ä»˜"""
        try:
            file_path = Path(file_path)
            if not file_path.exists():
                self.logger.warning(f"æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {file_path}")
                return
            
            with open(file_path, 'rb') as attachment:
                part = MIMEBase('application', 'octet-stream')
                part.set_payload(attachment.read())
            
            encoders.encode_base64(part)
            part.add_header(
                'Content-Disposition',
                f'attachment; filename= {file_path.name}'
            )
            
            message.attach(part)
            self.logger.info(f"ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«æ·»ä»˜: {file_path.name}")
            
        except Exception as e:
            self.logger.error(f"ãƒ•ã‚¡ã‚¤ãƒ«æ·»ä»˜ã‚¨ãƒ©ãƒ¼: {e}")
    
    def _send_result(self, result_data: dict):
        """çµæœã‚’Outputã‚­ãƒ¥ãƒ¼ã«é€ä¿¡"""
        try:
            self.channel.basic_publish(
                exchange='',
                routing_key=self.output_queue,
                body=json.dumps(result_data, ensure_ascii=False),
                properties=self._get_message_properties()
            )
            self.logger.info(f"ğŸ“¤ çµæœé€ä¿¡: {result_data['email_id']}")
        except Exception as e:
            self.logger.error(f"çµæœé€ä¿¡ã‚¨ãƒ©ãƒ¼: {e}")
    
    def create_task_completion_email(self, task_id: str, task_result: dict) -> dict:
        """ã‚¿ã‚¹ã‚¯å®Œäº†ãƒ¡ãƒ¼ãƒ«ä½œæˆï¼ˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰"""
        subject = f"AI Company - ã‚¿ã‚¹ã‚¯å®Œäº†é€šçŸ¥: {task_id}"
        
        message = f"""
    def cleanup(self):
        """TODO: cleanupãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

    def stop(self):
        """TODO: stopãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

    def initialize(self) -> None:
        """ãƒ¯ãƒ¼ã‚«ãƒ¼ã®åˆæœŸåŒ–å‡¦ç†"""
        # TODO: åˆæœŸåŒ–ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„
        logger.info(f"{self.__class__.__name__} initialized")
        pass

    def handle_error(self):
        """TODO: handle_errorãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

    def get_status(self):
        """TODO: get_statusãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

    def validate_config(self):
        """TODO: validate_configãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

AI Company ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰ã®é€šçŸ¥ã§ã™ã€‚

ã‚¿ã‚¹ã‚¯ID: {task_id}
å®Ÿè¡Œæ™‚åˆ»: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
å®Ÿè¡Œçµæœ: {task_result.get('status', 'unknown')}

è©³ç´°:
{task_result.get('response', 'No details available')}

---
AI Company System
        """.strip()
        
        return {
            'email_id': f"task_completion_{task_id}",
            'subject': subject,
            'message': message,
            'attachments': task_result.get('attachments', [])
        }


if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description='Email Notification Worker')
    parser.add_argument('--worker-id', help='ãƒ¯ãƒ¼ã‚«ãƒ¼ID')
    parser.add_argument('--test', action='store_true', help='ãƒ†ã‚¹ãƒˆãƒ¡ãƒ¼ãƒ«é€ä¿¡')
    parser.add_argument('--to', help='ãƒ†ã‚¹ãƒˆãƒ¡ãƒ¼ãƒ«å®›å…ˆ')
    
    args = parser.parse_args()
    
    worker = EmailNotificationWorker(worker_id=args.worker_id)
    
    if args.test and args.to:
        # ãƒ†ã‚¹ãƒˆãƒ¡ãƒ¼ãƒ«é€ä¿¡
        test_email = {
            'email_id': 'test_email',
            'to': args.to,
            'subject': 'AI Company ãƒ†ã‚¹ãƒˆãƒ¡ãƒ¼ãƒ«',
            'message': 'ã“ã‚Œã¯AI Companyã‹ã‚‰ã®ãƒ†ã‚¹ãƒˆãƒ¡ãƒ¼ãƒ«ã§ã™ã€‚',
            'attachments': []
        }
        
        if GMAIL_AVAILABLE:
            result = worker._send_email_gmail(**test_email)
        else:
            result = worker._send_email_fallback(**test_email)
        
        print(f"ãƒ†ã‚¹ãƒˆãƒ¡ãƒ¼ãƒ«é€ä¿¡çµæœ: {result}")
    else:
        worker.start()