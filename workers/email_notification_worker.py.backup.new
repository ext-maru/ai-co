#!/usr/bin/env python3
"""
Email Notification Worker - BaseWorker継承版
Gmail APIを使用してメール通知を送信
"""
import os
import sys
import json
import base64
import email
import pika
import traceback
import logging
from datetime import datetime
from pathlib import Path
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders

# プロジェクトルートをPythonパスに追加
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

from core.base_worker import BaseWorker
from core import ErrorSeverity

try:
    from google.auth.transport.requests import Request
    from google.oauth2.credentials import Credentials
    from google_auth_oauthlib.flow import InstalledAppFlow
    from googleapiclient.discovery import build
    from googleapiclient.errors import HttpError
    GMAIL_AVAILABLE = True
except ImportError:
    GMAIL_AVAILABLE = False


class EmailNotificationWorker(BaseWorker):
    """Gmail APIを使用してメール通知を送信するワーカー"""
    
    SCOPES = ['https://www.googleapis.com/auth/gmail.send']
    
    def __init__(self, worker_id="email-worker-1"):
        super().__init__(worker_type='email_notification', worker_id=worker_id)
        
        self.gmail_service = None
        self.credentials = None
        self.credentials_dir = PROJECT_ROOT / "credentials"
        self.credentials_dir.mkdir(exist_ok=True)
        
        if GMAIL_AVAILABLE:
            self._setup_gmail_service()
        else:
            self.logger.warning("Gmail API not available. Install with: pip install google-api-python-client google-auth-httplib2 google-auth-oauthlib")
    
    def setup_queues(self):
        """メール通知用キューの設定"""
        self.input_queue = 'ai_email'
        self.output_queue = 'ai_results'
    
    def process_message(self, ch, method, properties, body):
        """メール送信タスク処理"""
        try:
            task_data = json.loads(body)
            email_id = task_data.get('email_id', f"email_{datetime.now().strftime('%Y%m%d_%H%M%S')}")
            to_email = task_data.get('to', '')
            subject = task_data.get('subject', 'AI Company通知')
            message_text = task_data.get('message', '')
            attachments = task_data.get('attachments', [])
            
            self.logger.info(f"📧 メール送信要求受信: {email_id}")
            self.logger.info(f"宛先: {to_email}")
            self.logger.info(f"件名: {subject}")
            
            if not GMAIL_AVAILABLE:
                # Gmail API未使用時のフォールバック
                result = self._send_email_fallback(email_id, to_email, subject, message_text)
            else:
                # Gmail APIを使用
                result = self._send_email_gmail(email_id, to_email, subject, message_text, attachments)
            
            # 結果を返送
            response = {
                'email_id': email_id,
                'to': to_email,
                'subject': subject,
                'status': result['status'],
                'message': result['message'],
                'error': result.get('error'),
                'worker_id': self.worker_id
            }
            
            self._send_result(response)
            
            ch.basic_ack(delivery_tag=method.delivery_tag)
            self.logger.info(f"✅ メール送信完了: {email_id}")
            
        except Exception as e:
            # メール送信エラー
            context = {
                'operation': 'email_process_message',
                'email_id': task_data.get('email_id', 'unknown') if 'task_data' in locals() else 'unknown',
                'to': task_data.get('to', '') if 'task_data' in locals() else '',
                'subject': task_data.get('subject', '') if 'task_data' in locals() else ''
            }
            # メールは重要度中程度
            self.handle_error(e, context, severity=ErrorSeverity.MEDIUM)
            ch.basic_nack(delivery_tag=method.delivery_tag, requeue=True)
    
    def _setup_gmail_service(self):
        """Gmail APIサービスのセットアップ"""
        try:
            token_file = self.credentials_dir / "token.json"
            credentials_file = self.credentials_dir / "credentials.json"
            
            creds = None
            
            # トークンファイルが存在する場合、資格情報を読み込み
            if token_file.exists():
                creds = Credentials.from_authorized_user_file(str(token_file), self.SCOPES)
            
            # 有効な資格情報がない場合
            if not creds or not creds.valid:
                if creds and creds.expired and creds.refresh_token:
                    creds.refresh(Request())
                else:
                    if not credentials_file.exists():
                        self.logger.error("Gmail credentials.json not found. OAuth setup required.")
                        return False
                    
                    flow = InstalledAppFlow.from_client_secrets_file(
                        str(credentials_file), self.SCOPES)
                    creds = flow.run_local_server(port=0)
                
                # 資格情報を保存
                with open(token_file, 'w') as token:
                    token.write(creds.to_json())
            
            self.credentials = creds
            self.gmail_service = build('gmail', 'v1', credentials=creds)
            self.logger.info("Gmail APIサービス初期化完了")
            return True
            
        except Exception as e:
            self.logger.error(f"Gmail APIサービス初期化失敗: {e}")
            return False
    
    def _send_email_gmail(self, email_id: str, to_email: str, subject: str, message_text: str, attachments: list = None) -> dict:
        """Gmail APIを使用してメール送信"""
        try:
            if not self.gmail_service:
                return {
                    'status': 'failed',
                    'message': 'Gmail service not initialized',
                    'error': 'Gmail API not available'
                }
            
            # メッセージ作成
            message = MIMEMultipart()
            message['to'] = to_email
            message['subject'] = subject
            
            # メール本文
            msg_body = MIMEText(message_text, 'plain', 'utf-8')
            message.attach(msg_body)
            
            # 添付ファイル
            if attachments:
                for attachment_path in attachments:
                    self._attach_file(message, attachment_path)
            
            # メッセージをBase64エンコード
            raw_message = base64.urlsafe_b64encode(message.as_bytes()).decode('utf-8')
            
            # Gmail APIでメール送信
            send_message = self.gmail_service.users().messages().send(
                userId='me',
                body={'raw': raw_message}
            ).execute()
            
            self.logger.info(f"✅ Gmail送信成功: {email_id} (Message ID: {send_message['id']})")
            
            return {
                'status': 'success',
                'message': f'Email sent successfully. Message ID: {send_message["id"]}',
                'gmail_message_id': send_message['id']
            }
            
        except HttpError as error:
            self.logger.error(f"Gmail API エラー: {error}")
            return {
                'status': 'failed',
                'message': 'Gmail API error occurred',
                'error': str(error)
            }
        except Exception as e:
            self.logger.error(f"メール送信例外: {e}")
            return {
                'status': 'failed',
                'message': 'Email sending failed',
                'error': str(e)
            }
    
    def _send_email_fallback(self, email_id: str, to_email: str, subject: str, message_text: str) -> dict:
        """Gmail API未使用時のフォールバック処理"""
        try:
            # ローカルログファイルに保存
            email_log = {
                'email_id': email_id,
                'to': to_email,
                'subject': subject,
                'message': message_text,
                'timestamp': datetime.now().isoformat(),
                'status': 'logged_only'
            }
            
            log_file = PROJECT_ROOT / "logs" / "email_fallback.log"
            with open(log_file, 'a', encoding='utf-8') as f:
                f.write(json.dumps(email_log, ensure_ascii=False) + '\n')
            
            self.logger.info(f"📝 メール内容をログに保存: {email_id}")
            
            return {
                'status': 'logged',
                'message': 'Email content saved to log file (Gmail API not available)',
                'log_file': str(log_file)
            }
            
        except Exception as e:
            return {
                'status': 'failed',
                'message': 'Fallback email logging failed',
                'error': str(e)
            }
    
    def _attach_file(self, message: MIMEMultipart, file_path: str):
        """ファイルをメッセージに添付"""
        try:
            file_path = Path(file_path)
            if not file_path.exists():
                self.logger.warning(f"添付ファイルが見つかりません: {file_path}")
                return
            
            with open(file_path, 'rb') as attachment:
                part = MIMEBase('application', 'octet-stream')
                part.set_payload(attachment.read())
            
            encoders.encode_base64(part)
            part.add_header(
                'Content-Disposition',
                f'attachment; filename= {file_path.name}'
            )
            
            message.attach(part)
            self.logger.info(f"📎 ファイル添付: {file_path.name}")
            
        except Exception as e:
            self.logger.error(f"ファイル添付エラー: {e}")
    
    def _send_result(self, result_data: dict):
        """結果をOutputキューに送信"""
        try:
            self.channel.basic_publish(
                exchange='',
                routing_key=self.output_queue,
                body=json.dumps(result_data, ensure_ascii=False),
                properties=self._get_message_properties()
            )
            self.logger.info(f"📤 結果送信: {result_data['email_id']}")
        except Exception as e:
            self.logger.error(f"結果送信エラー: {e}")
    
    def create_task_completion_email(self, task_id: str, task_result: dict) -> dict:
        """タスク完了メール作成（ユーティリティメソッド）"""
        subject = f"AI Company - タスク完了通知: {task_id}"
        
        message = f"""
    def cleanup(self):
        """TODO: cleanupメソッドを実装してください"""
        pass

    def stop(self):
        """TODO: stopメソッドを実装してください"""
        pass

    def initialize(self) -> None:
        """ワーカーの初期化処理"""
        # TODO: 初期化ロジックを実装してください
        logger.info(f"{self.__class__.__name__} initialized")
        pass

    def handle_error(self):
        """TODO: handle_errorメソッドを実装してください"""
        pass

    def get_status(self):
        """TODO: get_statusメソッドを実装してください"""
        pass

    def validate_config(self):
        """TODO: validate_configメソッドを実装してください"""
        pass

AI Company システムからの通知です。

タスクID: {task_id}
実行時刻: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
実行結果: {task_result.get('status', 'unknown')}

詳細:
{task_result.get('response', 'No details available')}

---
AI Company System
        """.strip()
        
        return {
            'email_id': f"task_completion_{task_id}",
            'subject': subject,
            'message': message,
            'attachments': task_result.get('attachments', [])
        }


if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description='Email Notification Worker')
    parser.add_argument('--worker-id', help='ワーカーID')
    parser.add_argument('--test', action='store_true', help='テストメール送信')
    parser.add_argument('--to', help='テストメール宛先')
    
    args = parser.parse_args()
    
    worker = EmailNotificationWorker(worker_id=args.worker_id)
    
    if args.test and args.to:
        # テストメール送信
        test_email = {
            'email_id': 'test_email',
            'to': args.to,
            'subject': 'AI Company テストメール',
            'message': 'これはAI Companyからのテストメールです。',
            'attachments': []
        }
        
        if GMAIL_AVAILABLE:
            result = worker._send_email_gmail(**test_email)
        else:
            result = worker._send_email_fallback(**test_email)
        
        print(f"テストメール送信結果: {result}")
    else:
        worker.start()