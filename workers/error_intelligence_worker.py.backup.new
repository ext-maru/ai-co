#!/usr/bin/env python3
"""
ã‚¨ãƒ©ãƒ¼æ™ºèƒ½åˆ¤æ–­ãƒ¯ãƒ¼ã‚«ãƒ¼
DLQã‹ã‚‰ã‚¨ãƒ©ãƒ¼ã‚’å–å¾—ã—, åˆ†æãƒ»åˆ†é¡ãƒ»ä¿®æ­£ã‚’è¡Œã†
"""

import json
import os
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional
import logging

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã‚’Pythonãƒ‘ã‚¹ã«è¿½åŠ 
import sys
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

from core.base_worker import BaseWorker
from core import get_config, EMOJI
from libs.error_intelligence_manager import ErrorIntelligenceManager
from libs.ai_command_helper import AICommandHelper
from libs.slack_notifier import SlackNotifier
from libs.auto_fix_executor import AutoFixExecutor
from libs.retry_orchestrator import RetryOrchestrator
from libs.incident_manager import IncidentManager


class ErrorIntelligenceWorker(BaseWorker):
    """ã‚¨ãƒ©ãƒ¼æ™ºèƒ½åˆ¤æ–­ã‚’è¡Œã†ãƒ¯ãƒ¼ã‚«ãƒ¼"""
    
    def __init__(self, worker_id: Optional[str] = None):
        super().__init__('error_intelligence', worker_id)
        self.manager = ErrorIntelligenceManager()
        self.command_helper = AICommandHelper()
        self.auto_fix_executor = AutoFixExecutor()
        self.retry_orchestrator = RetryOrchestrator()
        self.incident_manager = IncidentManager()
        self.config = get_config()
        self.slack_notifier = SlackNotifier()
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            'processed': 0,
            'auto_fixed': 0,
            'ignored': 0,
            'manual_required': 0
        }
        
        self.logger.info(f"ErrorIntelligenceWorker initialized (pid: {os.getpid()})")
    
    def process_message(self, ch, method, properties, body) -> None:
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ï¼ˆBaseWorkerã®æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰å®Ÿè£…ï¼‰"""
        # DLQãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å ´åˆã¯å°‚ç”¨å‡¦ç†ã‚’å‘¼ã³å‡ºã™
        if method.routing_key.endswith('_dlq'):
            self.process_dlq_message(ch, method, properties, body)
        else:
            # ã‚¨ãƒ©ãƒ¼åˆ†æãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å ´åˆ
            self.process_error_analysis(ch, method, properties, body)
    
    def setup_consumer(self):
        """DLQã‚’ç›£è¦–ã™ã‚‹ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒãƒ¼ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—"""
        # DLQã‚­ãƒ¥ãƒ¼ã‚’ç›´æ¥ç›£è¦–
        self.consume_queue('ai_tasks_dlq', self.process_dlq_message)
        self.consume_queue('ai_pm_dlq', self.process_dlq_message)
        self.consume_queue('ai_results_dlq', self.process_dlq_message)
        
        # ã‚¨ãƒ©ãƒ¼åˆ†æçµæœã‚’å—ã‘å–ã‚‹ã‚­ãƒ¥ãƒ¼
        self.consume_queue('ai_error_analysis', self.process_error_analysis)
    
    def process_dlq_message(self, ch, method, properties, body):
        """DLQãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡¦ç†"""
        try:
            self.stats['processed'] += 1
            
            # ãƒ‡ãƒãƒƒã‚°æƒ…å ±
            self.logger.info(f"DLQãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡: method={method}, properties={properties}")
            
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è§£æ
            if isinstance(body, bytes):
                body = body.decode('utf-8')
            
            message_data = json.loads(body) if isinstance(body, str) else body
            self.logger.info(f"ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿: {message_data}")
            
            # ã‚¨ãƒ©ãƒ¼æƒ…å ±ã®æŠ½å‡º
            error_info = self._extract_error_info(message_data, properties)
            
            # ã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦–ã™ã¹ãã‹åˆ¤æ–­
            if self.manager.should_ignore_error(error_info['error_text']):
                self.logger.info(f"Ignoring error: {error_info['error_text'][:100]}")
                self.stats['ignored'] += 1
                ch.basic_ack(delivery_tag=method.delivery_tag)
                return
            
            # ã‚¨ãƒ©ãƒ¼åˆ†æ
            analysis = self.manager.analyze_error(
                error_info['error_text'],
                context=error_info
            )
            
            self.logger.info(
                f"Error analyzed: {analysis['category']} | "
                f"Severity: {analysis['severity']} | "
                f"Auto-fixable: {analysis['auto_fixable']}"
            )
            
            # ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆä½œæˆï¼ˆé‡è¦åº¦ãŒé«˜ã„å ´åˆï¼‰
            if analysis['severity'] in ['high', 'critical'] or not analysis['auto_fixable']:
                incident_id = self._create_incident(analysis, error_info)
                self._last_incident_id = incident_id  # å¾Œã§å‚ç…§ã™ã‚‹ãŸã‚ä¿å­˜
                self.logger.info(f"Created incident: {incident_id}")
            
            # Phase 2: è‡ªå‹•ä¿®æ­£ã®å®Ÿè¡Œ
            if analysis['auto_fixable'] and analysis['fix_strategies']:
                # AutoFixExecutorã§ä¿®æ­£å®Ÿè¡Œ
                fix_result = self.auto_fix_executor.execute_fix(analysis, error_info)
                
                if fix_result['success']:
                    self.stats['auto_fixed'] += 1
                    self._notify_fix_success(analysis, fix_result)
                    
                    # RetryOrchestratorã§ãƒªãƒˆãƒ©ã‚¤ç®¡ç†
                    retry_result = self.retry_orchestrator.orchestrate_retry(
                        message_data,  # original task info
                        error_info,
                        fix_result
                    )
                    
                    if retry_result['retry_success']:
                        self.logger.info(
                            f"Task {error_info['task_id']} successfully retried after fix"
                        )
                        
                        # ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã‚’è‡ªå‹•è§£æ±º
                        if hasattr(self, '_last_incident_id') and self._last_incident_id:
                            self.incident_manager.resolve_incident(
                                self._last_incident_id,
                                resolution="è‡ªå‹•ä¿®æ­£ã«ã‚ˆã‚Šè§£æ±º",
                                actions_taken=[fix_result.get('strategy_used', 'unknown')],
                                root_cause=analysis['category'],
                                preventive_measures=["ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ã«è¿½åŠ "]
                            )
                else:
                    self._notify_fix_failure(analysis, fix_result)
            
            # äººé–“ã®ä»‹å…¥ãŒå¿…è¦ãªå ´åˆ
            if analysis['requires_human'] or analysis['severity'] == 'high':
                self.stats['manual_required'] += 1
                self._notify_human_required(analysis, error_info)
            
            ch.basic_ack(delivery_tag=method.delivery_tag)
            
        except Exception as e:
            import traceback
            self.logger.error(f"Error processing DLQ message: {str(e)}")
            self.logger.error(f"Traceback: {traceback.format_exc()}")
            # ã“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è‡ªä½“ã‚’DLQã«é€ã‚‰ãªã„ï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ï¼‰
            ch.basic_nack(delivery_tag=method.delivery_tag, requeue=False)
    
    def process_error_analysis(self, ch, method, properties, body):
        """ã‚¨ãƒ©ãƒ¼åˆ†æãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‡¦ç†"""
        try:
            request = json.loads(body) if isinstance(body, str) else body
            error_text = request.get('error_text', '')
            context = request.get('context', {})
            
            # ã‚¨ãƒ©ãƒ¼åˆ†æ
            analysis = self.manager.analyze_error(error_text, context)
            
            # çµæœã‚’è¿”é€
            response_queue = request.get('response_queue')
            if response_queue:
                self.send_to_queue(response_queue, analysis)
            
            ch.basic_ack(delivery_tag=method.delivery_tag)
            
        except Exception as e:
            self.logger.error(f"Error in error analysis: {str(e)}")
            ch.basic_nack(delivery_tag=method.delivery_tag, requeue=False)
    
    def _create_incident(self, analysis: Dict, error_info: Dict) -> str:
        """ã‚¨ãƒ©ãƒ¼ã«åŸºã¥ã„ã¦ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã‚’ä½œæˆ"""
        try:
            # ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã‚«ãƒ†ã‚´ãƒªã®ãƒãƒƒãƒ”ãƒ³ã‚°
            category_map = {
                'ModuleNotFoundError': 'error',
                'ConnectionError': 'failure',
                'PermissionError': 'security',
                'MemoryError': 'performance',
                'TimeoutError': 'performance'
            }
            
            incident_category = category_map.get(analysis['category'], 'error')
            
            # å„ªå…ˆåº¦ã®ãƒãƒƒãƒ”ãƒ³ã‚°
            priority_map = {
                'critical': 'critical',
                'high': 'high',
                'medium': 'medium',
                'low': 'low'
            }
            
            incident_priority = priority_map.get(analysis['severity'], 'medium')
            
            # ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆä½œæˆ
            incident_data = {
                'category': incident_category,
                'priority': incident_priority,
                'title': f"{analysis['category']}: {error_info['task_id']}",
                'description': f"{error_info['error_text'][:500]}\n\nåˆ†æçµæœ: {analysis.get('description', '')}",
                'affected_components': [error_info['worker_type'], error_info['task_type']],
                'impact': f"ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå¤±æ•— - è‡ªå‹•ä¿®æ­£{'å¯èƒ½' if analysis['auto_fixable'] else 'ä¸å¯'}",
                'assignee': 'ai_system' if analysis['auto_fixable'] else 'human',
                'metadata': {
                    'error_analysis': analysis,
                    'error_info': error_info
                }
            }
            
            incident_id = self.incident_manager.create_incident(**incident_data)
            
            # è‡ªå‹•ä¿®æ­£ãŒæˆåŠŸã—ãŸå ´åˆã€ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã‚’è‡ªå‹•è§£æ±º
            if analysis['auto_fixable']:
                self.incident_manager.add_action(
                    incident_id,
                    "è‡ªå‹•ä¿®æ­£ã‚’è©¦è¡Œä¸­",
                    {"strategies": analysis['fix_strategies']}
                )
            
            return incident_id
            
        except Exception as e:
            self.logger.error(f"Failed to create incident: {str(e)}")
            return None
    
    def _extract_error_info(self, message_data: Dict, properties) -> Dict:
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰ã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’æŠ½å‡º"""
        error_info = {
            'error_text': '',
            'task_id': message_data.get('task_id', 'unknown'),
            'task_type': message_data.get('task_type', 'unknown'),
            'worker_type': message_data.get('worker_type', 'unknown'),
            'timestamp': datetime.now().isoformat(),
            'original_message': message_data
        }
        
        # ã‚¨ãƒ©ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆã®æŠ½å‡º
        if 'error' in message_data:
            error_info['error_text'] = str(message_data['error'])
        elif 'exception' in message_data:
            error_info['error_text'] = str(message_data['exception'])
        elif 'stderr' in message_data:
            error_info['error_text'] = message_data['stderr']
        else:
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¨ä½“ã‹ã‚‰æ¨æ¸¬
            error_info['error_text'] = str(message_data)
        
        # ãƒ¯ãƒ¼ã‚«ãƒ¼ã‚¿ã‚¤ãƒ—ã®ç‰¹å®š (ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‹ã‚‰ã‚‚å–å¾—ã‚’è©¦è¡Œ)
        if properties and hasattr(properties, 'headers') and properties.headers:
            error_info['worker_type'] = properties.headers.get('x-worker-type', error_info['worker_type'])
        
        return error_info
    

    
    def _notify_fix_success(self, analysis: Dict, fix_result: Dict):
        """ä¿®æ­£æˆåŠŸã‚’é€šçŸ¥"""
        message = f"""
    def stop(self):
        """TODO: stopãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

    def initialize(self) -> None:
        """ãƒ¯ãƒ¼ã‚«ãƒ¼ã®åˆæœŸåŒ–å‡¦ç†"""
        # TODO: åˆæœŸåŒ–ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„
        logger.info(f"{self.__class__.__name__} initialized")
        pass

    def handle_error(self):
        """TODO: handle_errorãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

    def get_status(self):
        """TODO: get_statusãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

    def validate_config(self):
        """TODO: validate_configãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

{EMOJI['info']} **ã‚¨ãƒ©ãƒ¼è‡ªå‹•ä¿®æ­£å®Œäº† (Phase 2)**

**ã‚¨ãƒ©ãƒ¼ã‚«ãƒ†ã‚´ãƒª**: {analysis['category']}
**é‡è¦åº¦**: {analysis['severity']}
**ä¿®æ­£æˆ¦ç•¥**: {fix_result.get('strategy_used', 'N/A')}
**å®Ÿè¡Œæ™‚é–“**: {fix_result.get('execution_time', 0):.2f}ç§’
**æ¤œè¨¼**: {'âœ… æˆåŠŸ' if fix_result.get('verification_passed') else 'âŒ å¤±æ•—'}

å…ƒã®ã‚¿ã‚¹ã‚¯ã¯è‡ªå‹•çš„ã«å†è©¦è¡Œã•ã‚Œã¾ã™ã€‚
"""
        try:
            self.slack_notifier.send_message(message)
        except:
            self.logger.warning("Slack notification failed")
    
    def _notify_fix_failure(self, analysis: Dict, fix_result: Dict):
        """ä¿®æ­£å¤±æ•—ã‚’é€šçŸ¥"""
        message = f"""
{EMOJI['warning']} **ã‚¨ãƒ©ãƒ¼è‡ªå‹•ä¿®æ­£å¤±æ•—**

**ã‚¨ãƒ©ãƒ¼ã‚«ãƒ†ã‚´ãƒª**: {analysis['category']}
**é‡è¦åº¦**: {analysis['severity']}
**è©¦è¡Œã—ãŸæˆ¦ç•¥**: {fix_result.get('strategy_used', 'N/A')}
**ã‚¨ãƒ©ãƒ¼**: {fix_result.get('error', 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼')}
**ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯**: {'å®Ÿè¡Œæ¸ˆã¿' if fix_result.get('rollback_performed') else 'æœªå®Ÿè¡Œ'}

æ‰‹å‹•ã§ã®å¯¾å¿œãŒå¿…è¦ã§ã™ã€‚
"""
        try:
            self.slack_notifier.send_message(message)
        except:
            self.logger.warning("Slack notification failed")
    
    def _notify_human_required(self, analysis: Dict, error_info: Dict):
        """äººé–“ã®ä»‹å…¥ãŒå¿…è¦ãªå ´åˆã®é€šçŸ¥"""
        strategies_text = "\n".join([
            f"- {s['description']}: `{s['command']}`"
            for s in analysis['fix_strategies']
        ]) if analysis['fix_strategies'] else "ãªã—"
        
        message = f"""
{EMOJI['info']} **è¦å¯¾å¿œ: é«˜é‡è¦åº¦ã‚¨ãƒ©ãƒ¼**

**ã‚¿ã‚¹ã‚¯ID**: {error_info['task_id']}
**ã‚¨ãƒ©ãƒ¼ã‚«ãƒ†ã‚´ãƒª**: {analysis['category']}
**é‡è¦åº¦**: {analysis['severity']}

**ã‚¨ãƒ©ãƒ¼å†…å®¹**:
```
{error_info['error_text'][:500]}
```

**æ¨å¥¨ã•ã‚Œã‚‹å¯¾å‡¦æ³•**:
{strategies_text}

ã“ã®ã‚¨ãƒ©ãƒ¼ã¯è‡ªå‹•ä¿®æ­£ã§ãã¾ã›ã‚“ã€‚æ‰‹å‹•ã§ã®å¯¾å¿œã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚
"""
        try:
            self.slack_notifier.send_message(message)
        except:
            self.logger.warning("Slack notification failed")
    
    def get_statistics(self) -> Dict:
        """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        manager_stats = self.manager.get_error_statistics()
        worker_stats = self.stats.copy()
        executor_stats = self.auto_fix_executor.get_statistics()
        retry_stats = self.retry_orchestrator.get_retry_statistics()
        
        return {
            'worker_stats': worker_stats,
            'manager_stats': manager_stats,
            'executor_stats': executor_stats,
            'retry_stats': retry_stats,
            'auto_fix_rate': (
                worker_stats['auto_fixed'] / worker_stats['processed'] * 100
                if worker_stats['processed'] > 0 else 0
            ),
            'phase2_metrics': {
                'fix_success_rate': executor_stats.get('success_rate', 0),
                'retry_success_rate': retry_stats.get('success_rate', 0),
                'avg_fix_time': executor_stats.get('avg_execution_time', 0),
                'rollback_count': executor_stats.get('rollback_count', 0)
            }
        }
    
    def cleanup(self):
        """ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†"""
        super().cleanup()
        
        # çµ±è¨ˆæƒ…å ±ã‚’ãƒ­ã‚°å‡ºåŠ›
        stats = self.get_statistics()
        self.logger.info(
            f"ErrorIntelligenceWorker statistics: "
            f"Processed: {stats['worker_stats']['processed']} | "
            f"Auto-fixed: {stats['worker_stats']['auto_fixed']} | "
            f"Ignored: {stats['worker_stats']['ignored']} | "
            f"Manual required: {stats['worker_stats']['manual_required']} | "
            f"Auto-fix rate: {stats['auto_fix_rate']:.1f}%"
        )


if __name__ == "__main__":
    worker = ErrorIntelligenceWorker()
    
    # DLQã‚­ãƒ¥ãƒ¼ã‚’ç›£è¦–
    try:
        import pika
        connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
        channel = connection.channel()
        
        # DLQã‚­ãƒ¥ãƒ¼ã‚’å®£è¨€
        channel.queue_declare(queue='ai_tasks_dlq', durable=True)
        channel.queue_declare(queue='ai_pm_dlq', durable=True)
        channel.queue_declare(queue='ai_results_dlq', durable=True)
        
        print("ğŸ” ErrorIntelligenceWorkerç›£è¦–ä¸­... (DLQã‚’ç›£è¦–)")
        
        # DLQã‹ã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ¶ˆè²»
        channel.basic_consume(queue='ai_tasks_dlq', on_message_callback=worker.process_dlq_message, auto_ack=False)
        channel.basic_consume(queue='ai_pm_dlq', on_message_callback=worker.process_dlq_message, auto_ack=False)
        channel.basic_consume(queue='ai_results_dlq', on_message_callback=worker.process_dlq_message, auto_ack=False)
        
        channel.start_consuming()
        
    except KeyboardInterrupt:
        print("âŒ¨ï¸ åœæ­¢ä¸­...")
        channel.stop_consuming()
        connection.close()
    except Exception as e:
        print(f"âŒ ã‚¨ãƒ©ãƒ¼: {e}")
