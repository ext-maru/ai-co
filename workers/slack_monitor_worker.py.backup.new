#!/usr/bin/env python3
"""
AI Company Slack Monitor Worker
エラーログを監視してSlackへ自動通知
"""

import sys
import json
import time
import re
from pathlib import Path
from datetime import datetime
from collections import deque

# プロジェクトルートをPythonパスに追加
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

from core.base_worker_ja import BaseWorker
from core.config import get_config
from core.common_utils import EMOJI
from core import msg
from libs.slack_notifier import SlackNotifier

class SlackMonitorWorker(BaseWorker):
    """ログ監視とSlack通知を行うワーカー"""
    
    def __init__(self, worker_id=None):
        super().__init__(
            worker_type='slack_monitor',
            worker_id=worker_id
        )
        # 監視ワーカーなので入力/出力キューなし
        self.input_queue = None
        self.output_queue = None
        
        self.config = get_config()
        self.notifier = SlackNotifier()
        
        # 監視設定
        self.check_interval = self.config.get('slack.monitor_interval', 10)
        self.error_threshold = self.config.get('slack.error_threshold', 3)
        self.critical_keywords = self.config.get('slack.critical_keywords', [
            'CRITICAL', 'FATAL', 'ERROR', 'Exception', 'Traceback'
        ])
        
        # ログファイルパス
        self.log_dir = PROJECT_ROOT / 'logs'
        self.monitored_logs = [
            'task_worker.log',
            'pm_worker.log',
            'result_worker.log',
            'dialog_worker.log',
            'slack_polling_worker.log'
        ]
        
        # ファイルポジション記録
        self.file_positions = {}
        
        # エラーカウンター（短期間のエラー急増検知用）
        self.error_history = deque(maxlen=100)
        
    def run(self):
        """監視ループの実行"""
        self.logger.info(f"{EMOJI['start']} Slack Monitor Worker開始")
        self.logger.info(f"📂 監視対象: {len(self.monitored_logs)}個のログファイル")
        self.logger.info(f"⏱️  チェック間隔: {self.check_interval}秒")
        
        # 初期通知
        self._send_startup_notification()
        
        while not self.should_stop:
            try:
                # 各ログファイルをチェック
                for log_file in self.monitored_logs:
                    self._check_log_file(log_file)
                
                # エラー急増をチェック
                self._check_error_surge()
                
                # システム状態をチェック
                self._check_system_health()
                
                # 指定間隔待機
                time.sleep(self.check_interval)
                
            except KeyboardInterrupt:
                self.logger.info(f"{EMOJI['stop']} 監視停止シグナルを受信")
                break
            except Exception as e:
                self.handle_error(e, "monitoring_loop")
                time.sleep(self.check_interval * 2)
    
    def _check_log_file(self, log_filename):
        """ログファイルの新規エラーをチェック"""
        log_path = self.log_dir / log_filename
        
        if not log_path.exists():
            return
        
        try:
            # 前回の読み取り位置を取得
            last_position = self.file_positions.get(log_filename, 0)
            
            with open(log_path, 'r', encoding='utf-8', errors='ignore') as f:
                # 前回の位置から読み取り
                f.seek(last_position)
                new_lines = f.readlines()
                
                # 現在の位置を記録
                self.file_positions[log_filename] = f.tell()
            
            # エラーを検出
            errors = self._extract_errors(new_lines, log_filename)
            
            # エラーがあればSlack通知
            if errors:
                self._notify_errors(errors, log_filename)
                
        except Exception as e:
            self.logger.error(f"{EMOJI['error']} ログファイル読み取りエラー: {str(e)}")
    
    def _extract_errors(self, lines, source):
        """ログ行からエラーを抽出"""
        errors = []
        
        for line in lines:
            # クリティカルキーワードをチェック
            for keyword in self.critical_keywords:
                if keyword in line:
                    errors.append({
                        'timestamp': datetime.now().isoformat(),
                        'source': source,
                        'level': self._determine_error_level(line),
                        'message': line.strip(),
                        'keyword': keyword
                    })
                    
                    # エラー履歴に追加
                    self.error_history.append(datetime.now())
                    break
        
        return errors
    
    def _determine_error_level(self, line):
        """エラーレベルを判定"""
        line_upper = line.upper()
        if 'CRITICAL' in line_upper or 'FATAL' in line_upper:
            return 'critical'
        elif 'ERROR' in line_upper or 'Exception' in line:
            return 'error'
        elif 'WARNING' in line_upper or 'WARN' in line_upper:
            return 'warning'
        else:
            return 'info'
    
    def _notify_errors(self, errors, source):
        """エラーをSlackに通知"""
        # レベル別にグループ化
        critical_errors = [e for e in errors if e['level'] == 'critical']
        normal_errors = [e for e in errors if e['level'] == 'error']
        
        # クリティカルエラーは即座に通知
        if critical_errors:
            message = self._format_critical_notification(critical_errors, source)
            self.notifier.send_error(message, mention=True)
            self.logger.warning(f"{EMOJI['warning']} クリティカルエラー通知送信: {len(critical_errors)}件")
        
        # 通常エラーは閾値を超えた場合のみ通知
        elif len(normal_errors) >= self.error_threshold:
            message = self._format_error_notification(normal_errors, source)
            self.notifier.send_error(message)
            self.logger.info(f"{EMOJI['info']} エラー通知送信: {len(normal_errors)}件")
    
    def _format_critical_notification(self, errors, source):
        """クリティカルエラー通知のフォーマット"""
        error_details = '\n'.join([
            f"• {e['message'][:200]}..." if len(e['message']) > 200 else f"• {e['message']}"
            for e in errors[:5]  # 最大5件
        ])
        
        return f"""🚨 *CRITICAL ERROR DETECTED*
    def cleanup(self):
        """TODO: cleanupメソッドを実装してください"""
        pass

    def stop(self):
        """TODO: stopメソッドを実装してください"""
        pass

    def initialize(self) -> None:
        """ワーカーの初期化処理"""
        # TODO: 初期化ロジックを実装してください
        logger.info(f"{self.__class__.__name__} initialized")
        pass

    def handle_error(self):
        """TODO: handle_errorメソッドを実装してください"""
        pass

    def get_status(self):
        """TODO: get_statusメソッドを実装してください"""
        pass

    def validate_config(self):
        """TODO: validate_configメソッドを実装してください"""
        pass

    def cleanup(self):
        """TODO: cleanupメソッドを実装してください"""
        pass

    def stop(self):
        """TODO: stopメソッドを実装してください"""
        pass

    def initialize(self) -> None:
        """ワーカーの初期化処理"""
        # TODO: 初期化ロジックを実装してください
        logger.info(f"{self.__class__.__name__} initialized")
        pass

    def handle_error(self):
        """TODO: handle_errorメソッドを実装してください"""
        pass

    def get_status(self):
        """TODO: get_statusメソッドを実装してください"""
        pass

    def validate_config(self):
        """TODO: validate_configメソッドを実装してください"""
        pass

━━━━━━━━━━━━━━━━━━━━━━
📍 *Source:* `{source}`
🔢 *Count:* {len(errors)} critical errors
⏰ *Time:* {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

📋 *Error Details:*
```
{error_details}
```

⚠️ *Immediate attention required!*"""
    
    def _format_error_notification(self, errors, source):
        """通常エラー通知のフォーマット"""
        error_summary = {}
        for error in errors:
            keyword = error['keyword']
            error_summary[keyword] = error_summary.get(keyword, 0) + 1
        
        summary_text = '\n'.join([
            f"• {keyword}: {count}件"
            for keyword, count in error_summary.items()
        ])
        
        return f"""⚠️ *Error Alert*
━━━━━━━━━━━━━━━━━━━━━━
📍 *Source:* `{source}`
🔢 *Total:* {len(errors)} errors detected
⏰ *Time:* {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

📊 *Error Summary:*
{summary_text}

💡 詳細はログファイルを確認してください"""
    
    def _check_error_surge(self):
        """短期間のエラー急増をチェック"""
        if len(self.error_history) < 10:
            return
        
        # 直近1分のエラー数をカウント
        now = datetime.now()
        recent_errors = [
            err_time for err_time in self.error_history
            if (now - err_time).total_seconds() < 60
        ]
        
        # 閾値を超えたら通知
        surge_threshold = self.config.get('slack.error_surge_threshold', 20)
        if len(recent_errors) >= surge_threshold:
            message = f"""🌊 *Error Surge Detected*
━━━━━━━━━━━━━━━━━━━━━━
⚡ *{len(recent_errors)} errors in the last minute!*
⏰ *Time:* {now.strftime('%Y-%m-%d %H:%M:%S')}

🔍 システムに異常が発生している可能性があります。
早急な確認をお願いします。"""
            
            self.notifier.send_error(message, mention=True)
            self.logger.critical(f"{EMOJI['error']} エラー急増検知: 1分間に{len(recent_errors)}件")
            
            # 履歴をクリア（連続通知を防ぐ）
            self.error_history.clear()
    
    def _check_system_health(self):
        """システム全体の健全性をチェック"""
        try:
            import psutil
            
            # CPU使用率
            cpu_percent = psutil.cpu_percent(interval=1)
            
            # メモリ使用率
            memory = psutil.virtual_memory()
            
            # ディスク使用率
            disk = psutil.disk_usage('/')
            
            # 閾値チェック
            alerts = []
            
            if cpu_percent > 90:
                alerts.append(f"🔥 CPU使用率: {cpu_percent}%")
            
            if memory.percent > 90:
                alerts.append(f"💾 メモリ使用率: {memory.percent}%")
            
            if disk.percent > 90:
                alerts.append(f"💿 ディスク使用率: {disk.percent}%")
            
            # アラートがあれば通知
            if alerts:
                message = f"""🏥 *System Health Alert*
━━━━━━━━━━━━━━━━━━━━━━
{chr(10).join(alerts)}

📊 *Current Status:*
• CPU: {cpu_percent}%
• Memory: {memory.percent}% ({memory.used // (1024**3)}GB / {memory.total // (1024**3)}GB)
• Disk: {disk.percent}% ({disk.used // (1024**3)}GB / {disk.total // (1024**3)}GB)"""
                
                self.notifier.send_warning(message)
                self.logger.warning(f"{EMOJI['warning']} システムリソース警告")
                
        except Exception as e:
            self.logger.error(f"{EMOJI['error']} システムヘルスチェックエラー: {str(e)}")
    
    def _send_startup_notification(self):
        """起動通知を送信"""
        message = f"""🤖 *Slack Monitor Started*
━━━━━━━━━━━━━━━━━━━━━━
✅ AI Company監視システムが起動しました

📋 *監視対象:*
{chr(10).join(['• ' + log for log in self.monitored_logs])}

⚙️ *設定:*
• チェック間隔: {self.check_interval}秒
• エラー閾値: {self.error_threshold}件
• 監視キーワード: {len(self.critical_keywords)}個

🔍 システムの監視を開始します..."""
        
        self.notifier.send_success(message)
    
    def process_message(self, ch, method, properties, body):
        """BaseWorkerの抽象メソッド実装（監視ワーカーなので使用しない）"""
        pass

def main():
    """メイン実行"""
    import argparse
    parser = argparse.ArgumentParser(description='Slack Monitor Worker')
    parser.add_argument('--worker-id', help='Worker ID')
    parser.add_argument('--test', action='store_true', help='テストモード')
    
    args = parser.parse_args()
    
    if args.test:
        print(f"{EMOJI['test']} テストモード: Slack Monitor Worker")
        print("✅ ワーカーは正常に初期化できます")
        return
    
    worker = SlackMonitorWorker(worker_id=args.worker_id)
    
    try:
        worker.start()
    except KeyboardInterrupt:
        print(f"\n{EMOJI['stop']} Slack Monitor Worker停止")
    finally:
        worker.cleanup()

if __name__ == "__main__":
    main()
