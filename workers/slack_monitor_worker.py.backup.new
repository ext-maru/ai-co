#!/usr/bin/env python3
"""
AI Company Slack Monitor Worker
ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚’ç›£è¦–ã—ã¦Slackã¸è‡ªå‹•é€šçŸ¥
"""

import sys
import json
import time
import re
from pathlib import Path
from datetime import datetime
from collections import deque

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã‚’Pythonãƒ‘ã‚¹ã«è¿½åŠ 
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

from core.base_worker_ja import BaseWorker
from core.config import get_config
from core.common_utils import EMOJI
from core import msg
from libs.slack_notifier import SlackNotifier

class SlackMonitorWorker(BaseWorker):
    """ãƒ­ã‚°ç›£è¦–ã¨Slacké€šçŸ¥ã‚’è¡Œã†ãƒ¯ãƒ¼ã‚«ãƒ¼"""
    
    def __init__(self, worker_id=None):
        super().__init__(
            worker_type='slack_monitor',
            worker_id=worker_id
        )
        # ç›£è¦–ãƒ¯ãƒ¼ã‚«ãƒ¼ãªã®ã§å…¥åŠ›/å‡ºåŠ›ã‚­ãƒ¥ãƒ¼ãªã—
        self.input_queue = None
        self.output_queue = None
        
        self.config = get_config()
        self.notifier = SlackNotifier()
        
        # ç›£è¦–è¨­å®š
        self.check_interval = self.config.get('slack.monitor_interval', 10)
        self.error_threshold = self.config.get('slack.error_threshold', 3)
        self.critical_keywords = self.config.get('slack.critical_keywords', [
            'CRITICAL', 'FATAL', 'ERROR', 'Exception', 'Traceback'
        ])
        
        # ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
        self.log_dir = PROJECT_ROOT / 'logs'
        self.monitored_logs = [
            'task_worker.log',
            'pm_worker.log',
            'result_worker.log',
            'dialog_worker.log',
            'slack_polling_worker.log'
        ]
        
        # ãƒ•ã‚¡ã‚¤ãƒ«ãƒã‚¸ã‚·ãƒ§ãƒ³è¨˜éŒ²
        self.file_positions = {}
        
        # ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ï¼ˆçŸ­æœŸé–“ã®ã‚¨ãƒ©ãƒ¼æ€¥å¢—æ¤œçŸ¥ç”¨ï¼‰
        self.error_history = deque(maxlen=100)
        
    def run(self):
        """ç›£è¦–ãƒ«ãƒ¼ãƒ—ã®å®Ÿè¡Œ"""
        self.logger.info(f"{EMOJI['start']} Slack Monitor Workeré–‹å§‹")
        self.logger.info(f"ğŸ“‚ ç›£è¦–å¯¾è±¡: {len(self.monitored_logs)}å€‹ã®ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«")
        self.logger.info(f"â±ï¸  ãƒã‚§ãƒƒã‚¯é–“éš”: {self.check_interval}ç§’")
        
        # åˆæœŸé€šçŸ¥
        self._send_startup_notification()
        
        while not self.should_stop:
            try:
                # å„ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯
                for log_file in self.monitored_logs:
                    self._check_log_file(log_file)
                
                # ã‚¨ãƒ©ãƒ¼æ€¥å¢—ã‚’ãƒã‚§ãƒƒã‚¯
                self._check_error_surge()
                
                # ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
                self._check_system_health()
                
                # æŒ‡å®šé–“éš”å¾…æ©Ÿ
                time.sleep(self.check_interval)
                
            except KeyboardInterrupt:
                self.logger.info(f"{EMOJI['stop']} ç›£è¦–åœæ­¢ã‚·ã‚°ãƒŠãƒ«ã‚’å—ä¿¡")
                break
            except Exception as e:
                self.handle_error(e, "monitoring_loop")
                time.sleep(self.check_interval * 2)
    
    def _check_log_file(self, log_filename):
        """ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®æ–°è¦ã‚¨ãƒ©ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯"""
        log_path = self.log_dir / log_filename
        
        if not log_path.exists():
            return
        
        try:
            # å‰å›ã®èª­ã¿å–ã‚Šä½ç½®ã‚’å–å¾—
            last_position = self.file_positions.get(log_filename, 0)
            
            with open(log_path, 'r', encoding='utf-8', errors='ignore') as f:
                # å‰å›ã®ä½ç½®ã‹ã‚‰èª­ã¿å–ã‚Š
                f.seek(last_position)
                new_lines = f.readlines()
                
                # ç¾åœ¨ã®ä½ç½®ã‚’è¨˜éŒ²
                self.file_positions[log_filename] = f.tell()
            
            # ã‚¨ãƒ©ãƒ¼ã‚’æ¤œå‡º
            errors = self._extract_errors(new_lines, log_filename)
            
            # ã‚¨ãƒ©ãƒ¼ãŒã‚ã‚Œã°Slacké€šçŸ¥
            if errors:
                self._notify_errors(errors, log_filename)
                
        except Exception as e:
            self.logger.error(f"{EMOJI['error']} ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿å–ã‚Šã‚¨ãƒ©ãƒ¼: {str(e)}")
    
    def _extract_errors(self, lines, source):
        """ãƒ­ã‚°è¡Œã‹ã‚‰ã‚¨ãƒ©ãƒ¼ã‚’æŠ½å‡º"""
        errors = []
        
        for line in lines:
            # ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒã‚§ãƒƒã‚¯
            for keyword in self.critical_keywords:
                if keyword in line:
                    errors.append({
                        'timestamp': datetime.now().isoformat(),
                        'source': source,
                        'level': self._determine_error_level(line),
                        'message': line.strip(),
                        'keyword': keyword
                    })
                    
                    # ã‚¨ãƒ©ãƒ¼å±¥æ­´ã«è¿½åŠ 
                    self.error_history.append(datetime.now())
                    break
        
        return errors
    
    def _determine_error_level(self, line):
        """ã‚¨ãƒ©ãƒ¼ãƒ¬ãƒ™ãƒ«ã‚’åˆ¤å®š"""
        line_upper = line.upper()
        if 'CRITICAL' in line_upper or 'FATAL' in line_upper:
            return 'critical'
        elif 'ERROR' in line_upper or 'Exception' in line:
            return 'error'
        elif 'WARNING' in line_upper or 'WARN' in line_upper:
            return 'warning'
        else:
            return 'info'
    
    def _notify_errors(self, errors, source):
        """ã‚¨ãƒ©ãƒ¼ã‚’Slackã«é€šçŸ¥"""
        # ãƒ¬ãƒ™ãƒ«åˆ¥ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
        critical_errors = [e for e in errors if e['level'] == 'critical']
        normal_errors = [e for e in errors if e['level'] == 'error']
        
        # ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚¨ãƒ©ãƒ¼ã¯å³åº§ã«é€šçŸ¥
        if critical_errors:
            message = self._format_critical_notification(critical_errors, source)
            self.notifier.send_error(message, mention=True)
            self.logger.warning(f"{EMOJI['warning']} ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚¨ãƒ©ãƒ¼é€šçŸ¥é€ä¿¡: {len(critical_errors)}ä»¶")
        
        # é€šå¸¸ã‚¨ãƒ©ãƒ¼ã¯é–¾å€¤ã‚’è¶…ãˆãŸå ´åˆã®ã¿é€šçŸ¥
        elif len(normal_errors) >= self.error_threshold:
            message = self._format_error_notification(normal_errors, source)
            self.notifier.send_error(message)
            self.logger.info(f"{EMOJI['info']} ã‚¨ãƒ©ãƒ¼é€šçŸ¥é€ä¿¡: {len(normal_errors)}ä»¶")
    
    def _format_critical_notification(self, errors, source):
        """ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚¨ãƒ©ãƒ¼é€šçŸ¥ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        error_details = '\n'.join([
            f"â€¢ {e['message'][:200]}..." if len(e['message']) > 200 else f"â€¢ {e['message']}"
            for e in errors[:5]  # æœ€å¤§5ä»¶
        ])
        
        return f"""ğŸš¨ *CRITICAL ERROR DETECTED*
    def cleanup(self):
        """TODO: cleanupãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

    def stop(self):
        """TODO: stopãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

    def initialize(self) -> None:
        """ãƒ¯ãƒ¼ã‚«ãƒ¼ã®åˆæœŸåŒ–å‡¦ç†"""
        # TODO: åˆæœŸåŒ–ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„
        logger.info(f"{self.__class__.__name__} initialized")
        pass

    def handle_error(self):
        """TODO: handle_errorãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

    def get_status(self):
        """TODO: get_statusãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

    def validate_config(self):
        """TODO: validate_configãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

    def cleanup(self):
        """TODO: cleanupãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

    def stop(self):
        """TODO: stopãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

    def initialize(self) -> None:
        """ãƒ¯ãƒ¼ã‚«ãƒ¼ã®åˆæœŸåŒ–å‡¦ç†"""
        # TODO: åˆæœŸåŒ–ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„
        logger.info(f"{self.__class__.__name__} initialized")
        pass

    def handle_error(self):
        """TODO: handle_errorãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

    def get_status(self):
        """TODO: get_statusãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

    def validate_config(self):
        """TODO: validate_configãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„"""
        pass

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ *Source:* `{source}`
ğŸ”¢ *Count:* {len(errors)} critical errors
â° *Time:* {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

ğŸ“‹ *Error Details:*
```
{error_details}
```

âš ï¸ *Immediate attention required!*"""
    
    def _format_error_notification(self, errors, source):
        """é€šå¸¸ã‚¨ãƒ©ãƒ¼é€šçŸ¥ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        error_summary = {}
        for error in errors:
            keyword = error['keyword']
            error_summary[keyword] = error_summary.get(keyword, 0) + 1
        
        summary_text = '\n'.join([
            f"â€¢ {keyword}: {count}ä»¶"
            for keyword, count in error_summary.items()
        ])
        
        return f"""âš ï¸ *Error Alert*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ *Source:* `{source}`
ğŸ”¢ *Total:* {len(errors)} errors detected
â° *Time:* {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

ğŸ“Š *Error Summary:*
{summary_text}

ğŸ’¡ è©³ç´°ã¯ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„"""
    
    def _check_error_surge(self):
        """çŸ­æœŸé–“ã®ã‚¨ãƒ©ãƒ¼æ€¥å¢—ã‚’ãƒã‚§ãƒƒã‚¯"""
        if len(self.error_history) < 10:
            return
        
        # ç›´è¿‘1åˆ†ã®ã‚¨ãƒ©ãƒ¼æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
        now = datetime.now()
        recent_errors = [
            err_time for err_time in self.error_history
            if (now - err_time).total_seconds() < 60
        ]
        
        # é–¾å€¤ã‚’è¶…ãˆãŸã‚‰é€šçŸ¥
        surge_threshold = self.config.get('slack.error_surge_threshold', 20)
        if len(recent_errors) >= surge_threshold:
            message = f"""ğŸŒŠ *Error Surge Detected*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ *{len(recent_errors)} errors in the last minute!*
â° *Time:* {now.strftime('%Y-%m-%d %H:%M:%S')}

ğŸ” ã‚·ã‚¹ãƒ†ãƒ ã«ç•°å¸¸ãŒç™ºç”Ÿã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
æ—©æ€¥ãªç¢ºèªã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚"""
            
            self.notifier.send_error(message, mention=True)
            self.logger.critical(f"{EMOJI['error']} ã‚¨ãƒ©ãƒ¼æ€¥å¢—æ¤œçŸ¥: 1åˆ†é–“ã«{len(recent_errors)}ä»¶")
            
            # å±¥æ­´ã‚’ã‚¯ãƒªã‚¢ï¼ˆé€£ç¶šé€šçŸ¥ã‚’é˜²ãï¼‰
            self.error_history.clear()
    
    def _check_system_health(self):
        """ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®å¥å…¨æ€§ã‚’ãƒã‚§ãƒƒã‚¯"""
        try:
            import psutil
            
            # CPUä½¿ç”¨ç‡
            cpu_percent = psutil.cpu_percent(interval=1)
            
            # ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡
            memory = psutil.virtual_memory()
            
            # ãƒ‡ã‚£ã‚¹ã‚¯ä½¿ç”¨ç‡
            disk = psutil.disk_usage('/')
            
            # é–¾å€¤ãƒã‚§ãƒƒã‚¯
            alerts = []
            
            if cpu_percent > 90:
                alerts.append(f"ğŸ”¥ CPUä½¿ç”¨ç‡: {cpu_percent}%")
            
            if memory.percent > 90:
                alerts.append(f"ğŸ’¾ ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡: {memory.percent}%")
            
            if disk.percent > 90:
                alerts.append(f"ğŸ’¿ ãƒ‡ã‚£ã‚¹ã‚¯ä½¿ç”¨ç‡: {disk.percent}%")
            
            # ã‚¢ãƒ©ãƒ¼ãƒˆãŒã‚ã‚Œã°é€šçŸ¥
            if alerts:
                message = f"""ğŸ¥ *System Health Alert*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
{chr(10).join(alerts)}

ğŸ“Š *Current Status:*
â€¢ CPU: {cpu_percent}%
â€¢ Memory: {memory.percent}% ({memory.used // (1024**3)}GB / {memory.total // (1024**3)}GB)
â€¢ Disk: {disk.percent}% ({disk.used // (1024**3)}GB / {disk.total // (1024**3)}GB)"""
                
                self.notifier.send_warning(message)
                self.logger.warning(f"{EMOJI['warning']} ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚½ãƒ¼ã‚¹è­¦å‘Š")
                
        except Exception as e:
            self.logger.error(f"{EMOJI['error']} ã‚·ã‚¹ãƒ†ãƒ ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: {str(e)}")
    
    def _send_startup_notification(self):
        """èµ·å‹•é€šçŸ¥ã‚’é€ä¿¡"""
        message = f"""ğŸ¤– *Slack Monitor Started*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… AI Companyç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ãŒèµ·å‹•ã—ã¾ã—ãŸ

ğŸ“‹ *ç›£è¦–å¯¾è±¡:*
{chr(10).join(['â€¢ ' + log for log in self.monitored_logs])}

âš™ï¸ *è¨­å®š:*
â€¢ ãƒã‚§ãƒƒã‚¯é–“éš”: {self.check_interval}ç§’
â€¢ ã‚¨ãƒ©ãƒ¼é–¾å€¤: {self.error_threshold}ä»¶
â€¢ ç›£è¦–ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: {len(self.critical_keywords)}å€‹

ğŸ” ã‚·ã‚¹ãƒ†ãƒ ã®ç›£è¦–ã‚’é–‹å§‹ã—ã¾ã™..."""
        
        self.notifier.send_success(message)
    
    def process_message(self, ch, method, properties, body):
        """BaseWorkerã®æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰å®Ÿè£…ï¼ˆç›£è¦–ãƒ¯ãƒ¼ã‚«ãƒ¼ãªã®ã§ä½¿ç”¨ã—ãªã„ï¼‰"""
        pass

def main():
    """ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œ"""
    import argparse
    parser = argparse.ArgumentParser(description='Slack Monitor Worker')
    parser.add_argument('--worker-id', help='Worker ID')
    parser.add_argument('--test', action='store_true', help='ãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰')
    
    args = parser.parse_args()
    
    if args.test:
        print(f"{EMOJI['test']} ãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰: Slack Monitor Worker")
        print("âœ… ãƒ¯ãƒ¼ã‚«ãƒ¼ã¯æ­£å¸¸ã«åˆæœŸåŒ–ã§ãã¾ã™")
        return
    
    worker = SlackMonitorWorker(worker_id=args.worker_id)
    
    try:
        worker.start()
    except KeyboardInterrupt:
        print(f"\n{EMOJI['stop']} Slack Monitor Workeråœæ­¢")
    finally:
        worker.cleanup()

if __name__ == "__main__":
    main()
