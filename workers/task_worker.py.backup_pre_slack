#!/usr/bin/env python3
import os
import sys
import json
import subprocess
import pika
import traceback
from datetime import datetime
from pathlib import Path
import logging

# RAGã‚·ã‚¹ãƒ†ãƒ ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
sys.path.append(str(Path(__file__).parent.parent))
from libs.rag_manager import RAGManager

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
PROJECT_DIR = Path(__file__).parent.parent
OUTPUT_DIR = PROJECT_DIR / "output"
LOG_DIR = PROJECT_DIR / "logs"

# ãƒ­ã‚°è¨­å®š
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [TaskWorker] %(levelname)s: %(message)s',
    handlers=[
        logging.FileHandler(LOG_DIR / "task_worker.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("TaskWorker")

class TaskWorker:
    def __init__(self, worker_id="worker-1"):
        self.worker_id = worker_id
        self.model = "claude-sonnet-4-20250514"
        # RAGãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼åˆæœŸåŒ–
        self.rag = RAGManager(model=self.model)

    def connect(self):
        try:
            self.connection = pika.BlockingConnection(
                pika.ConnectionParameters('localhost')
            )
            self.channel = self.connection.channel()
            self.channel.queue_declare(queue='task_queue', durable=True)
            self.channel.queue_declare(queue='result_queue', durable=True)
            logger.info(f"{self.worker_id} - RabbitMQæŽ¥ç¶šæˆåŠŸ")
            return True
        except Exception as e:
            logger.error(f"RabbitMQæŽ¥ç¶šå¤±æ•—: {e}")
            return False

    def process_task(self, ch, method, properties, body):
        try:
            task = json.loads(body)
            task_id = task.get('task_id', f'unknown_{datetime.now().strftime("%Y%m%d_%H%M%S")}')
            prompt = task.get('prompt', '')
            task_type = task.get('type', 'general')

            logger.info(f"ã‚¿ã‚¹ã‚¯å—ä¿¡: {task_id} (ã‚¿ã‚¤ãƒ—: {task_type})")
            logger.info(f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ(å…ˆé ­100æ–‡å­—): {prompt[:100]}")

            # ðŸ§  RAGæ©Ÿèƒ½ï¼šéŽåŽ»ã®å±¥æ­´ã‚’å«ã‚ãŸãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
            enhanced_prompt = self.rag.build_context_prompt(prompt, include_history=True)
            if len(enhanced_prompt) > len(prompt):
                logger.info(f"âœ¨ RAGé©ç”¨: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ‹¡å¼µ {len(prompt)} â†’ {len(enhanced_prompt)} æ–‡å­—")

            # ä¿å­˜ãƒ•ã‚©ãƒ«ãƒ€ä½œæˆ
            task_output_dir = OUTPUT_DIR / task_type / task_id
            os.makedirs(task_output_dir, exist_ok=True)

            output_file = task_output_dir / "result.txt"
            logger.info(f"çµæžœãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜å…ˆ: {output_file}")

            # Claude CLI å‘¼ã³å‡ºã—ï¼ˆæ‹¡å¼µãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä½¿ç”¨ï¼‰
            if self.check_claude_cli():
                cmd = ["claude", "--model", self.model, "--allowedTools", "Edit,Write,FileSystem", "--print"]
                logger.info(f"CLIã‚³ãƒžãƒ³ãƒ‰å®Ÿè¡Œ: {' '.join(cmd)}")
                try:
                    result = subprocess.run(
                        cmd,
                        input=enhanced_prompt,  # RAGæ‹¡å¼µãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ä½¿ç”¨
                        capture_output=True,
                        text=True,
                        cwd="/root/ai_co/output",
                        timeout=300
                    )
                    logger.info(f"CLIå®Ÿè¡Œçµ‚äº† ãƒªã‚¿ãƒ¼ãƒ³ã‚³ãƒ¼ãƒ‰: {result.returncode}")

                    if result.returncode == 0:
                        output_text = result.stdout
                        logger.info(f"å‡ºåŠ›æ–‡å­—æ•°: {len(output_text)}")
                        status = "completed"
                    else:
                        output_text = f"ã‚¨ãƒ©ãƒ¼: {result.stderr}"
                        logger.error(f"CLIã‚¨ãƒ©ãƒ¼: {result.stderr}")
                        status = "failed"

                except subprocess.TimeoutExpired:
                    output_text = "ã‚¨ãƒ©ãƒ¼: CLIã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ(5åˆ†)"
                    logger.error("CLIã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç™ºç”Ÿ")
                    status = "failed"
            else:
                logger.warning("Claude CLIæœªæ¤œå‡ºã€‚ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ãƒ‰ã§å¿œç­”ç”Ÿæˆã€‚")
                output_text = f"[ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¿œç­”]\nã‚¿ã‚¹ã‚¯ID: {task_id}\nãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ: {prompt}\n"
                status = "completed"

            # ãƒ•ã‚¡ã‚¤ãƒ«ã«çµæžœä¿å­˜
            try:
                with open(output_file, 'w', encoding='utf-8') as f:
                    f.write(f"=== Task Info ===\n")
                    f.write(f"Task ID: {task_id}\n")
                    f.write(f"Worker: {self.worker_id}\n")
                    f.write(f"Timestamp: {datetime.now().isoformat()}\n")
                    f.write(f"Model: {self.model}\n")
                    f.write(f"RAG Applied: {'Yes' if len(enhanced_prompt) > len(prompt) else 'No'}\n")
                    f.write(f"\n=== Original Prompt ===\n{prompt}\n")
                    f.write(f"\n=== Response ===\n{output_text}\n")
                    f.write(f"=== End ===\n")
                logger.info(f"çµæžœãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜æˆåŠŸ: {output_file} (ã‚µã‚¤ã‚º: {output_file.stat().st_size} bytes)")
            except Exception as e:
                logger.error(f"çµæžœãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜å¤±æ•—: {e}")
                traceback.print_exc()

            # ðŸ§  RAGæ©Ÿèƒ½ï¼šã‚¿ã‚¹ã‚¯å±¥æ­´ã‚’ä¿å­˜ï¼ˆè¦ç´„è‡ªå‹•ç”Ÿæˆï¼‰
            try:
                rag_success = self.rag.save_task_with_summary(
                    task_id=task_id,
                    worker=self.worker_id,
                    prompt=prompt,  # å…ƒã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ä¿å­˜
                    response=output_text,
                    status=status,
                    task_type=task_type
                )
                if rag_success:
                    logger.info(f"ðŸ§  RAGå±¥æ­´ä¿å­˜æˆåŠŸ: {task_id}")
                else:
                    logger.warning(f"RAGå±¥æ­´ä¿å­˜å¤±æ•—: {task_id}")
            except Exception as e:
                logger.error(f"RAGå±¥æ­´ä¿å­˜ä¾‹å¤–: {e}")

            # çµæžœã‚­ãƒ¥ãƒ¼ã¸é€ä¿¡
            result_data = {
                "task_id": task_id,
                "worker": self.worker_id,
                "status": status,
                "output_file": str(output_file),
                "timestamp": datetime.now().isoformat()
            }

            try:
                self.channel.basic_publish(
                    exchange='',
                    routing_key='result_queue',
                    body=json.dumps(result_data),
                    properties=pika.BasicProperties(delivery_mode=2)
                )
                logger.info(f"çµæžœã‚’result_queueã«é€ä¿¡: {task_id}")
            except Exception as e:
                logger.error(f"çµæžœã‚­ãƒ¥ãƒ¼é€ä¿¡å¤±æ•—: {e}")

            ch.basic_ack(delivery_tag=method.delivery_tag)

        except Exception as e:
            logger.error(f"ã‚¿ã‚¹ã‚¯å‡¦ç†ä¾‹å¤–: {e}")
            traceback.print_exc()
            ch.basic_nack(delivery_tag=method.delivery_tag, requeue=True)

    def check_claude_cli(self):
        try:
            result = subprocess.run(["which", "claude"], capture_output=True)
            return result.returncode == 0
        except:
            return False

    def start(self):
        if not self.connect():
            logger.error("RabbitMQæŽ¥ç¶šå¤±æ•—ã«ã‚ˆã‚Šãƒ¯ãƒ¼ã‚«ãƒ¼ã‚’èµ·å‹•ã§ãã¾ã›ã‚“ã€‚")
            return

        self.channel.basic_qos(prefetch_count=1)
        self.channel.basic_consume(queue='task_queue', on_message_callback=self.process_task)

        logger.info(f"ðŸ§  {self.worker_id} RAGçµ±åˆç‰ˆèµ·å‹•å®Œäº† - task_queueå¾…æ©Ÿä¸­...")
        try:
            self.channel.start_consuming()
        except KeyboardInterrupt:
            logger.info("ãƒ¯ãƒ¼ã‚«ãƒ¼åœæ­¢ä¸­...")
            self.channel.stop_consuming()
            self.connection.close()


if __name__ == "__main__":
    worker_id = sys.argv[1] if len(sys.argv) > 1 else "worker-1"
    worker = TaskWorker(worker_id)
    worker.start()
